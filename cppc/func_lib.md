#	Cpp函数

##	*Function*

函数：被组织成具有特定名称的独立单元的代码块

###	函数定义、声明

```cpp
type name(parameters){
	body
}
```

> - `name`：函数名
> - `parameters`：逗号分隔的函数**形参列表**

####	*Parameters*

形参：调用函数时用以传递实参的占位符

-	类似局部变量，但是在调用时使用实参进行初始化

#####	*Default Parameter*

默认形参：具有默认值的形参，调用时可以不给其传递实参值

-	默认形参只能出现在函数声明中，不能出现在函数定义中
-	默认形参只能出现在形参列表末尾

> - 默认形参在C++中有滥用的问题，更倾向使用函数重载完成默认
	形参的功能

#####	*Value Parameter*

值参数：函数调用时，被调函数中值形参将获得主调函数的实参的
**值拷贝**

-	被调函数中传入的实参变量值仅改变被调用函数**局部形参**
	的值，对主调函数中实参变量的值没有影响

#####	*Reference Parameter*

引用参数`&`：函数调用时，被调函数中引用形参获得主调函数中实参
引用

-	主调函数、被调函数共享实参变量的统一存储空间

-	对应引用形参的形参必须是**可赋值**的量，如：变量名

-	常用于
	-	函数需要返回多余一个值，此时将函数转换为过程，并通过
		实参列表向函数传递及从函数返回数值

####	*Prototype*

函数原型/函数声明：函数定义的首行加上分号结尾组成

-	提供编译器大部分情况下**仅仅需要的**形参、返回值类型

-	函数原型中形参名可选，但是好的形参名有助于可读性

-	如果函数先定义后调用，可以不需要编写函数原型，但这种代码
	风格和自顶向下的程序设计风格相悖

####	*Signature*

函数签名：函数的形参模型

> - 和函数原型相比，不包括返回值类型

####	*Overloading*

**函数名**重载：使用相同名字的不同版本函数

-	函数名相同、函数参数列表不同是合法的，即函数签名不同即
	合法（函数原型不同不一定合法，返回值类型不同）

	-	形参数量
	-	形参类型

-	编译器遇到调用函数的函数名指代不唯一时，编译器会检查所传
	实参，选择最合适的函数版本

###	*Calling*

使用函数名调用函数代码（块）的行为

-	函数被调用后将会获得函数*argument*提供的值，执行函数功能
	
-	**返回函数调用点**：记忆主调程序工作情况，以便程序
	返回函数调用的确切位置是函数调用机制的主要特性之一

> - *argument*：实参，调用函数时的表达式，用于向函数传递信息
> - 调用函数前必须对函数提供声明或定义，以使编译器可以判断
	函数调用是否与其定义兼容

####	函数调用步骤

-	*主调函数*将实参与自己上下文中的**若干局部变量**绑定来
	计算每个参数值

	-	实参通常为表达式，计算其值时可能涉及操作符、其他函数
		调用
	-	新的函数开始执行前，主调函数会对传如的实参合法性进行
		验证

-	系统为新函数所需的所有局部变量（包括形参）创建新的存储
	空间

	-	这些变量将被分配在内存中*stack frame*区域中

-	每个实参值将被传入到函数相应的形参变量中

	-	对于包含多个形参的函数，实参对形参的**值拷贝**将按照
		对应函数形参顺序执行
	-	如有必要，编译器将**像变量赋值**一样，执行从实参到
		形参的类型转换

-	执被调函数体中语句，直到遇到`return`语句或没有多余语句

-	如果函数有返回值，函数体内`return`语句表达式的值将被计算
	，作为返回值返回给主调函数

	-	如有必要，编译器将**执行数值的类型转换**，确保返回值
		符合**被调函数值的类型要求**（被调函数返回之前转换）
		```cpp
		int rint(){
			return 9.8;
				// 返回整形
		}
		int main(){
			double j = rint();
				// `j`被初始化为`9.8`
		}
		```

-	删除为函数调用创建的栈帧，其中所有局部变量被系统清理

-	将函数返回值（若存在）代入到调用函数调用点的位置

###	优点

-	将某段操作代码组织起来，编写一次、多次使用，可以显著降低
	程序规模，而且使程序更易于维护

-	将大型程序分解成多个易于管理的小部分

	-	好的、独特的分解分解方法，会使得每个函数都是紧密的
		单元，使得问题整体更加易于理解

	-	*top-down design*：过程一般从主程序开始分解问题，
		逐步求精

	-	即使函数只在程序中使用一次，定义函数依然值得

##	库

定义C++库时，需要提供：*interface*、*implementation*

-	类库向用户提供了一组函数、数据类型，以实现
	*programming abstraction*

-	类库像函数一样，提供了可用于降低复杂度的方法，但也需要
	在建库时考虑更多细节，简化程度取决于接口设计的优劣

###	接口、实现

-	接口：允许库用户在不了解库实现细节的情况下使用库中库函数

	-	典型接口可提供多种定义、声明，称为*interface entry*
		-	函数声明
		-	类型定义
		-	常量定义

-	实现：说明库的底层实现细节

-	C++接口通常写在`.h`头文件中，实现在同名`.cpp`文件

####	接口设计原则

-	*unified*：统一性，接口必须按照统一主题来定义一致的抽象
-	*simple*：简单性，接口必须向用户隐藏实现的复杂性
-	*sufficient*：充分性，接口必须提供足够功能满足用户的需求
-	*general*：通用性，良好设计的接口必须有高度适用性
-	*stable*：稳定性，接口在函数底层实现改变时也要有不变的
	结构、功能

###	使用

```cpp
$ g++ -o a.out src.cpp -L /path/to/library -l lib_name
	// 动态、静态链接库均可
	// `-L`指定（额外）库文件搜索路径
$ g++ -o a.out src.cpp liblib_name.a
	// 静态链接库可以类似于`.o`文件使用
```

-	编译时使用指定链接库名只需要指定`lib_name`，编译器自动
	解析为`lib[lib_name].so`

-	gcc/ld为可执行文件链接库文件时搜索路径

	-	`/lib`、`/usr/lib64`、`/usr/lib`、`/usr/lib64`
	-	`LIBRARY_PATH`中包含的路径

###	*Static Link Library*

静态链接库`.a`/`.lib`：二进制`.o`中间目标文件的集合/压缩包

-	链接阶段被引用到静态链接库会和`.o`文件一起，链接打包到
	可执行文件中
-	程序运行时不再依赖引用的静态链接库，移植方便、无需配置
	依赖
-	相较于动态链接库浪费资源、空间
-	相较于`.o`二进制的文件，管理、查找、使用方便

####	生成静态链接库

-	linux下使用`ar`、windows下使用`lib.exe`，即可将目标文件
	压缩得到静态链接库
	
-	库中会对二进制文件进行编号、索引，以便于查找、检索

	```shell
	$ g++ -c src.cpp src.o
	$ ar -crv libsrc.a src.o
		// 生成静态库`libsrc.a`
	```

-	linux下静态库命名规范：`lib[lib_name].a`（必须遵守，因为
	链接时按此规范反解析名称）

###	*Dynamic Link Library*

动态链接/共享库`.so`/`.dll`

-	动态链接库在程序链接时不会和二进制中间文件一起，被打包
	进可执行文件中，而时在程序运行时才被
	*dynamic linker/loader*载入

-	不同程序调用相同库，在内存中只需要该共享库一份实例，规避
	空间浪费、实现资源共享

-	解决了静态库对程序更新、部署、发布的麻烦，可以通过仅仅
	更新动态库实现增量更新

-	执行环境需要安装依赖、配置环境变量（或者是编译时指定依赖
	搜索路径）

####	生成动态链接库

-	直接使用编译器即可创建动态库

	```cpp
	$ g++ -f PIC -c src.cpp -o src.o
		# PIC: position independent code
		# 创建地址无关的二进制目标文件w
	$ g++ -shared -nosname libsrc.so -o libsrc.so.1 src.o
		# 生成动态链接库
	```

-	动态链接库命名规则：`lib[libname].so`（必须按照此规则
	命名，因为链接时按照此规则反解析库名称）

####	*dynamic linker/loader*

动态载入器：先于executable模块程序工作，并获得控制权

-	对于linux下elf格式可行程序，即为`ld-linux.so*`
-	按照一定顺序搜索需要动态链接库，定位、加载

#####	搜索次序

`ld-linux.so*`依次搜索以下，定位动态链接库文件、载入内存

-	elf文件的`DT_RPATH`段：**链接/编译**时指定的搜索
	库文件的路径，存储在elf文件中

	-	g++通过添加`-Wl,rpath,`、ld通过`-rpath`参数指定添加
		的路径
	-	若没有指定rpath，环境变量`LD_RUN_PATH`中路径将被添加

	```c
	$ objdump -x elf_exe
		# 查看elf文件的`DT_RPATH`
	$ g++ -Wl,-rpath,/path/to/lib
		# 在g++命令中直接给出链接参数
		# 也可以使用链接器`ld`链接时给出
	$ g++ -Wl,--enable-new-tags,-rpath,'$ORIGIN/../lib'
		# 使用相对路径
		# Makefile中使用时需要转义`$$ORIGIN/../lib`
	```

-	`LD_LIBRARY_PATH`环境变量

	-	优先级较高，可能会覆盖默认库，应该避免使用，会影响
		所有动态链接库的查找
	-	不需要root权限，同时也是影响安全性

-	`/etc/ld.so.cache`文件列表（其中包括所有动态链接库
	文件路径）

	-	`/lib`、`/lib64`、`/usr/lib`、`/usr/lib64`隐式
		默认包含，优先级较低、且逐渐降低

	-	其由`ldconfig`根据`/etc/ld.so.conf`生成，库文件添加
		进已有库路径、添加路径至`/et/ld.so.conf`后，需要通过
		`ldconfig`更新缓存才能被找到

	> - `ldconfig`具体参见*linux/shell/cmd_sysctl*

> - 因为`LD_LIBRARY_PATH`的缺点，建议使用`LD_RUN_PATH`，在
	链接时就指定动态库搜索路径






