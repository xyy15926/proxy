---
title: 数据模型--基本数据类型
categories:
  - Python
  - Py3Ref
tags:
  - Python
  - Py3Ref
  - Data Model
  - Variable
  - Object
  - Value
  - Datatype
date: 2019-06-05 11:05:43
updated: 2022-05-25 11:18:48
toc: true
mathjax: true
comments: true
description: 数据模型--基本数据类型
---

##	对象、值、类型

-	对象：Python 中对数据的抽象
	-	Python 中所有数据都是由对象、对象间关系表示

> - 按冯诺依曼 “存储程序计算机” 模型，代码本身也是由对象表示

###	编号、类型、值

> - 每个对象都有各自**编号**、**类型**、**值**

-	编号：可以视为对象在内存中地址，对象创建后不变
	-	`id()` 函数：获取代表对象编号的整形
	-	`is` 算符：比较对象编号判断是否为同一对象

> - CPython：`id()` 返回值即存放对象的内存地址

-	值：通过一些特征行为表征的抽象概念
	-	对象值在python中是抽象概念
		-	对象值没有规范的访问方法
		-	不要求具有特定的构建方式，如：值由其全部数据属性组成
	-	对象值可变性由其类型决定
	-	比较运算符实现了 **特定对象值概念**，可认为是通过实现对象比较间接定义对象值

-	类型：决定对象支持的操作、可能取值，对象创建后不变
	-	`type()` 函数：返回对象类型
	-	可变类型：值可改变的对象
		-	返回新值的运算不允许返回已存在对象
			-	`c = []; d = []` 会保证 `c`、`d` 指向不同、单独空列表
			-	`c = d = []` 会将同一对象赋给 `c`、`d`
	-	不可变类型：值（直接引用的值）不可改变的对象
		-	返回新值的运算可能返回同类型、同取值现有对象引用
			-	`a = 1; b = 1` 执行后 `a`、`b`可能指向相同对象`1`（取决于具体实现）
		-	不可变类型包含可变对象的引用，前者值可能随后者值改变而改变

> - Python 是动态强类型语言
> - CPython：相同整形值都引用同一个对象

###	对象销毁

-	对象不会被显式销毁，无法访问对象可能会被作为垃圾回收
	-	垃圾回收的实现质量有不同，仅需保证可访问对象不被回收即可
	-	包含对外部资源的引用的对象被垃圾回收时资源被释放，但是因垃圾回收不确定发生，建议显式关闭此类对象以释放资源
	-	以下情况下，正常应该被回收的对象可能继续存活
		-	使用实现的跟踪、调试功能
		-	通过`try...except...`语句捕捉异常

> - `del` 仅是移除名称绑定
> - CPython：使用带有（可选）延迟检测循环链接垃圾的引用计数方案，在对象不可访问时立刻回收其中大部分，但不包含循环引用的垃圾

##	标准类型层级结构

-	以下仅列出 Python 内置类型，扩展模块可以定义更多类型
	-	某些类型有特殊属性，其定义在未来可能改变，不应用作通常使用

> - <https://docs.python.org/zh-cn/3.9/reference/datamodel.html#the-standard-type-hierarchy>

###	`None`、`NotImplemented`、`Ellipsis`

-	`NoneType`：只有一种取值，`None` 是具有此值的唯一对象
	-	通过内置名称 `None` 访问
	-	多数情况表示空值，如
		-	未显式指明返回值函数返回 `None`
	-	逻辑值：假

-	`NotImplementedType`：只有一种取值，`NotImplemented` 是具有此值的唯一对象
	-	通过内置名称 `NotImplemented` 访问
	-	数值、富比较方法在操作数没有该实现操作时应返回此值
		-	返回 `NotImplemented` 前，解释器会依据运算符尝试反射方法、委托回退方法
	-	逻辑值：真

-	`Ellipsis`：只有一种取值，`Ellipsis`是具有此值的唯一对象
	-	通过字面值`...`、内置名称`Ellipsis`访问
	-	逻辑值：真

###	`numbers.Number`

-	`number.Number`：由数字字面值创建，被作为算法运算符、算数内置函数返回结果
	-	不可变：一旦创建其值不再改变
	-	类似数学中数字，但也受限于计算机对数字的表示方法

-	`numbers.Integral`：表示数学中整数集合，可细分为
	-	`int`：整形，表示 **任意大小数字，仅受限于可用内存**
		-	变换、掩码运算中以二进制表示
		-	负数以2的补码表示（类似符号位向左延伸补满空位）
	-	`bool`：布尔型，表示逻辑值真、假
		-	`True`、`False` 是唯二两个布尔对象
		-	整形子类型：在各类场合中行为类似整形 `1`、`0`，仅在转换为字符串时返回 `"True"`、`"False"`

-	`numbers.Real`、`float`：表示机器级 **双精度浮点数**
	-	接受的取值返回、溢出处理取决于底层结构、Python 实现
	-	Python 不支持单精度浮点（没必要因为节省处理器、内存消耗而增加语言复杂度）

-	`numbers.Complex`、`complex`：以一对机器级双精度浮点数表示复数值
	-	实部、虚部：可通过只读属性`z.real`、`z.imag`获取

####	特殊取值

```python
infty = float("inf")
neg_infty = float("-inf")		# 正/负无穷大
nan = float("nan")				# Not a Number
```

-	特殊取值根据定义 `==`、`is` 肯定返回 `False`
	-	`float.__eq__()` 内部应该有做检查，保证 `==` 返回 `False`
	-	每次会创建“新”的 `nan`、`infty`

> - 连续执行 `id(float("nan"))` 返回值可能相等，这是垃圾回收实现的结果
> - `np.nan` 即均为 `numpy` 初始化的同一个 `float("nan")`，故 `np.nan is np.nan` 返回 `True`

###	序列

-	序列：表示以非负整数作为索引的有限有序集
	-	不可变序列类型：对象一旦创建不能改变
		-	内生不可变序列包括
			-	`str`
			-	`tuple`
			-	`bytes`
			-	`range`：非基本序列类型
	-	可变序列：创建后仍可被改变值
		-	内生可变序列包括
			-	`list`
			-	`bytesarray`
		-	可变序列下标、切片标注可被用于赋值、`del` 目标

####	一般序列

-	`tuple` 元组：元组中条目可以是任意 Python 对象
	-	元组创建
		-	一对圆括号创建空元组
		-	逗号分隔
			-	单项元组：后缀逗号`a,`、`(a,)`
			-	多项元组：`a,b,c`、`(a,b,c)`
		-	内置构建器：`tuple`、`tuple(iterable)`

-	`list` 列表：列表中条目可以是任意 Python 对象
	-	构建方式
		-	方括号括起、项以逗号分隔：`[]`、`[a]`、`[a,b]`
		-	列表推导式：`[x for x in iterable]`
		-	类型构造器：`list(iterable)`

-	`range`：不可变数字序列类型
	-	构建方式

```python
class range(stop)
class range(start=0, stop[, step=1])
```

####	文本序列

-	`str` 字符串：由 Unicode 码位值组成不可变序列（应该是 *UTF16-bl* 编码）
	-	范围在 `U+0000~U+10FFFF` 内所有码位值均可在字符串中使用
	-	不存在单个“字符”类型
		-	字符串中单个字符为长度为1字符串
	-	不存在可变字符串类型
		-	可以用 `str.join()`、`io.StringIO` 高效连接多个字符串
			片段
	-	字符串构建
		-	字符串字面值 `""`
		-	内置构造器 `str()`

####	二进制序列

-	`bytes` 字节串：单个字节构成的不可变序列
	-	类似整数构成序列
		-	每个条目都是8位字节
		-	取值范围 `0~255`，但只允许 *ASCII* 字符 `0-127`
		-	下标 `b[n]` 返回整数，切片返回 `bytes` 对象
		-	可通过 `list(bytes)` 将 `bytes` 对象转换为整数构成列表
	-	字节串构建
		-	字节串字面值 `b""`
		-	内置构造器 `bytes()`
			-	指定长度零值填充：`bytes(10)`
			-	整数组成可迭代对象：`bytes(range(20))`
			-	通过缓冲区协议复制现有二进制数据：`bytes(obj)`

-	`bytearray` 字节数组：字节串可变对应版本，其他同不可变 `bytes`
	-	字节数组构建
		-	字节数组没有字面值语法，只能通过构造器构造
		-	可变，构建空字节数组有意义

-	`memoryview` 内存视图：允许 Python 代码访问对象内部数据
	-	内存视图元素：原始对象 `obj` 处理的基本内存单元
		-	对简单 `bytes`、`bytesarray` 对象，一个元素就是一字节
		-	`array.array` 等类型可能有更大元素
	-	若对象支持缓冲区协议，则无需拷贝
		-	支持缓冲区协议的内置对象包括 `bytes`、`bytesarray`
	-	内存视图支持索引抽取、切片
		-	若下层对象可选，则支持赋值，但切片赋值不允许改变大小

###	集合

-	集合：表示**不重复**、**不可变**对象组成的无序、有限集合
	-	特性
		-	不能通过下标索引
		-	可以迭代
		-	可以通过内置函数`len`返回集合中条目数量
	-	常用于
		-	快速成员检测、去除序列中重复项
		-	进行交、并、差、对称差等数学运算
-	Python 中集合类似 `dict` 通过 Hash 实现
	-	集合元素须遵循同字典键的不可变规则
	-	数字：相等的数字 `1==1.0`，同一集合中只能包含一个

-	`set()` 集合：由具有唯一性的 *hashable* 对象组成的多项无序集
	-	集合创建
		-	`set()`内置构造器
		-	花括号包括、逗号分隔元组列表：`{a, b}`

-	`frozenset()` 冻结集合：不可变集合，可哈希，可以用作集合元素、字典键
	-	冻结集合创建
		-	`frozenset()`内置构造器

###	映射

-	映射：表示任何索引集合所索引的对象的集合
	-	通过下标`a[k]`可在映射`a`中选择索引为`k`的条目
		-	可在表达式中使用
		-	可以作为赋值语句、`del`语句的目标

-	`dict` 字典：可由 **几乎任意值作为索引** 的有限个对象可变集合
	-	字典的高效实现要求使用键hash值以保持一致性
		-	不可作为键的值类型
			-	包含列表、字典的值
			-	其他通过对象编号而不是值比较的可变对象
		-	数字：相等的数字 `1==1.0` 索引相同字典条目
	-	创建字典
		-	花括号括起、逗号分隔键值对 `{key:value,}`
		-	内置字典构造器 `dict()`

> - `dbm.ndbm`、`dbm.gnu`、`collections`模块提供额外映射类型

###	可调用类型

####	用户定义函数（对象）

-	用户定义函数（对象）：通过函数定义创建，调用时附带参数列表
	-	函数对象支持获取、设置任意属性
		-	用于给函数附加元数据
		-	使用属性点号`.`获取、设置此类属性

-	函数对象包含以下特殊属性
	-	大部分属性赋值时会检查赋值有效性
	-	赋值可用于不重定义函数的情况下修改函数的部分元信息，影响函数执行结果
		-	对 `__defaults__` 赋值即可改变函数参数的默认值

|属性|含义|读写|
|-----|-----|-----|
|`__doc__`|函数文档|可写|
|`__name__`|函数名|可写|
|`__qualname__`|函数 *Qualified Name* 完整限定名称|可写|
|`__module__`|所属模块|可写|
|`__defaults__`|参数默认值构成的元组|可写|
|`__code__`|编译后函数体代码对象|可写|
|`__globals__`|函数中全局变量字典（命名空间）的引用|只读|
|`__dict__`|命名空间支持的函数属性|可写|
|`__closure__`|函数 **闭包变量绑定单元** 的元组|只读|
|`__annotations__`|函数参数、`return` 标注字典|可写|
|`__kwdefaults__`|*keyword-only* 参数的默认值字典|可写|

####	（实例、绑定）方法（对象）

-	(实例、绑定）方法（对象）：使用属性表示法调用、定义在类命名空间中的函数
	-	实例方法用于将类、类实例同可调用对象结合起来
	-	方法支持只读的获取底层函数对象任意属性
		-	“方法属性” 实际保存在下层函数对象中
		-	直接设置方法地属性将 `raise AttributeError`

|属性名|含义|
|-----|-----|
|`__self__`|类实例（由用户定义函数创建的方法）、类（由类方法创建的方法）|
|`__func__`|底层函数|
|`__doc__`|方法文档，同 `__func__.__doc__`|
|`__name__`|方法名，同 `__func__.__name__`|
|`__module__`|定义方法所在模块名|

-	通过类实例、类获取类属性时，若属性为用户定义函数、类方法时，方法被创建
	-	**每次** 从实例获取类属性（函数）时都会发生，函数对象到实例方法对象的转换
		-	“有时” 可将属性赋值给本地变量、调用实现性能优化
		-	非用户定义函数、不可调用对象在被获取时不会发生转换
		-	作为实例的属性的用户定义函数不会被转换为方法
	-	此时，函数、类方法类型 “发生变化”
		-	用户定义函数：`function` 转换为 `method`
		-	C 包装函数：`wrapper_descriptor` 转换为 `method-wrapper`
	-	方法被调用时，等价于调用相应下层函数 `m.__func__(m.__self__,....)`
		-	`__self__` 在用户定义函数中为类实例、在类方法中为类
		-	`__self__` 作为函数的首个实参插入参数列表

> - CPython3 中以上特性依赖于 `__getattribute__` （描述器），即函数属性被访问（通过 `.` 等方式）时被转换为方法
> - 此 “类方法” 即下述 *Class Method Object*，其实现也依赖描述器

####	内置函数、内置方法

|属性名|含义|
|-----|-----|
|`__self__`|`None`（内置函数）、对象（内置方法）|
|`__doc__`|函数文档|
|`__name__`|函数名|
|`__module__`|函数所在模块名|

-	内置函数：对 C 函数的外部封装
	-	参数数量、类型由 C 函数决定
	-	包括以下两种类型
		-	`builtin_function_or_method`
		-	`wrapper_descriptor`
	-	案例
		-	`len()`
		-	`math.sin()`

-	内置方法：内置函数另一种形式，但隐式传入当前实例作为 C 函数额外参数（类似实例方法）
	-	内置方法由支持其的类型描述
	-	类型为
		-	`method_descriptor`
	-	案例
		-	`list.append()`

####	协程函数

-	协程函数：用 `async def` 定义的函数、方法
	-	调用时返回 `coroutine` 对象
	-	协程函数可能包含

####	生成器函数、异步生成器函数

-	生成器函数：使用 `yield` 语句的函数、方法
	-	调用时返回生成器迭代器对象，此对象可执行函数体
		-	调用 `iter.__next__()` 方法将导致函数运行直到 `yield` 提供值
		-	执行至 `return`、末尾时将 `raise StopIteration`


-	异步生成器函数：使用 `async def` 定义，并包含 `yield` 语句的函数、方法
	-	调用时返回生成器迭代器对象，此对象可在 `async for` 中执行函数体
		-	调用 `aiter.__anext__()` 方法将返回 `awaitable`，被 `await` 后将执行直到 `yield` 通提供值
		-	执行至 `return`、末尾时将 `raise StopIteration`

####	类、类实例

-	类：类可调用，通常作为返回其自身实例的工厂
	-	可覆盖 `__new__()` 改变类调用行为

-	类实例：定义有 `__call__()` 方法的类实例可调用

###	*Module*

-	模块：Python 代码的基本组织单元
	-	导入系统创建
		-	`import` 语句
		-	`importlibd.import_module()`、`__import__()` 函数
	-	模块对象具有由字典 `__dict__` 实现的命名空间
		-	属性引用：被转换为该字典中查找`m.__dict__['x']`
		-	属性赋值：更新模块命名字典空间
		-	不包含用于初始化模块 `__init__.py` 的代码对象
		-	模块中定义的函数的 `__globals__` 属性引用此命名空间

|属性名|含义|
|-----|-----|
|`__name__`|模块名|
|`__doc__`|模块文档|
|`__annotaion__`|包含变量标注的字典|
|`__file__`|模块对应的被加载文件的路径名，某些可能无此属性（静态链接到解释器 C 模块等）|
|`__dict__`|以字典对象表示的模块命名空间|

> - CPython：由于 CPython 清理模块字典的设定，模块离开作用域时模块字典将被清理，即使字典还有活动引用，可以复制该字典、保持模块状态以直接使用其字典

###	自定义类

|属性名|含义|
|-----|-----|
|`__name__`|类名|
|`__module__`|类所在模块名|
|`__dict__`|以字典对象表示的类命名空间|
|`__bases__`|基类元组，按在基类列表中出现顺序排列|
|`__doc__`|文档字符串，类定义的首条语句（字符串）|
|`__annotaion__`|包含变量标注的字典|
|`__qualname__`|*Qualified Uame*，完整限定名称|

-	自定义类：通过类定义创建
	-	类属性查找
		-	每个类通过字典对象 `__dict__` 实现独立命名空间，类属性引用一般会在此命名空间中查找
			-	`C.x` 会被转化为 `C.__dict__["x"]`
			-	存在钩子对象以允许其他定位属性的方式
		-	未发现某个属性时，会继续在基类中查找（使用 *C3 MRO* 算法）
	-	类属性获取、赋值
		-	类属性赋值只更新类字典，不更新基类字典
		-	类属性产生静态方法对象时，该类属性转换为静态方法封装的对象
		-	类属性产生类方法对象时，该类属性转换为实例方法对象
		-	可通过 *实现描述器* 从 `__dict__` 获取属性
	-	类可被调用产生类实例

> - *Qualified Name* ：以点号分隔的名称，显示模块全局作用域到模块中某个定义类、函数、方法的路径

###	类实例

|属性名|含义|
|-----|-----|
|`__dict__`|属性字典|
|`__class__`|实例对应类|

-	类实例：通过调用类对象创建
	-	类实例属性查找
		-	类实例通过字典对象 `__dict__` 实现独立命名空间，类实例属性引用一般会在此命名空间中查找
		-	未发现某个属性时，会继续在类属性中查找
		-	可通过 *实现描述器* 从 `__dict__` 外获取属性
		-	若无法找到属性，可通过 `__getattr__()` 自定义行为
	-	类实例属性获取、赋值
		-	类属性为用户定义函数、类函数时被转换为（封装为）方法
		-	静态方法、类方法属性同样被转换
		-	对类实例属性的赋值只更新类实例字典，不更新类字典
		-	若类实现 `__setattr__()`、`__delattr__()` 方法，方法会被调用，而不是直接更新类实例字典

###	*I/O* 对象（文件对象）

-	文件对象：表示打开的文件
	-	创建文件对象
		-	`open()`内置函数
		-	`os.popen()`、`os.fdopen()`
		-	`socket.makefile()`
	-	`sys.stdin`、`sys.stdout`、`sys.stderr` 会初始化为对应于解释器的标准输入、输出、错误流对象
		-	均以文本模式打开
		-	遵循`io.TextIOBase`抽象类所定义接口

###	内部类型

-	内部类型：在解释器内部使用的类型
	-	未来可能随解释器版本更新而变化
	-	以下对象在正常代码中一般不会涉及，基本由 Python 解释器内部自行生成、使用

####	*Code Object*

|属性名|含义|
|-----|-----|
|`co_name`|函数名称|
|`co_argcount`|位置参数数量|
|`co_posonlyargcount`|仅限位置参数的数量|
|`co_kwonlyargcount`|仅限关键字参数的数量|
|`co_nlocals`|函数使用的本地变量数量（包括参数）|
|`co_varnames`|包含本地变量名称的元组|
|`co_freevars`|包含自由变量的元组|
|`co_cellvars`|被嵌套函数所引用的局部变量名称元组|
|`co_code`|表示字节码指令序列的字符串|
|`co_consts`|包含字节码所使用的字面值元组|
|`co_names`|包含字节码所使用的名称的元组|
|`co_filenames`|被编译代码所在文件名|
|`co_firstlineno`|函数首行行号|
|`co_lnotab`|以编码表示的字节码偏移量到行号映射的字符串|
|`co_stacksize`|要求栈大小（包括本地变量）|
|`co_flags`|以编码表示的多个解释器所用标志的整形数|

-	代码对象：“伪编译” 为字节的可执行 Python 代码，也称 *bytecode*
	-	代码对象和函数对象区别
		-	代码对象不包含上下文；函数对象包含对函数全局对象（函数所属模块）的显式引用
		-	默认参数值存放于函数对象而不是代码对象
		-	代码对象不可变，也不包含对可变对象的应用
	-	代码对象由内置 `compile()` 函数返回
		-	可以通过函数对象 `__code__` 属性从中提取
		-	可以作为参数传给 `exec()`、`eval()` 函数执行

-	属性说明
	-	`co_consts`：若代码对象表示一个函数，第一项为函数文档字符|
	-	`co_flags`
		-	`0x04` 位：函数使用 `*arguments` 接受任意数量位置参数
		-	`0x08` 位：函数使用 `**keywords` 接受任意数量关键字参数
		-	`0x20` 位：函数是生成器
		-	`0x2000` 位：函数编译时使用启用未来除法特性
		-	其他位被保留为内部使用

####	*Frame Objects*

|属性|含义|读写|
|-----|-----|-----|
|`f_back`|前一帧对象，指向主调函数，最底层堆栈帧则为`None`|只读|
|`f_code`|此栈帧中所执行的代码对象|只读|
|`f_locals`|查找本地变量的字典|只读|
|`f_globals`|查找全局变量|只读|
|`f_builtins`|查找内置名称|只读|
|`f_lasti`|精确指令，代码对象字节码字符串的索引|只读|
|`f_trace`|`None`，或代码执行期间调用各类事件的函数（供调试器使用，通常每行新源码触发一个事件）|可写|
|`f_trace_lines`|设置是否每行新源码触发一个事件|可写|
|`f_trace_opcodes`|设置是否允许按操作码请求事件|可写|
|`f_lineno`|帧当前行号|

-	栈帧对象：执行帧
	-	可能出现在回溯对象中，还会被传递给注册跟踪函数

-	说明
	-	可以通过写入 `f_lineno` 实现 `Jump` 命令


-	帧对象支持一个方法
	-	`.clear()`：清楚该帧持有的全部对本地变量的引用
		-	若该栈帧为属于生成器，生成器被完成
		-	有助于打破包含帧对象的循环引用
		-	若帧当前正在执行则会 `raise RuntimeError`

####	*Traceback Objects*

|属性|含义|读写|
|-----|-----|-----|
|`tb_frame`|执行当前层级的执行栈帧|只读|
|`tb_lineno`|给出发生异常所在行号|只读|
|`tb_lasti`|最后具体指令|只读|
|`tb_next`|栈跟踪中下一层级（通往发生异常的帧），没有下一层级则为`None`|可写|

-	回溯对象：表示异常的栈跟踪记录
	-	异常被印发时会自动创建回溯对象，并将其关联到异常的可写 `__traceback__` 属性
		-	查找异常句柄使得执行栈展开时，会在每个展开层级的当前回溯之前插入回溯对象
		-	进入异常句柄时，栈跟踪将对程序启用
		-	获取 `sys.exc_info()` 返回的元组第三项、异常的 `__traceback__` 属性
		-	程序没有合适的处理句柄时，栈跟踪将写入标准错误
	-	可通过 `types.TracebackType` 显式创建
		-	由回溯对象创建者决定如何链接 `tb_next` 属性构成完整栈追踪

> - 若异常出现在没有匹配的 `except` 子句、没有 `finally` 子句的 `try` 中，回溯对象中的行号、最后指令可能于相应帧对象中行号不同

####	*Slices Object*

|属性|含义|读写|
|-----|-----|-----|
|`start`|下界|只读|
|`stop`|上界|只读|
|`step`|步长值|只读|

-	切片对象：表示 `__getitem__()` 方法得到的切片
	-	可以使用内置的 `slice()` 函数创建
	-	`a[start: stop]` 形式的调用被转换为 `a[slice(start, stop, None)]`

-	属性说明
	-	切片对象的 3 个只读属性可以具有任意类型

-	切片对象支持一个方法
	-	`.indices(self, length)`：计算切片对象被应用到 `length` 长度序列时切片相关信息
		-	返回值：`(start, stop, step)` 三元组
		-	索引号缺失、越界按照正规连续切片方式处理

####	*Class Method Objects*、*Static Method Objects*

-	类方法对象：通过内置 `classmethod()` 构造器对其他任意对象的封装
	-	类方法对象自身不可调用，但通常用于封装可调用的对象
	-	通常用于在类中封装用户定义方法对象，作为类属性
		-	通过类、类实例获取时，返回结果为首个参数、`__self__` 为类对象的方法
		-	提供了始终将类绑定为函数对象首个参数的方式
	-	用途
		-	实现自定义、多个构造器，如
			-	只调用 `__new__()`、绕过 `__init__`，创建未初始化的实例
			-	反序列化对象：从字节串反序列构造符合要求的对象

-	静态方法：通过内置 `staticmethod()` 构造器对其他任意对象的封装
	-	静态方法对象自身不可调用，但通常用于封装可调用的对象
	-	通常用于在类中封装用户定义方法对象，作为类属性
		-	通过类、类实例获取时，返回结果即为被封装对象
		-	提供了避免将函数对象转换为方法对象的方式
	-	用途
		-	被封装函数与一般函数类似，仅是定义在类命名空间中

> - 此类方法对象与通常意义的类方法含义不同，是指被 `classmethod()` 封装的对象，而不是可调用的方法
> - Py3中以上特性依赖于`___getattribute__`实现，即给函数套壳，定制、区分行为




