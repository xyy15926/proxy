---
title: Python执行模型
categories:
  - Python
  - Py3Ref
tags:
  - Python
  - Py3Ref
  - Execution Model
date: 2019-06-11 17:32:52
updated: 2022-04-26 13:59:44
toc: true
mathjax: true
comments: true
description: Python执行模型
---

##	程序结构

###	*Code Blocks*

-	代码块：作为一个单元执行的一段 python 文本，代码块构成 python 程序
	-	模块、函数体、类定义
	-	交互式输入的每条命令
	-	作为标准输入、命令行参数发送给解释器的脚本文件
	-	脚本命令
	-	传递给`eval()`、`exec()`的字符串参数

-	代码块在执行帧中执行
	-	执行帧包含某些用于调试的管理信息并决定代码块执行完成后操作

##	*Naming*、*Binding*

> - <https://www.runoob.com/python3/python3-namespace-scope.html>

###	*Namespace*

-	命名空间：名称到对象的映射
	-	Python 中大部分命名空间通过字典实现
		-	各命名空间独立，不同命名空间可重名，但同一命名空间内不可重名
	-	查找顺序：一般按以下顺序在命名空间查找变量（解析名称绑定）
		-	局部命名空间
		-	全局命名空间
		-	内置命名空间
	-	生命周期：命名空间的生命周期取决于对象作用域
		-	对象执行完成则命名空间生命周期结束

-	命名空间可分为三类
	-	*Built-in Namespace* 内置命名空间：全局命名空间中的 `__builtins__`
		-	`__builtins__` 为字典、或模块（此时使用模块的字典）
		-	内置命名空间中包括：内置函数 `abs` 等、内置异常 `BaseException` 等
		-	默认情况下
			-	`__main__` 模块中：`__builtins__` 为内置模块 `builtins`
			-	非 `__main__` 模块中：`__buitlins__` 是 `builtins` 模块自身的字典的别名
	-	*Global Namespace* 全局命名空间：模块命名空间
		-	全局命名空间包括：模块级变量和函数、其他导入模块
		-	模块作用域在模块第一次被导入时创建
			-	脚本的主模块总被命名为 `__main__`
	-	*Local Namespace* 局部命名空间：函数命名空间
		-	局部命名空间包含：函数中定义的变量、参数

> - *CPython* 实现细节：用户不应接触作为实现细节的 `__builtins__`，可通过 `import builtins` 并修改模块属性以重载命名空间中的值

###	*Binding of Names*

-	名称绑定的方式
	-	传递参数
	-	`import` 语句
		-	`from ... import *` 会绑定被导入模块中定义的所有公有名称（仅在模块层级上被使用）
	-	类、函数定义
	-	以标识符为目标的赋值
	-	`for` 循环开头、`with` 和 `except` 子句的 `as` 之后
	-	`del` 语句的目标也被视为绑定（虽然实际语义为解除名称绑定）

> - 名称：用于 **指代对象**，通过名称绑定操作引入

-	变量类型
	-	局部变量：在代码块中绑定的名称，且未声明为 `nonlocal`、或 `global`
	-	全局变量：在模块层级绑定的名称
		-	模块代码块中变量既为全局变量、也是局部变量
	-	自由变量：在代码块中使用但未在其中定义的变量

> - 自由变量不一定是闭包变量，函数闭包变量（`__closure__` 中元素）要求自由变量来自于父函数作用域

###	*Scope*、*Resolution of Names*

-	作用域：可以直接访问名称、命名空间的代码区域
	-	作用域定义了代码块中名称的可见性
		-	命名空间即名称的集合，同一命名空间中名称具有类似的可访问性（具体名称的作用域会因为被覆盖等原因而改变）
		-	所以，**作用域也可视为在代码区域可见的特定命名空间、名称的集合**
	-	名称的作用域范围包括
		-	定义该变量的代码块
		-	若定义在函数代码块中，作用域扩展至函数代码块所包含的代码块
			-	除非被包含代码块中引入对该名称不同绑定
			-	可在子代码块中直接访问变量，但修改变量必须使用 `global`、`local` 等声明
	-	作用域按逻辑上的包含关系可分为 4 类
		-	*Local*：局部代码块
		-	*Enclosing*：闭包
		-	*Global*：模块全局
		-	*Built-in*：解释器内置

-	名称解析：名称（的使用）由包含它的最近作用域来解析
	-	在代码块内任何位置进行名称绑定，则代码块内所有对该名称的使用被认为是 **对代码块的引用**
		-	python 没有声明语法，代码块中局部变量可通过在整个代码块文本中扫描名称绑定来确定
		-	名称在绑定前被使用则会导致错误
	-	解析失败
		-	若名称完全无法找到将 `raise NameError`
		-	若当前作用域为函数作用域，且名称指向局部变量，若名称被绑定值前被被使用将 `raise UnboundLocalError`
	-	名称解析是指定解析至变量而不是变量值
		-	对自由变量，外部可改变变量值，解析至变量即意味着函数执行结果取决于调用时刻（即可视为运行时解析）

> - `UnboundLocalError` 是 `NameError` 子类
> - （代码块的）环境：对代码块可见的所作用域集合

####	名称解析规则

-	`global` 名称解析：在 **最高层级命名空间** 查找、解析名称绑定
	-	最高层级命名空间指
		-	全局命名空间：包含代码块的模块命名空间
		-	内置命名空间：`builtins` 模块的命名空间
	-	`global` 语句须在名称使用之前声明
	-	`global` 声明语句与名称绑定确定的作用域相同，即 `global` 语句所在代码块

-	`nonlocal` 名称解析：在 **最近包含函数作用域** 查找、解析名称绑定
	-	指定名称不存在于任何包含函数作用域则`raise SyntaxError`

-	类名称解析：大部分情况下同普通规则，但
	-	未绑定的局部变将在全局命名空间中搜索
	-	类定义的命名空间 `__dict__` 会成为类的属性字典
	-	类代码块中定义的名称的作用域会被限制在类代码块中，不会扩展到方法代码块中
		-	包括推导式、生成器表达式（此二者也通过函数作用域实现）

		```python
		# 此代码将失败
		class A:
			a = 42
			b = list(a + i for i in range(10))
		```

-	自由变量的名称解析：运行结果依赖于调用时刻
	-	名称解析是解析至变量（而不是变量值），外部运行

	```python
	i = 0
	def f():
		print(i)
	i = 42
	f()
		# 打印`42`
	```

-	`eval()`、`exec()` 没有对完整环境的访问权限来解析名称
	-	可通过传参重载全局、局部命名空间

##	*Exception*

-	异常：中断代码块的正常控制流程以便处理错误、其他异常条件的方式
	-	在错误被检测到的位置引发
		-	解释器检测到运行时错误时错误
		-	`raise` 语句显式引发
	-	可被当前包围代码块、任何直接或间接主调代码块捕获、处理
		-	`try...except`指定错误处理，`finally`子句清理代码
		-	异常通过实例标识、根据器类型选择执行`except`子句
	-	异常实例可以携带关于异常状态的额外信息

-	错误处理采用“终止”模型
	-	异常处理器可以找出发生的问题，在外层继续执行
	-	但不能修复错误的根源，并重试失败操作
	-	异常完全未被处理时，解释器会终止程序执行、或返回交互模式循环，并打印栈回溯信息，除非为 `SystemExit` 异常

> - 异常信息不是 Python API 一部分，内容可能在不同 Python 版本间不经警告的改变

