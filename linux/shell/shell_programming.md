#	Shell编程基础

##	执行

###	`#!`

在脚本首行开头，其后路径被shell认为执行该脚本的命令解释器的
决定路径

-	不限于shell脚本，其他形式解释语言可以指定相应的解释器，
	shell将使用该解释器执行脚本

###	4种执行方式

-	`$ file_name`：表示在当前shell执行文件，需要有文件的执行
	权限

-	`$ source/. file_name`：`source`和`.`意义一致，表示读取
	文件内容在shell中，然后在shell里执行文件内容，需要读权限

-	`$ sh file_name`：表示开启一个新的shell进程，并读取文件
	内容在新的shell中然后执行，同样的需读权限

####	举例

以下面的文件test.sh为例

```shell
#!/bin/bash
echo "fisrt"
sleep 1000
echo "second"
slepp 1000
```

-	`$ test.sh`：产生两个新进程test.sh和sleep，在second输出
	之前`<ctrl-c>`，会同时终止两个进程，不会继续输出second

-	`$ sh test.sh`：产生两个新进程，shell和sleep，在second
	输出之前`<ctrl-c>`，同样的会同时终止两个进程，不会继续
	输出second（实际上first是在新的shell里输出的）

-	`source/. test.sh`：产生一个新进程sleep，在second输出之前
	`<ctrl-c>`，只有sleep进程被终止，而test.sh的内容在当前
	shell里直接执行，当前shell没有被终止，second会继续输出

####	结论

-	如果需要对当前shell进行设置，应该使用source/.

-	否则这三种执行方式除了进程产生、权限要求应该没有差别

##	符号

###	引号

-	`\'`：单引号扩起字符都作为普通字符，特殊字符失去原有意义

-	`\"`：`$, \\, \', \"`仍保留特殊功能，其余字符作为普通
	字符对待

-	<code>````</code>：反引号扩起字符串表示*Shell解释命令*，
	执行时shell首先解释其，以标准输出替代整个反引号

###	逻辑运算

####	数值

-	`!`：逻辑取反
-	`&&, -a`：逻辑与
-	`||, -o`：逻辑或
-	`-eq, -ne, -ge, -le, -lt, -gt`：比较
-	`==, !=, >=, <=, <, >`：数值比较

####	字符串

-	`=, !=, -z, -n`：字符串相等、不相等、为空、非空

####	文件

-	`-r, -w`：有文件读、写权限
-	`-f`：文件存在

###	数值运算符

####	位运算

-	`~`：位与
-	`|`：位或
-	`^`：位异或
-	`>>`：位右移
-	`<<`：位左移

####	计算

-	`**`：数值平方
-	`$[ expression ]`：计算中括号中的值、返回

####	赋值

-	`+=, *=, \=, -=, ==`：

###	命令

####	命令执行

-	`;`：连续执行指令，分割多条命令
-	`:`：内建空指令，返回值为0
-	`&&, ||`：逻辑与、或，全部（任意）之前的命令执行成功才会
	执行下连接中的命令

####	内置变量

-	`$0, $1,..., $9`：向脚本传递的位置参数
-	`$*`：脚本全部参数列表
-	`$#`：向脚本传递的参数数量
-	`$?`：上条命令执行结果
-	`$$`：脚本进程号
-	`$!`：执行脚本最后一条命令

####	内置命令

-	`echo`：输出变量内容
	-	`env`：输出系统主要环境变量
	-	`set`：输出系统全部环境变量

-	`read`：从标准输入读入变量内容

-	`let`：执行计算的工具，用于执行一个、多个表达式
	-	变量计算中不需要`$`标识变量
	-	表达式中包含特殊字符，需要引起来

-	`declare`：声明变量内容
	-	`-a`：声明变量为普通数组
	-	`-A`：声明变量为关联数组（下标支持字符串，类似字典）
	-	`-i`：声明变量为整形
	-	`-r`：声明变量只读
	-	`-x`：设置为环境变量（`export`）
	-	`-g`：在函数中创建全局变量
	-	`+`：和以上联合使用，取消定义的变量类型

	-	`-f`：列出脚本中定义的函数名称、函数体
	-	`-F`：列出脚本中定义的函数名称
	-	`-p`：查看变量属性、值

###	字符串

####	"转义"

-	`\\`：转义字符
	-	放在指令前，取消`alias`
	-	特殊符号前转义，Shell将不对其后字符作特殊处理，当作
		普通字符（即`$, \', \"`）
	-	行尾表示连接下一行，回车符只起换行作用，视为空格

-	`$`：变量符号，表示其后字符串为一个变量

-	`\', \"`：内部视为字符串

####	通配符

-	`*`：匹配任意长度字符串
	-	不包括`.`、`/`，必须显式匹配

-	`?`：匹配一个字符

-	`[]`：通配符，匹配出现在`[]`中的字符
		```shell
		ls /[eh][to][cm]*
			# 匹配`/etc`、`/home`等
		```

-	`{}`
	-	笛卡尔积（字符串连接）
	```shell
	$ mkdir {user1, user2}-{home, bin}
		# 等价于建立`user1-home, user1-bin, user2-home, user2-bin`
	```
	-	语句块分割

##	控制语句

###	`if`

用于条件控制结构，结构如下

```shell
if test_expression:
	then command_1
	else command_2
fi
```

###	`case`

```shell
case chars in
char_pattern_1)
	# `)`是必要的
	# 匹配即停止，不会下沉
	command_1
;;
	# 每个模式字符串可以有多条命令，最后一条必须以`;;`结尾
char_pattern_2 | char_pattern_3)
	# `|`分隔，或，可以匹配其中一个模式即可
	command_2
;;
*)
	# 匹配所有字符串模式，捕获所有
	command_3
;;
esac
	# 返回值位最后执行命令的退出值，未执行命令则为0
```

###	`while`

```shell
while test_expression
	# test_expression是指`test`、`[]`语句
	# 测试条件为真进入循环体
do
	command_1
done
```

###	`until`

```shell
until test_exprssion
	# 测试条件为假进入循环体
do
	command_1
done
```

###	`for`

```shell
for var in var_arr
do
	command_1
done

for var in file_regex:
	# `var`依次取（当前）目录下的与正则表达式匹配的文件名
	# 执行循环体语句
do
	bommand_2
done

for var[ in $*]
	# `var`依次取位置参数的值，执行循环体中命令
	# `[ in $*]`可以省略
do
	command_3
done

for ((i=0; i<limit; i++))
do
	command_1
done
```

###	条件测试

-	`test expession`：

-	`[ expression ]`：也可以作为条件判断符号，视为`test`命令
	的软连接，注意内部两边要有空格
	```shell
	if [ $? == 0 ]
		# 等价于
	if test $? == 0
		```

-	`[[ expression ]]`：

###	`break, continue, exit`

-	`break[n]`：跳出n层循环体，默认跳出一层循环体
-	`continue[n]`：跳过n层循环体在其之后的语句，回到循环开头
	，默认跳过一次循环体
-	`exit`：退出程序，后跟返回值

##	Shell环境

###	环境变量

-	设置环境变量直接：`$ ENV_NAME=value`（`=`前后不能有空格）
	但是此时环境变量只能在当前shell中使用，需要`export`命令
	导出之后才可在子shell中使用

-	环境变量设置代理
	```shell
	export http_proxy=socks://ip
	export https_proxy=socks5://ip
	```

###	输入输出

-	`0`：STDIN_FILENO，标准输入
-	`1`：STDOUT_FILENO，标准输出
-	`2`：STDERR_FILENO，标准错误

说明：

-	标准输出和标准错误虽然都是在命令行上显示，但是两个是
	不同的流。输出重定向`>`只能将标准输出重定向，不会将
	标准错误重定向，其仍然会在命令行显示

####	重定向

-	`<`：重定向标准输入
-	`>`：标准输出write重定向
-	`>>`：标准输出add重定向
-	`2>`：标准错误重定向

说明：

-	输出重定向就是`1 > output`，`command > output`只是省略
	`1`的简写
	-	命名自己不是输出，不能重定向
	-	是命令产生的标准输出重定向

-	可以通过`2>&1`将标准错误重定向到标准输出，从而将命令的
	标准输出、错误输出同时输出
	-	`&`这里表示**等效于标准输出（标准输出的引用）**
	-	`command>a 2>a`和`command>a 2>&1`看起来类似，实际上
		前者写法会打开两次`a`，stderr覆盖stdout，而后者是
		引用，不会覆盖、IO效率更高
	-	`2>&1`放在后面大概是因为需要获取stdout的引用，所以
		需要标准输出先给出重定向

-	可以重定向到设备，在\*nix系统中，设备也被视为文件
	```shell
	$ echo "hello" > /dev/tty01
	```

