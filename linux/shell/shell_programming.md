#	Shell编程基础

##	执行

###	`#!`

在脚本首行开头，其后路径被shell认为执行该脚本的命令解释器的
决定路径

-	不限于shell脚本，其他形式解释语言可以指定相应的解释器，
	shell将使用该解释器执行脚本

###	4种执行方式

-	`$ file_name`：表示在当前shell执行文件，需要有文件的执行
	权限

-	`$ source/. file_name`：`source`和`.`意义一致，表示读取
	文件内容在shell中，然后在shell里执行文件内容，需要读权限

-	`$ sh file_name`：表示开启一个新的shell进程，并读取文件
	内容在新的shell中然后执行，同样的需读权限

####	举例

以下面的文件test.sh为例

```shell
#!/bin/bash
echo "fisrt"
sleep 1000
echo "second"
slepp 1000
```

-	`$ test.sh`：产生两个新进程test.sh和sleep，在second输出
	之前`<ctrl-c>`，会同时终止两个进程，不会继续输出second

-	`$ sh test.sh`：产生两个新进程，shell和sleep，在second
	输出之前`<ctrl-c>`，同样的会同时终止两个进程，不会继续
	输出second（实际上first是在新的shell里输出的）

-	`source/. test.sh`：产生一个新进程sleep，在second输出之前
	`<ctrl-c>`，只有sleep进程被终止，而test.sh的内容在当前
	shell里直接执行，当前shell没有被终止，second会继续输出

####	结论

-	如果需要对当前shell进行设置，应该使用source/.

-	否则这三种执行方式除了进程产生、权限要求应该没有差别

##	变量

###	定义、使用、删除

-	定义变量

	-	定义时不加`$`符号
	-	变量名和等号之间不能有空格
	-	变量名只能由英文字母、数字、下划线，且不以数字开头，
		不能用bash中的关键字
	-	已经定义变量可以重新定义

-	使用变量

	-	`$var_name`/`${var_name}`：变量名前加`$`即可使用，
		未定义变量直接使用不报错，返回空值
	-	`{}`可选，但是`{}`能够明确定义变量名范围，帮助阅读、
		解释器执行

-	**匿名变量**

	-	可以认为所以语句（命令）的执行结果都存储在一个匿名
		变量中，可以在其之前加上`$`获取其结果

-	`readonly`：设置变量为只读变量，更改（重定义）变量报错

-	`unset`：删除变量，不能删除只读变量

###	变量作用域

####	局部变量

在脚本、命令中定义

-	仅在当前shell实例中有效
-	其他shell启动的程序不能访问局部变量

####	环境变量

在脚本、命令中定义

-	所有程序都能访问环境变量
-	环境变量时某些程序正常运行的必要条件

####	Shell变量

由shell程序设置的特殊变量，包括环境变量、局部变量，保证shell
的正常运行

-	`$0, $1,..., $9`：向脚本传递的位置参数
-	`$*`：脚本全部参数列表
-	`$#`：向脚本传递的参数数量
-	`$?`：上条命令执行结果
-	`$$`：脚本进程号
-	`$!`：执行脚本最后一条命令

###	内置命令

-	`echo`：输出变量内容
	-	`env`：输出系统主要环境变量
	-	`set`：输出系统全部环境变量

-	`read`：从标准输入读入变量内容

-	`let`：执行计算的工具，用于执行一个、多个表达式
	-	变量计算中不需要`$`标识变量
	-	表达式中包含特殊字符，需要引起来

-	`declare`：声明变量内容
	-	`-a`：声明变量为普通数组
	-	`-A`：声明变量为关联数组（下标支持字符串，类似字典）
	-	`-i`：声明变量为整形
	-	`-r`：声明变量只读
	-	`-x`：设置为环境变量（`export`）
	-	`-g`：在函数中创建全局变量
	-	`+`：和以上联合使用，取消定义的变量类型

	-	`-f`：列出脚本中定义的函数名称、函数体
	-	`-F`：列出脚本中定义的函数名称
	-	`-p`：查看变量属性、值

##	字符串

###	拼接

shell中字符默认为字符串，自动拼接

###	通配符

-	`*`：匹配任意长度字符串
	-	不包括`.`、`/`，必须显式匹配

-	`?`：匹配一个字符

-	`[]`：匹配出现在`[]`中的字符

	```shell
	ls /[eh][to][cm]*
		# 匹配`/etc`、`/home`等
	```

-	`{}`

	-	枚举全部

		```shell
		$ mkdir {user1, user2}-{home, bin}
			# 笛卡尔积（字符串连接）
			# 等价于建立`user1-home, user1-bin, user2-home, user2-bin`
		$ echo {1..10}
			# 生成序列
			# 见`for`中`RangeIterator`部分
		```

###	子串

```shell
$ file=/dir1/dir2/dir3/file.txt.bak
$ null=""
```

####	子串匹配

#####	规则

```shell
$ ${var_name%pattern}
$ ${var_name&%pattern}
$ ${var_name#pattern}
$ ${var_name##pattern}
```

-	`#`：去掉字符串左边最短pattern
-	`##`：去掉字符串左边最长pattern
-	`%`：去掉字符串右边最短pattern
-	`%%`：去掉字符串右边最长pattern

以上4种模式都不会改变变量的值，只有在pattern中使用通配符时，
最短、最长匹配一般才会有区别

#####	路径分段

|命令|解释|结果|
|------|------|------|
|`${file#*/}`|去除首个`/`及其左边|`dir2/dir3/file.txt.bak`|
|`${file##*/}`|仅保留最后`/`右边|`file.txt.bak`|
|`${file#*.}`|去除首个`.`及其左边|`txt.bak`|
|`${file##*.}`|仅保留最后`.`右边|`bak`|
|`${file%/*}`|去除最后`/`及其右边|`/dir1/dir2/dir3`|
|`${file%%*/}`|去除首个`/`及其右边|空值|
|`${file%*.}`|去除最后`.`及其右边|`/dir1/dir2/dir3/file.txt`|
|`${file%%*.}`|去除首个`.`及其右边|`/dir1/dir2/dir3/file.txt`|

####	切片

#####	规则

-	`:n[:m]`：从第`n`开始`m`个字符，不设置`m`时表示到末尾

#####	示例

|命令|解释|结果|
|------|------|------|
|`${file:0:5}`|提取首个字符开始的5个字符|`/dir1`|
|`${file:5:5}`|提取第五个字符开始的5个字符|`/dir2`|

####	替换

#####	规则

-	`/from/to`：替换首个`from`为`to`
-	`//from/to`：替换全部`from`为`to`

#####	示例

|命令|解释|结果|
|-----|-----|-----|
|`${file/dir/path}`|替换首个`dir`为`path`|`/path1/dir2/dir3/file.txt.bak`|
|`${file/dir/path}`|替换全部`dir`为`path`|`/path1/path2/path3/file.txt.bak`|

###	默认值替换

-	`-`：变量**未设置**返回
-	`+`：变量**设置**返回
-	`=`：变量**未设置**返回、设置变量
-	`?`：变量**未设置**输出至stderr
-	`:`：以上命令条件包括**空值**

|命令|解释|示例|结果|
|-----|-----|-----|-----|
|`${#var_name}`|获取字符串长度|`${#file}`|27|
|`${var_name-default}`|变量**未设置**返回默认值|`${invalid-file.txt.bak}`|`file.txt.bak`|
|`${var_name:-default}`|变量**未设置、空值**返回默认值|`${null-file.txt.bak}`|`file.txt.bak`|
|`${var_name+default}`|变量**设置**返回默认值|`${file-file.txt.bak}`|`fil.txt.bak`|
|`${var_name:+default}`|变量**非空**返回默认值|`${file-file.txt.bak}`|`file.txt.bak`|
|`${var_name=default}`|变量**未设置**，返回默认值、并设置变量为默认值|`${invalid=file.txt.bak}`|`file.txt.bak`|
|`${var_name:=default}`|变量**未设置、空值**返回默认值、并设置变量为默认值|`${null=file.txt.bak}`|`file.txt.bak`|
|`{$var_name?default}`|变量**未设置**输出默认值至stderr|`{invalid?file.txt.bak}`|`file.txt.bak`输出至stderr|
|`{$var_name:?default}`|变量**未设置、空值**输出默认值至stderr|`{$null:?file.txt.bak}`|`file.txt.bak`输出至stderr|

###	字符串比较

-	`=, !=, -z, -n`：字符串相等、不相等、为空、非空

注意

-	使用`=`比较变量是否为某字符串时

	```shell
	if [[ "$text"x = "text"x ]]; then
		command
	fi
	```

	其中在两边添加一个字符保证`=`不为空值，否则若`$test`为
	空值，表达式报错

##	数组

```md
$ A=(a b c def)
```

###	取值

-	`[]`：选择数组元素
	-	`[n]`：返回数组第n个元素
	-	`[*]`/`[@]`：返回数组全部元素

####	示例

|命令|解释|结果|
|------|------|------|
|`${A[@]}`|返回全部元素|`a b c def`|
|`${A[*]}`|同上|同上|
|`${A[0]}`|返回数组第一个元素|`a`|
|`${#A[@]}`|返回数组元素总数|4|
|`${#A[*]}`|同上|同上|
|`${#A[3]}`|返回数组第4个元素长度|3|
|`A[3]=xyz`|设置数组第4个元素值||

##	数值

-	`(())`/`[]`：在其中执行整数运算
-	`let`：执行数值运算

###	规则

-	返回的数据结果相当于存储在一个匿名变量中，使用的话需要
	在之前加上`$`

-	`$(())`/`$[]`中的变量名称可以省略`$`

	```shell
	$ a=5; b=7; c=2;
	$ echo $((a + b * $c))
		# 19
	```

-	`$((N#xx))`/`$[$#xx]`：将其他进制数据转换为10进制

	```shell
	$ echo $((2#110))
		# 6
	```

-	自增、自减运算可以在`(())`/`[]`中直接执行

	```shell
	$ a=5; ((a++)); echo $a;
		# 6
	```

###	特殊运算符

-	`~`：位与
-	`|`：位或
-	`^`：位异或
-	`>>`：位右移
-	`<<`：位左移
-	`**`：数值平方
-	`+=, ++, -=, --, *=, \=`：自变化运算符

###	逻辑运算

-	`-eq, -ne, -ge, -le, -lt, -gt`：比较
-	`==, !=, >=, <=, <, >`：数值比较

##	文件

-	`-e`：目标存在
-	`-f`：文件为一般文件（非目录、设备）
-	`-s`：文件大小非0
-	`-d`：目标为目录
-	`-b`：文件为块设备（软盘、光驱）
-	`-c`：文件为流设备（键盘、modem、声卡）
-	`-p`：文件为管道
-	`-h`/`L`：目标为符号链接
-	`-S`：目标为Socket
-	`-t`：文件描述符被关联到终端
	-	一般用于检测脚本的stdin是否来自终端`[ -t 0 ]`，或
		输出是否输出至终端`[ -t 1 ]`
-	`-r`：目标是否可读权限
-	`-w`：目标是否可写权限
-	`-x`：目标是否可执行权限
-	`-g`：目标是否设置有set-group-id
-	`-u`：目标是否设置有set-user-id
-	`-k`：目标是否设置sticky bit
-	`-O`：用户是否是文件所有者
-	`-G`：用户是否属于文件所有组
-	`-N`：文件从上次读取到现在为止是否被修改
-	`f1 -nt f2`：文件`f1`比`f2`新
-	`f1 -ot f2`：文件`f1`比`f2`旧
-	`f1 -ef f2`：文件`f1`、`f2`指向相似文件实体（相同的硬链接）

##	符号

###	命令执行

-	`;`：连续执行指令，分割多条命令
	-	所以如果不是在一行内执行，`;`是可以有任意多个

-	`:`：内建空指令，返回值为0

-	`&&, ||`：逻辑与、或，全部（任意）之前的命令执行成功才会
	执行下连接中的命令

###	"转义"

-	`\\`：转义字符

	-	放在指令前，取消`alias`
	-	特殊符号前转义，Shell将不对其后字符作特殊处理，当作
		普通字符（即`$, \', \"`）
	-	行尾表示连接下一行，回车符只起换行作用，视为空格

-	`$`：变量符号，表示其后字符串为一个变量

-	`\', \"`：内部视为字符串

###	引号

####	单引号`''`

-	单引号括起字符都作为普通字符，变量无效

-	单引号字串中不能出现单独的单引号，使用转义符也不行，但是
	可以成对出现，作为字符串拼接使用

####	双引号`""`

-	双引号字串中可以有变量、转义字符

####	反引号<code>\`\`</code>

反引号扩起字符串表示*Shell解释命令*，执行时shell首先解释其，
以标准输出替代整个反引号

-	括号中语句为命令，分号连接
	-	<code>\`\`</code>中的表达式只需要符合C语言的运算规则
		即可，甚至可以使用三目预算符、逻辑表达式

-	命令和括号之间无空格

-	<code>$\`\`</code>可以将命令输出作为变量返回值，同`$()`

###	括号

####	`()`

-	命令组/运算表达式，在括号中的命令列表将作为命令在子shell
	运行，类似<code>``</code>

	-	`()`中出现`()`不需要转义，<code>``</code>需要转义

	-	`()`应该是新开启一个子shell执行其中命令，可能会因为
		环境变量有所不同，也不会影响当前shell环境

	-	`()`中不能使用C风格的运算表达式

	-	有些shell可能不支持`()`，如tcsh

-	初始化数组（参见*数组*）

####	`(())`

-	计算、测试算法表达式结果，退出状态和`[]`完全相反
	（参见*整数计算*部分）
-	用于C风格的`for`、`while`循环语句中

####	`[]`

-	条件测试表达式：参见*`if`*
-	数组索引

####	`[[]]`

-	条件测试表达式：参见*`if`*
-	bash把双中括号中表达式看作是单独元素，返回一个退出状态码

####	`{}`

-	创建匿名函数
	-	不开启新进程
	-	括号内变量之后可继续使用
	-	括号内命令分号分隔，最后一个语句也要有分号
	-	`{`和第一个语句之间要有空格

-	字符串
	-	默认值替换：参见*字符串默认值替换*
	-	获取子串：参见*字符串子串*
	-	获取切片：参见*字符串子串*
	-	字符串替换：参见*字符串子串*

-	`$`后包括变量名精确分隔变量名，参见*变量使用*

##	控制语句

###	`if`

用于条件控制结构，结构如下

```shell
if test_expression; then
	then command_1
	else command_2
fi
```
####	条件测试

#####	`test`

`test expession`：判断表达式是否为真

-	`test`后面只能有一个表达式判断，不能使用逻辑与、或连接

#####	`[ ]`

`[ expression ]`：条件判断符号

-	注意内部两边要有空格

-	`[]`是shell内建`test`命令的一部分，而不是`/usr/bin/test`
	外部命令的符号链接

-	整数比较参见*整数逻辑运算*

-	字符串比较*字符串比较*

-	只能使用`-o`（或）、`-a`（与）、`!`（非）连接多个逻辑
	表达式，不能使用`||`（或）、`&&`（与）

	```shell
	if [ $? == 0 ]
		# 等价于
	if test $? == 0
	```

#####	`[[ expression ]]`：

-	注意内部两边要有空格

-	整数比较参见*整数逻辑运算*

-	字符串模式匹配比比较（和`[]`不同）

	-	右边作为模式时不能加引号（包括双引号），否则认为
		是普通字符串，同`[]`

-	只能使用`||`（或）、`&&`（与）、`!`（非）连接多个逻辑表达式
	不能使用`-o`（或）、`-a`（与）

###	`case`

```shell
case chars in
char_pattern_1)
	# `)`是必要的
	# 匹配即停止，不会下沉
	command_1
;;
	# 每个模式字符串可以有多条命令，最后一条必须以`;;`结尾
char_pattern_2 | char_pattern_3)
	# `|`分隔，或，可以匹配其中一个模式即可
	command_2
;;
*)
	# 匹配所有字符串模式，捕获所有
	command_3
;;
esac
	# 返回值位最后执行命令的退出值，未执行命令则为0
```

###	`while`

```shell
while test_expression
	# test_expression是指`test`、`[]`语句
	# 测试条件为真进入循环体
do
	command_1
done
```

###	`until`

```shell
until test_exprssion
	# 测试条件为假进入循环体
do
	command_1
done
```

###	`for`

####	CStyle

```shell
for ((i=0; i<limit; i++))
	# C-style for
do
	command_1
done
```

####	ListStyle

```shell
for var in var_arr
	# list-style for
do
	command
done
```

#####	FileIterator

```shell
for var in /path/to/file_regex
	# `var`依次取（当前）目录下的与正则表达式匹配的文件名
	# 执行循环体语句
do
	command
done
```

#####	ParamsIterator

```shell
for var[ in $*]
	# `var`依次取位置参数的值，执行循环体中命令
	# `[ in $*]`可以省略
do
	command
done
```

#####	RangeIterator

```shell
for i in $(seq start end)
do
	command
done

for i in {start..end}
do
	command
done
```

###	`break, continue, exit`

-	`break[n]`：跳出n层循环体，默认跳出一层循环体
-	`continue[n]`：跳过n层循环体在其之后的语句，回到循环开头
	，默认跳过一次循环体
-	`exit`：退出程序，后跟返回值

##	Shell环境

###	环境变量

-	设置环境变量直接：`$ ENV_NAME=value`（`=`前后不能有空格）
	但是此时环境变量只能在当前shell中使用，需要`export`命令
	导出之后才可在子shell中使用

-	环境变量设置代理
	```shell
	export http_proxy=socks://ip
	export https_proxy=socks5://ip
	```

###	输入输出

-	`0`：STDIN_FILENO，标准输入
-	`1`：STDOUT_FILENO，标准输出
-	`2`：STDERR_FILENO，标准错误

说明：

-	标准输出和标准错误虽然都是在命令行上显示，但是两个是
	不同的流。输出重定向`>`只能将标准输出重定向，不会将
	标准错误重定向，其仍然会在命令行显示

####	重定向

-	`<`：重定向标准输入
-	`>`：标准输出write重定向
-	`>>`：标准输出add重定向
-	`2>`：标准错误重定向

说明：

-	输出重定向就是`1 > output`，`command > output`只是省略
	`1`的简写
	-	命名自己不是输出，不能重定向
	-	是命令产生的标准输出重定向

-	可以通过`2>&1`将标准错误重定向到标准输出，从而将命令的
	标准输出、错误输出同时输出

	-	`&`这里表示**等效于标准输出（标准输出的引用）**
	-	`command>a 2>a`和`command>a 2>&1`看起来类似，实际上
		前者写法会打开两次`a`，stderr覆盖stdout，而后者是
		引用，不会覆盖、IO效率更高
	-	`2>&1`放在后面大概是因为需要获取stdout的引用，所以
		需要标准输出先给出重定向
	-	这种写法还有个**简写**`&>`、`>&`

-	可以重定向到设备，在\*nix系统中，设备也被视为文件
	```shell
	$ echo "hello" > /dev/tty01
	```
	特别的设备`/dev/null`可以作为不需要输出的重定向目标

