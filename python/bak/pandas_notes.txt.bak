python数据分析pandas笔记

1.	Series：可以看作是包含一个Index类（index，存放标签）、一个一维ndarray类（values，存放数据）

	a.	SeriesObj创建方式

		1.	SeriesObj= pd.Series(list)：不指定标签名，只有默认的RangeIndex

		2.	SeriesObj= pd.Series(list, index=index_list)：指定index中标签名

		3.	SeriesObj= pd.Series(dict)：用字典的方式指定标签名

	b.	SeriesObj可以像ndarray对象一样直接进行bool运算得到bool元素的Series对象

	c.	SeriesObj既可以通过SeriesObj[index_name]标签名、SeriesObj[index_no]序号（从0开始)方式取得、操作元素

	d.	SeriesObj之间的运算逻辑和ndarrayObj不一样，可以处理标签不一致的数据，但是只有标签的交集才能得到有意义的结果，其余的的结果为NaN

2.	DataFrame：可以看作包含两个Index类（index、columns）、一个二维ndarray类（values）

	a.	DFObj= pd.DataFrame(data=np.darray/dict/DFObj, columns=list, index=list)

		1.	values：必须是二维数据，即使是具有层级索引的DF对象

		2.	columns：指定DF对象列名称

			a.	使用dict对象时，默认将所有键值对生成DF对象

			b.	可以用columns指定部分dict中的键名，此时只使用该部分生成DF对象

		3.	index：指定DF对象index名称

			a.	可以是integer，且默认使用RangeIndex

				1.	注意python是强类型语言，index名称注意区别'1'、1，不能混用

				2.	使用integer作为index时注意df1.ix[]的逻辑

		4.	层级索引

			a.	columns/index=[level0_list, level1_list,...]（隐式指定）

			b.	columns/index=pd.MultiIndex.from_arrays([level0_list, level1_list,...])

				1.	down_list的长度必须相等，且层级由在list的次序决定

				2.	不会自动合并不连续的同一个index名称

			c.	columns/index=pd.MultiIndex.from_tuples([(level0_1, level1_1),....]

			d.	columns/index=pd.MultiIndex.from_product([level0_type_list, level1_type_list,...])

				1.	from_arrays是类似于from_tuples的列举出了所有“索引组合”

				2.	from_product则只给处各层级的索引名称，函数自动配对得到所有“索引组合”

		4.	关于DF对象的看法

			a.	结构和数据库表结构相似，也可以照此理解：列表示属性，行表示个体

			b.	DF对象应该是

				1.	二维value + 结构化index + 结构化columns

				2.	values自己还有两根只能使用integer索引的轴

	b.	DF对象的行列逻辑
	
		1.	获取数据

			a.	列优先

				1.	取列返回Series对象

					a.	df[column_name]

					b.	df.column_name

				2.	单独值

					a.	df1[column_name][index_name]（老版本可能df1[column_name, index_name])

					b.	df1.column_name.index_name

				3.	注意

					a.	属性方式要求*_name为字符串

					b.	“.”和“[]”都是“函数”，实际上是先得到一个Series对象

			b.	行优先

				1.	df1.loc[]：行优先,逻辑和df1[]列优先类似，不同点如下：

					a.	还可以：df1.loc[index_name, column_name]

					b.	不能：df1.loc.index_name

				2.	df1.iloc[]

					a.	应视为对value（ndarray）进行操作，index和columns的结构对其没有任何影响

					b.	df1.iloc[val_row_index]：返回value某行的Series对象

						1.	val_row_index：values部分序号，从0开始

						2.	没有层级索引的情况下，返回值和df1.loc[]对应

						3.	行层级索引时，此返回值仍然是Series对象

					c.	df1.iloc[val_row_index, val_col_index]：类似于df1.loc得到某个值

				3.	df1.ix[]是df1.loc[]、df1iloc[]封装

					a.	df1.ix[]根据参数类型自动选择函数

					b.	优先使用df1.loc[]，index为integer时注意逻辑

						1.	df1.iloc[0]始终是“索引组合”（values）第1行

						2.	df1.ix[0]可能是df1.loc[0]

				4.	快速版本：只能取一个值，不能用于获取切片

					a.	df1.at[index_name, column_name]

					b.	df1.iat[val_row_index, val_col_index]（类似于直接在ndarray中操作）

			c.	层级索引

				1.	获取数据：整体来说和一般的DF对象类似

					a.	列优先

						1.	索引有层级，df1[level0_column_name]返回的是DF对象

						2.	获取某列Series对象，需要指定多层索引

							a.	根据函数作用顺序，显然

								1.	df1[level0_column][leve1_column]

								2.	df1.level0_column.level_column

							b.	df1[level0_column, leve1_column]也可以

								a.	但是层级超过2层时，不能df1[level0, level1, level2]

								b.	根据低层级#todo

						3.	获取具体值类似：df1[l0_col][l1_col][l0_index][l1_index]

					b	行优先

						1.	df1.loc[]和df1[]类似

							a.	“属性”写法依然不允许，但“[]”仍然最多只能有两个键

							b.	需要注意的是df1.loc[name1, name2]中

								1.	name1为level0_index_name

								2.	name2不是level1_index_name，而是level0_col_name

								3.	所以返回值实际是DF对象，而不是层级索引的Series对象

								4.	可以视为df1.loc[name1][name2]的语法糖，或者本身也好理解

						2.	df1.iloc[]、df1.iat[]逻辑没有变化

						3.	df1.at[]好像用法有点问题，不管怎样都报错#todo

		2.	切片操作：应该分为value切片，index切片

			a.	index切片：切片对象是索引

				1.	列索引切片：df1[[column_name1,...]]

				2.	行索引切片：df1.ix[[index_name1,...]]（df1.loc[]也可以）

			b.	value切片：切片的对象是value行

				1.	df1[start:end]（应该是df.ix[]、df.iloc[]的语法糖）

				2.	非层级索引情况下，value切片和行index切片结果时一样的

				3.	行层级索引情况下，value切片操作单位是value行，而index行切片是level0索引

			c.	含有层级索引的切片#todo

				1.	顶级切片正常操作

				2.	低级：df1[:, level1_column_name]

		注：下面需要删改#todo
		3.	df1.T可以更改行、列逻辑，但df1数据（values）共享的逻辑比较特殊

			a.	增加列情况下数据共享情况

				1.	df1T = df1.T，此时df1T和df1共享数据，df1T可以看作是df1的视图

				2.	df1T['t_new_column']添加一个新列之后，df1T和df1仍然共享其公共部分的数据，但是df1T中新添加的列不会反映在df1行中（对df1添加新列同理）

				3.	继续df1['new_column']添加新列，此时df1和df1T所有数据均独立

			b.	使用del删除列得到的结果类似

			c.	df1返回的DataFrame对象应该是"默认尽可能"共享数据，直到无法处理（数据区同时增加、删除行、列）

			d.	注意：df1.reindex()返回的DataFrame对象不共享数据

3.	pandas数据处理 

	a.	数据合并、拼接、组合


	b.	轴向旋转：以下函数均不改变DF对象

		1.	df1.stack(level=0/1...)：将DF对象列索引”压缩“至行索引

			a.	参数（唯一参数）

				1.	level：对于列具有层级索引对象，指定压缩的列索引层级，默认为最大值（最底层）

			b.	注意

				1.	对于列索引只有一层，即压缩成为具有层级索引的Series对象

		2.	df1.unstack()：将DF对象（Series对象）行索引”解压“至列索引

			a.	参数（唯一参数）

				1.	level：对于行具有层级索引的对象，指定“解压”索引层级，默认为最大值（最底层）

			b.	注意

				1.	对于Series对象，即将具有层级索引的Series对象解压为DF对象

				2.	对于行索引只有一层，“解压”至列索引后得到是Series对象

				3.	df1.unstack().stack()可以用于层级索引的合并（因为其中好像有排序操作）

		3.	df1.pivot('column_name1', 'column_name2')

			a.	选取df1中的两列，将其作为新DF对象两个轴

			b.	参数

				1.	column_name：df1中的列名称，一般是两个，第1个为index，第2各为columns，但是尝试后发现可以传递更多，但是返回的DF对象看不懂

			c.	返回值：有列层级索引的DF对象

				1.	columns_name1为index名称

				2.	columns_name2为colomns第二层级的名称

				3.	df1中剩余列作为columns的第一个层级，即使只剩余一列

			d.	注意

				1.	不是所有的DF对象都可以这样转换，选取的两列各元素组合重复就会报错（主健不唯一）

	c.	增、删

		1.	del(df1['column_name']：返回删除df1的某列的DF对象，改变df1

			tips：del是python全局级的删除，表示从内存中回收

		2.	df1.drop(name/[name1,...], axis=0/1, level=0/1...)

			a.	参数

				1.	name：df1列名称（或者是index、index名称，取决于axis参数），也可以是其组成的list用于删除多个

				2.	asix：指定删除的方向，默认是0（列减少的方向）

				3.	level：对于含有层级索引对象，指定删除层级（从0开始增加），默认为0（删除顶层）

			b.	返回值：返回删除df1的某行，不改变df1

			c.	注意

				1.	含有层级索引的DF对象的删除#todo

		3.	df1[new_column_name]=list/df1.loc[new_index_name]=list：添加新列/行

			a.	层级索引添加新行、列#todo

			b.	注意

				1.	df1.ix[]是df1.loc[]的封装，也可以用于添加新列

				2.	df1.iloc[]则不可能，毕竟val_row_index不能手动修改

				2.	new_*_name可以是integer

					a.	区分数字字符串和数字

					b.	df1.ix[]优先考虑df1.loc[]（df1.loc和df2.iloc[]结果可能会冲突）

		4.	df1.reindex #todo

		5.	df.append()

	d.	筛选

		1.	df1.is_unique()

		2.	df1.duplicated()：返回元素为bool值的Series对象，重复出现（仅后出现者）列对应True

		3.	df1.drop_duplicated()：返回删除后的DF对象

		2.	df1.is_null()

		3.	df1.not_null()

		4.	df1.dropna(how='all')

			a.	参数
			
				1.	how：指定何种情况下删除NaN元素，默认删除NaN元素所在行列，'all'时仅删除值全为NaN的行、列
			b.	注意：对于Series对象，没有（不需要）how参数

		5.	ser1.dropna()

		6.	df1.fillna(value/value_dict)：按照给出的参数对NaN进行填充，给出dict对象时，按照dict键（DF列名称）值对填充

		7.	ser(bool)=df1(bool).any(Axis=0/1)：df对象中任何列、行存在False时为False

	e.	排序

		1.	df1.sort_index(ascending=True/False, axis=0/1, level=0/1, by=columns_name)

			a.	参数

				1.	ascending：默认为True，a-z升序

				2.	axis：排序方向，对于Series对象没有这个参数，默认为0，对行排序

				3.	level：排序层级，默认为0（顶级）

				4.	by：排序基准列（对于Series对象没有这个参数），默认为index

			b. 返回值：DF对象，不更改原DF对象

		2.	df1.sortlevel(ascending=True/False, axis=0/1, level=0/1)：感觉上类似df1.sort_index

		3.	df1.rank(ascending=True，axis=0/1, method='fisrt'/...)：排名（元素是排序结果）

		4.	df1.take(val_index_list, axis=0/1)：安照val_index_list给出的序号，对value进行排序、筛选（val_index_list不包含全部value行、列时）

		z.	ser1.order()：根据value进行排序 

	f.	映射（行、列、元素级操作）

		1.	df1.apply(func1, axis=0/1)

		2.	df1.replace({old_value1:new_value1,...})：新值替换就值

		3.	ser1.map({source1:target1,...})：依次将ser1中值作为source查找相应target，返回Series对象
			a.	可以用于给DF按照规则添加新列：df1[new_column_name]=df1[column_name].map(rule_dict)

		4.	df1.agg(func1, axis=0/1)

		5.	df1.transform(func1, axis=0/1)：不改变行、列数目的apply

	g.	统计

		1.	df1.sum(level=all/0/1, axis=0/1)

			a.	level默认值未知，默认时返回Series对象，不分level；否则返回DF对象，按level统计

		2.	df1.mean()

		3.	df1.describe()：显示DF对象的多个描述性统计量

		4.	df1.corr()：返回各列相关系数DF对象

		5.	df1.cov()：返回各列协方差DF对象

			tips：这两个函数不知道有没有axis参数，从统计、DF对象的角度来说没有也是正常的

		6.	ser1.corr(ser1)：计算ser1和ser2的相关系数

		7.	df1.corrwith(ser1/df2)

			a.	参数为Series对象时，返回df1各列与ser1的相关系数Series对象

			b.	参数为DF对象时，返回df1各列与df2各列两两直接相关系数

		8.	ser=df1.std()：列标准差

		9.	ser=pd.value_counts(list1/ser1/cat1)：统计各值出现次数

		10.	ser/df=df1.quantile(q=0.5/float/float_list, axis=0/1)：计算q分位数

	h.	index属性

		1.	df1.columns=[]：更改列名称，index同

		2.	df1.columns.names=[]：更改列名，index同

		3.	df1.swaplevel(level_name1, level_name2, axis=0/1)

			a.	level_name：可以level序号，也可以是用index.names指定的名称，默认是交换最低级两级

			b.	axis默认为0，行level交换

		4.	df1.rename(columns=rule_dict, index=rule_dict)：安装键值对规则重命名field名

		5.	df1.add_prefix(Preifx=prefix)

	i.	数据处理

		1.	cat=pd.cut(data_list, bin_list, labels=list, bins=bins)

			a.	用于将数据分组，返回Categorical对象

			b.	bin_list表示根据list给出区间分组，bins表示安装区间数目和data_list极值分组

		2.	cat=pd.qcut(data_list, q=bins)：将data_list安装参数q等分

		3.	group=df1.group(by=None, axis=0, level=None)

	a.	函数书写声明：return = func(value, param=value)

		1.	常用参数说明

			a.	aixs=0/1/'index'/'columns'：作用方向

				1.	默认为0/'index'：一般表示row-wise（行变动）方向

			b.	inplace=False/True：是否直接在原对象更改

				1.	默认为False：不更改，返回新DF对象（为True时无返回值）

				2.	大部分df1.func()类型函数都有这个参数

			c.	level=0/1/level_name...：作用索引层级

				1.	大部分默认为0：顶层级（也有默认为底层级）

				2.	level默认参数使用：t(top，顶层级0）/b（bottom，底层级)给出默认参数值

		2.	约定

			a.	参数

				1.	参数后面第一个值表示默认参数，之后表示可能取值

				2.	参数不是赋值形式，表示参数名称未知；参数名后有“?”表示参数名待确定

				3.	参数首字母大写表示唯一参数

			b.	返回值

				1.	返回值类型由返回对象名称蕴含

				2.	obj(type)中type表示返回值包含元素类型

			c.	DF对象和Series对象都具有的函数属性列出DF对象

3.	pandas库中的其他一些问题

	a.	数据类型转换：Series对象和DF对象在运算过程中dtype类型可能发生"无意义"的转换

		1.	dtype=i8的对象之间的+、-结果为dtype=f8类型的对象（当然这个可能是保持和\的一致性）

		2.	SeriesObj.reindex(new_index)会"可能"会改变原有数据类型（由i8->f8）（有增加新index时）

