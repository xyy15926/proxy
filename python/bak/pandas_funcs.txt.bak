pandas函数目录

1.	函数书写声明：return = func(value, param=value)

	a.	常用参数说明

		1.	aixs=0/1/'index'/'columns'：作用方向

			a.	默认为0/'index'：一般表示row-wise（行变动）方向

		2.	inplace=False/True：是否直接在原对象更改

			a.	默认为False：不更改，返回新DF对象（为True时无返回值）

			b.	大部分df1.func()类型函数都有这个参数

		3.	level=0/1/level_name...：作用索引层级

			a.	大部分默认为0：顶层级（也有默认为底层级）

			b.	level默认参数使用：t(top，顶层级0）/b（bottom，底层级)给出默认参数值

			c.	默认值为None表示所有层级

	a.	约定

		1.	参数

			a.	参数后面第一个值表示默认参数，之后表示可能取值

			b.	参数不是赋值形式，表示参数名称未知；参数名后有“?”表示参数名待确定

			c.	参数首字母大写表示唯一参数

		2.	返回值

			a.	返回值类型由返回对象名称蕴含

			b.	obj(type)中type表示返回值包含元素类型

		3.	DF对象和Series对象都具有的函数属性列出DF对象

2.	数据变换

	a.	二、多对象

		1.	df=pd.merge(df1, df2, on='column_name'/[column_names],
					left_on='left_column_name', right_on='right_column_name',
					left_index=False/True, right_index=False/true,
					how='Inner'/'outer'/'left'/'right')

			a.	功能：合并操作，类似于sql的join操作

				1.	df1、df2有多个列名相同且不全是合并基准列时，返回的DF对象的重复列名称会改变

				2.	df1.join(df2)

					a.	df1、df2不能有重名的列，否则需要提前重命名

					b.	结果类似于left join，从函数形式也可以看出来

			b.	参数

				1.	df1, df2：两个需要合并的DataFrame对象

				2.	on：指定合并基准列，可以是多个列名称的list，df1、df2仅有一列名称相同时可省略，否则返回空DF对象

				3.	left_on、right_on：df1、df2合并基准列名称不同时使用

				4.	left_index、right_index：默认为False，值为True时使用索引作为基准进行合并（此时也可以使用df1.join(df2))

				5.	how：指定合并方式，默认是inner join，参数取值：'outer', 'left', 'right'（不知道能不能取'inner'，这个应该是默认取值，可以使用）


		2.	df/ser=pd.concat([ser1,df1,...], axis=0/1, join='inner',
						keys=index_list)

			a.	拼接，以某个轴为方向将多个Series对象或DF对象拼接

				1.	pd.concat只涉及拼接方向，而merge只能沿列数增加的方向“拼接”

				2.	pd.concat(axis=1,...)和pd.merge(left_index=True, right_index=True, how='outer',...)的作用应该是一样的，只是不会将相同的列名称重命名

				3.	pd.merge可以指定合并基准列，而pd.concat只能按index”合并“，且只能inner join或时outer join
				4.	pd.concat()时即使有相同的列名称、index序号也不会重命名

			b.	参数：

				1.	[ser1, df1,...]：用于拼接操作的Series对象或者是DF对象

				2	axis：指定拼接方向，取值为0（默认，行数增加方向拼接）、1（列数增加方向）（这个和np.concatenate的axis的参数取值对应方向相同，但是DF对象是列优先，而ndarry是行优先）

				3.	join：指定拼接方式，默认是outer join，取值：'inner'

				4.	keys：在拼接轴上创建等级索引、指定拼接后列名称

					1.	指定keys参数的结果和其他参数有关，有可能是创建等级索引，也有可能是指定返回DF对象的列名称

					2.	总结来说：条目增加方向新增高一级”索引“

			c.	返回值

				1.	大部分情况下是DF对象

				2.	一般仅在拼接对象全为Series对象，且axis=0时返回Series对象

		3.	ser1.combine_first(ser2)/df1.combine_first(df2)

			a.	组合

				1.	以元素（而不是行、列）为单位进行组合，因此两个对象shape可以不一样

				2.	将df对象行、列分别取最长者作为返回对象的长度，然后优先将df1中的非NaN元素填入

				3.	这个函数好像不能df.combine_first(ser)或者反过来，但是报错不一样

				4.	是pd.merge(left_index=True, right_index=True, how='outer')、pd.concat(axis=1)的补充

					a.	重复列值的确定

					b.	以及确定重复值导致的元素级别的“组合”

			b.	参数

				1.	ser1/df1：优先使用values的Series对象、DF对象

				2.	ser2/df2：仅在ser1/df1没有该行（index）时作为备用的对象

	b.	单对象

		1.	df1.drop(name1/[name1,...], axis=0/1, level=t, inplace=false)：删除某行、列

		2.	df1[new_column_name]=list/df1.loc[new_index_name]=list：添加新列、行（iloc显然不可）
			注：层级索引待测试

		3.	df.append()

		z.	del df1[column_name]：python上直接删除某列，直接更改df1对象

3.	形、态变换

	a.	形状

		1.	df/ser=df1.stack(Level=b)：将DF对象列索引“压缩”至行索引底层

		2.	df/ser=df1.unstack(Level=b)：将DF对象行索引“解压”至列索引底层

			注：两个函数好像都有排序操作，df1.unstack().stack()会合并层级索引

		3.	df=df1.pivot(index?=column_name1, columns?=column_name2)：选取df1中两列作为列（底层）、行索引，但是如果选取的两列元素两两组合有重复回报错

	b.	排序

		1.	df=df1.sort_index(axis=0/1, level=t/[lev_name1,...], ascending=False/True,
							inplace=False/True, kind='quicksort'/'heapsort'/'mergesort',
							na_position='last'/'first', sort_remaining=True/False)

		2.	df=df1.sort_value(by=name/[name1,...], axis=0/1, ascending=Ture/False,
							inplace=False/True, kind='quicksort'/'heapsort'/'mergesort',
							na_position='last'/'first')

		3.	df=df.rank()

		4.	df=df1.take(indices=val_index_list, axis=0/1)：按照indices给出的列表排序、筛选

	c.	Index属性

		1.	df1.swaplevel(i=-1(t)/name, j=-2, axis=0/1)

		2.	df1.rename(mapper, columns, index=func/dict, axis=0/1, copy=True/False, inplace=False/True, level=None)

		3.	df1.add_prefix(Prefix=str)

4.	筛、改

	1.	重复

		a.	bool=ser.is_unique：有重复元素该属性为True

		b.	ser=ser.unique()：删除重复元素

		c.	ser(bool)=df.duplicated()：查找重复出现元素，仅重复后者为True

		d.	df=df1.drop_duplicated()：删除重复元素

	2.	空

		a.	df(bool)=df1.isnull()

		b.	df(bool)=df.notnull()

		c.	df=df1.dropna(axis=0/1, how='any'/'all')：以某种方式删除空值行、列：全为空、

		d.	df=df.fillna(value/value_dict)：按照参数值、键（列）值对填补

	3.	其他

		a.	ser=df1(bool).any(Axis=0/1)：任何含有NaN值的列、行为False

5.	数据处理

	a.	简单统计

		1.	ser=df1.sum(level=None/0/1, axis=0/1)

		2.	ser=df1.mean(axis=0/1)

		3.	ser=df1.std(axis=0/1)

		4.	df=df1.describe()

		5.	df=df1.corr()

		6.	df=df1.cov()

		7.	float=ser1.corr(ser1)

		8.	ser=df1.corwith(other=df2/ser1, axis=0/1, drop=False/True)
			a.	other为DF对象时计算相同名称相关系数
			b.	这里axis=0返回的是列相关系数（column-wise，同df.any()）

		9.	ser=pd.value_count(values=ndarray(1d), sort=True/False, ascending=False/True,
							normalize=False/True, bins=int, dropna=True/False)

		10.	ser/df=df1.quantile(q=0.5/float/list(float), axis=0/1)：计算分位数

		11.	

	b.	元素级

		1.	df=df1.apply()

		2.	df=df1.agg()

		3.	df=df1=df1.replace(to_replace=None, value=None, inplace=False, limit=None/int, regex=False, method='pad'/'ffill'/'bfill')

		4.	df=df1.transform(func=func/dict/str/list[...])

		5.	ser=ser1.map(arg=dict/func, na_action=None/'ingnore')：map values of ser1

		6.	

	c.	分组

		1.	cat=pd.cut(x=array_like, bins=int/list, right=True, label=None/False/list, retbins=False/True, include_lowest=False/True)

		2.	cat=pd.qcut(x=array_list, q=int/quantile_list)

		3.	group=df1.group(by=None/col_name, axis=0, level=None)
