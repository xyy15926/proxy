python类说明

1.	元类说明

	a.	**type**就是元类，python中所有类都是type创建
		class = type(name=cls_name, bases=(par_name,..), dict={attr1: val1,...})

		1.	参数

			a.	cls_name：类名称

			b.	bases：父类为元素的元组

			c.	dict：类方法、属性

		2.	返回值：类的别名？

	b.	元类作用
	
		1.	拦截类创建->修改类->返回修改后的类（创建**类对象**）
			（如果不确定是否需要用元类，就不应该使用）

		2.	元类的作用和函数相似，且事实上，python并不关心**类对象**
			是否是由真正的**元类**创建，可以指定元类为一个函数，而
			不一定是继承自type的元类

		3.	但是仍然应该尽量将元类指定为继承自type的对象

			a.	元类应用场景一般比较复杂，使用类可以更好的管理代码

			b.	默认元类type是类，类继承保持一致性意图比较明显，且可以
				使用type中的方法

			c.	元类可以使用一些类中特有的方法：__new__，__init__等

	c.	自定义元类
		class UpperAttrMeta(type):
			def __new__(cls, cls_name, bases, attrs):
				upper_attrs=dict((name.upper(), val) for name,val in attrs.items() if not name.startswith('__'));
				return super(UpperAttrMeta,cls).__new__(cls, cls_name, bases, upper_attrs); 
		// 使用元类创建新类
		class Foo(metaclass=UpperAttrMeta):
			b=1;

		1.	使用自定义元类UppAttrMeta创建的类Foo中定义的__init__、
			__new__等函数无意义，因为该类不仅是通过元类创建，也是通过
			元类初始化

			a.	原因在于，类Foo通过UpperAttrMeta创建，而UppAttrMeta
				本身没有实现自定义__init__，默认继承于object

				“因此Foo类的创建就有object的init完成“
				segmentfault.com/q/1010000004438156
				这个是原话，不明白什么意思了

			b.	但是如果元类仅仅是pass，如下：
				class MetaCls(type):
					pass;
				使用此自定义元类，类定义中的__init__、__new__有效
		

2.	类创建

3.	类的特殊方法、属性





5.	自定义元类（py2，not compatiable with py3）

	a.	python创建**类对象**步骤

	a.	__metaclass__指定创建类使用的元类

		1.	python按照优先级
			类定义内 > 祖先类内 > 模块内 > type
			查找__metaclass__，并使用其**创建****类对象**，若前三者均
			未定义__metaclass__，则使用type创建

		2.	自定义元类就是为__metaclass__指定自定义值

		3.	事实上，python只是将创建类的参数传递给__metaclass__，并不
			关心__metaclass__是否是一个**类**

			a.	cls()返回一个类对象，是相当于调用cls.__new__()

			b.	所以可以指定__metaclass__为一个函数

	b.	例子
	
		1.	函数版本
		
			def upper_attr(cls_name, bases, attrs):
				upper_attrs=dict((name.upper(), val) for name,val in attrs.items());
				return type(cls_name, bases, upper_attrs);

			class Foo():
				bar=1;
				__metaclass__=upper_attr;

		2.	类版本1

			class UpperAttrMeta(type):
				def __new__(clsf, cls_name, bases, attrs):
					upper_attrs=dict((name.upper(), val) for name,val in attrs.items());
					return type(cls_name, bases, upper_attrs); 

			class Foo():
				bar=1;
				__metaclass__=UpperAttrMeta;

		3.	类版本2

			class UpperAttrMeta(type):
				def __new__(cls, cls_name, bases, attrs):
					upper_attrs=dict((name.upper(), val) for name,val in attrs.items());
					return type.__new__(cls, cls_name, bases, upper_attrs); 

		4.	类版本3

			class UpperAttrMeta(type):
				def __new__(cls, cls_name, bases, attrs):
					upper_attrs=dict((name.upper(), val) for name,val in attrs.items());
					return super(UpperAttrMeta,cls).__new__(cls, cls_name, bases, upper_attrs); 
