python数据分析numpy笔记

numpy的核心ndarray对象是同质元素（dtype）组成、大小固定的多维数组（这个多维数组的概念类似于C中的概念，是规则的立方体）

1.	部分复杂函数

	a.	np.column_stack

	b.	np.row_stack

	c.	np.apply_to_axis

	d.	np.concatenate([npdarray,...], axis=0/1..., )

2.	副本、视图、bool数组

	a.	numpy对象通过"="直接赋值一般都是视图
	
		1.	多个视图共享同一个数据区，对任一个视图的数据更改会影响到其他对象
		
		2.	但是多个视图有一些独立的属性（如维数），类似于C中包含data_pointer的复制
		
		3.	ndarray对象的切片也是视图（python list类型的切片不是）

	b.	可以通过ndarrayObj.copy()获得副本

	c.	ndarrayObj可以直接进行bool运算得到bool元素的ndarray对象

		1.	如new_ndarrayObj = ndarrayObj < 0

		2.	这个可以看作是向量化（ndarrayObj省略循环）或者是广播（比较对象隐式转换为ndarray对象然后广播）

		3.	bool数组可以用于筛选数组元素：ndarrayObj[ndarrayObj<0]

3.	向量化：代码中可以省略部分显式循环，由numpy内部实现（将ndarray对象视为向量，可以"直接"进行向量运算）

4.	广播：实现对形状不完全相同的ndarrayObj的运算

	a.	条件：数组各维度兼容，即数组对应维度：
	
		1.	各维等长
		
		2.	长度为1：用已有值填充至该维度长度一致
		
		3.	长度为0（即该维度缺失）：这个其实应该看作是长度为1的特例

			a.	维度缺失只能是"高维度"缺失，"低维度"是无法缺失的
			
				1.	因为numpy（python）里的数组的维度排序是确定的，若需要跳过第二维（维度缺失），需要将第二维长度设为1，否则所有维度level都会下降
				
				2.	所以应该将缺失维度视为维度长度为1，只是因为缺失是"高维度"缺失，可以省略

			b.	当然这样的考虑下数组维度无限，只需要考虑到最高level的维度

	b.	具体来说就是将多个兼容的ndarray"面"综合考虑后，用已有值扩展为合适ndarray"体"后运算

		1.	需要注意的是，数组维度level是左高->右低
		
			a.	所以实际上维度应该是右对齐，在左边补齐缺失维度（长度为1）
			
			b.	这个在不需要考虑广播为ndarray"体"的情况下不会弄错

			c.	但是在广播为ndarray"体"的情况下，因为正常的思维是左对齐，即直接将已有的维度作为高维度，这样比较容易构建"体"

		2.	手动计算步骤：

			a.	数组维度右对齐，检查兼容性，用1补齐缺失高维度

			b.	缺失m维度在最外层加上m层[]补齐

			c.	确定最终ndarray"体"各维度长度，从底（右）到高（左）依次递归复制（即包含低于其维度level，[]内的所有数据）该维度数据，直到达到最终维度长度

		3.	例：shape(3, 2, 2, 1) + shape(1, 3)
				-> shape(3, 2, 2, 1) + shape(1, 1, 1, 3)
				-> shape(3, 2, 2, 3) + shape(1, 1, 2, 3)
				-> shape(3, 2, 2, 3) + shape(1, 2, 2, 3)
				-> shape(3, 2, 2, 3) + shape(3, 2, 2, 3)

5.	结构化数组：ndarray元素为特定结构tuple，类似于二维数据表

	a.	结构化数组可以看作是有一维的index为string的二维数组，可以通过ndarray[fieldname]得到该field的一个ndarray

	b.	在使用np.array([tuple1, tuple2...], dtype = (''))构造结构化数组中dtype有两种指定方式

		1.	字符串方式：dtype = "type1, type2..."，此时各个field名称为'f0','f1'...

		2.	list方式：dtype = [(fieldname1, type1), (fieldname2, type2)...]

	c.	dtype必须显式给出各个field的数据类型，否则

		1.	不给dtype，各个tuple长度相同：构造的是普通的二维ndarray，此时dtype由python根据以下优先级推断：string(U)> complex(c16)> float(f8)> int(i8)

			a.	这里pyhthon推断的数据类型都是按最小风险推断

			b.	string被推断为< U_MAXLEN（unicode）而不是< S_MAXLEN（bytes）

			c.	complex、float、int类型被推断为最精确类型

		2.	不给dtype，各个tuple长度不同：构造的是以tuple为元素的一维ndarray，此时dtype=object

		3.	给出一个dtype，此时就是表示普通的ndarray初始化，需要满足tuple长度相同、dtype可以推断至所有数据

