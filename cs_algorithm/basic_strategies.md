---
title: 算法设计策略
categories:
  - Algorithm
tags:
  - Algorithm
date: 2019-05-30 00:38:54
updated: 2022-10-10 16:52:19
toc: true
mathjax: true
comments: true
description: 算法设计策略
---

##	综述

-	从算法设计思路角度可将算法分类
	-	朴素（蛮力）：模拟、遵循问题思路设计的算法
		-	遍历
		-	枚举
		-	模拟
	-	递归：分析问题特点，抽取、复用问题处理思路解决相似的小问题
		-	问题规模的变化情况
			-	分治：问题规模指数下降
			-	减治：问题规模线性下降
		-	回溯：在递归基础上评估每步递归结果，不满足约束条件下回退
			-	约束剪枝：在回溯生成状态空间树上，利用约束条件跳过无效分支
			-	分支界限剪枝
	-	动态规划：在递归基础上，记录、复用子问题结果
		-	要求可复用子问题结果，即要求问题具有最优子结构特性
		-	子问题结果复用情况在算法执行过程中 “动态” 确定
	-	特定场景思路：基于问题本身特性设计特定算法
		-	贪婪：每步最优即全局最优
		-	变治法：在权衡时间、空间效率的情况下变换问题
		-	预处理：根据问题特征预处理数据，提高效率
			-	倍增
			-	分块

> - 递归本身是从上至下，但从下至上避免递归不影响递归思路

##	朴素（蛮力）思路

-	朴素思路：简单直接解决问题的方法，常常直接基于问题的描述和所涉及的概念定义
	-	特点
		-	可以解决各种问题，可能是唯一几乎可以解决所有问题的方法
		-	对某些问题，有产生合理、具备实用价值算法，且不必限制实例规模
			-	若问题实例不多，蛮力法速度可接受，设计高效算法可能不值得
		-	可以作为基线算法，用于研究、教学
	-	案例
		-	排序
			-	选择排序
			-	冒泡排序
		-	查找
			-	顺序查找
			-	蛮力字符串匹配
		-	几何
			-	最近对问题
			-	凸包问题
		-	组合
			-	背包问题
			-	旅行商问题
			-	分配问题
		-	图处理
			-	深度优先搜索
			-	广度优先搜索

##	*Recursion*

> - *Reduction* 简化论：仅仅通过理解构成对象某一部分就可以理解整个对象
> - *Holism* 整体论：总体总比构成它的部分更为重要

-	递归：将大问题通过简化成相同形式的小问题来解决问题
	-	递归思路：从整体角度、采用稳步跳跃理念，正确地将原始问题分解为有效的子问题
		-	更加简单，且和原问题求解形式相同
		-	最终能达到简单情况，并正确解决
		-	能重新组合子问题的解得到原始问题的解
	-	*Recursive Leap of Faith*（递归的）稳步跳跃理念：任何更简单的递归调用将正确工作
		-	相信子问题能被正确解决、递归逻辑能稳步组合
		-	无需深入探究递归栈

-	*Recursive Paradigm* 递归范型：递归可以表示称如下函数体形式

	```cpp
	if(test for simple case){
		// 非递归解决简单问题
	} else {
		// 1. 将问题简化为某种形式的子问题（一个或多个）
		// 2. 递归调用函数解决每个子问题
		// 3. 将子问题的解组合得到原问题的解
	}
	```

###	递归思路

-	递归实现上的本质即压栈（调用）、出栈（回退）
	-	函数递归调用即由编译器处理函数栈嵌套，则可自行维护栈实现递归避免递归函数栈开销
		-	栈元素即递归标记，对应递归函数参数
		-	栈元素处理循环体即对应递归函数体
	-	也可自行维护递归标记栈，但设计较递归函数参数设计更为复杂
		-	递归标记需要仔细设计以避免空间开销过大
			-	通过端点、共用数据代替数据副本
		-	循环体相较于递归函数体需要更多判断逻辑，此即降低函数栈开销的核心
			-	虽然，循环体中递归标记压栈顺序与函数栈压栈顺序一致
			-	但，递归函数仅需涉及处理逻辑，由函数栈压栈、出栈维护执行顺序
			-	而，循环体需包含压栈、出栈逻辑，需要添加判断逻辑决定压栈、出栈（即处理逻辑），否则可能死循环
		-	循环体处理结果保存也需仔细考量
			-	递归函数无返回值、在位修改全局变量：在循环体中类似设计即可
			-	递归函数带返回值：则循环体中需设计结果保存机制
		-	循环体终止条件一般为栈空，也存在需要添加其他判断逻辑情况

-	尾递归：递归压栈为最后执行指令
	-	即（仅），其他指令执行无需依赖递归压栈结果
	-	因，递归退栈后无需执行其他指令，则无需维护递归栈、压栈、退栈
	-	类似的，非递归版本中也无需维护栈

###	问题规模

-	*Decrease and Conquer* 减治：利用问题给定实的解和同样问题较小实例解之间某种关系求解问题
	-	可以自底向上、自底向上的运用该关系
		-	自顶向下会自然导致递归算法，但是还是非递归实现较好
		-	自底向上往往是迭代实现的，从求解问题较小实例开始
	-	减治法有 3 种主要变化形式
		-	*Decrease-by-Constant* 减常量：每次算法迭代总是从实例中减去相同常量
			-	*新问题规模 = 原问题规模 - constant*
			-	一般来说这个常量为1
		-	*Decrease-by-A-Constant-Factor* 减去常量因子：在算法迭代过程中总是减去相同的常数因子
			-	*新问题规模 = 原问题规模 / constant-factor*
			-	常数因子一般为2
		-	*Variable-Size-Decrease* 减可变规模：算法每次迭代时，规模减小模式不同

-	*Divide-and-Conquer* 分治法：将问题划分为同一类型的若干子问题，子问题规模最好相同
	-	对子问题求解
		-	一般使用递归方法
		-	规模足够小时，有时也会利用其他算法
	-	有必要则合并子问题的解得到原始问题答案

-	减治法例
	-	减常量法
		-	数值计算
			-	自顶向下递归计算指数
			-	利用指数定义自底向上计算指数
		-	排序
			-	插入排序
			-	希尔排序
		-	图问题
			-	拓扑排序
		-	组合
			-	生成排列
			-	生成子集
	-	减常因子法
		-	数值计算
			-	递归的计算$a^{n/2}$计算指数
			-	俄式乘法
			-	约瑟夫斯问题
		-	查找
			-	数值问题
	-	减可变规模
		-	数值计算
			-	计算最大公约数的欧几里得算法
				$$gcd(m, n) = gcd(n, m mod n)$$
		-	排序
			-	顺序统计量
		-	查找
			-	差值查找
			-	二叉查找树
		-	组合
			-	拈游戏

-	分治法案例
	-	查找
		-	求解二叉树高度
		-	遍历二叉树
	-	数值计算
		-	大整数乘法
		-	Strassen矩阵乘法
	-	几何
		-	最近对问题
		-	凸包问题

##	回溯、剪枝

```cpp
Backtrack(X[1..i])
	// 回溯算法通用模板
	// 输入：X[1..i]一个解的前i个有希望的分量
	// 输出；代表问题解的所有元组
	if X[1..i] 是一个解
		write X[1..i]
	else
		for feasible(x) \in S_{i+1} do
			// 不符合约束的不处理，即回溯
			// 符合约束则继续深度优先搜索
			X[i+1] = x
			Backtrack(X[1..i+1])
```

-	*Backtracing*：每次只构造解一个满足约束分量，评估此部分构造解决定接受、或回溯
	-	回溯法目标是最终输出：$n$ 元组 $(x_1, x_2, \cdots, x_n)$
		-	其中元素 $x_i$ 为有限线性集 $S_i$ 的一个元素
		-	元组可能需要满足额外约束
		-	适合处理含有约束条件、困难的组合问题，只需要求出可行解
			-	问题往往有精确解，但是没有高效算法求解
	-	回溯法核心就是对状态空间树进行剪枝，忽略无法产生解的分支
		-	尝试在当前部分解基础上构造下个分量
		-	若，存在不违反问题约束的下个分量，则接受首个合法选择
		-	若，无法得到下个分量合法选择，则回溯，将当前部分构造解最后分量替换为下个选择

-	回溯法时间效率不稳定，性能无法保证，但至少可以期望在期望时间求解问题
	-	对状态空间树剪枝是对穷举法的改进，避免考虑某些无效解
	-	在最坏情况下须生成状态空间中所有解，且其规模无法分析、求解
		-	只能通过抽样大致估计路径平均长度，从而确定状态空间规模
		-	对特定问题，可通过某些技巧缩小状态空间规模
			-	组合问题对称性
			-	把值预先分配给解的分量
			-	数据预处理：预排序

###	状态空间树

-	回溯法会显式、隐式的生成一棵状态空间树
	-	状态空间树中
		-	树根表示查找解之前的初始状态
		-	树的第 $i$ 层节点表示对第 $i$ 个分量的选择
			-	从根到节点路径的即对应的解分量整体
		-	叶子节点（无需最优解）
			-	完整树中：无希望解分量、或完整解（路径）
			-	构造中树中：无希望分量、或未处理解分量
	-	大部分情况下，回溯算法的状态空间树按照深度优先方式构造
		-	当前节点（解分量）有希望：添加下个分量的下个选择得到新的节点，处理新节点
			-	当前节点仍有未处理的子女节点
			-	当前节点符合约束（具体判断位置取决于程序设计）
				-	新添加分量约束
				-	添加后解分量整体约束
		-	当前节点无希望：回溯到节点父母重新处理

###	分支界限剪枝

-	分支界限法：在回溯基础上，比较叶子节点最优边界值、当前最优解以进一步剪枝
	-	即，在回溯法基础上增加约束条件：叶子节点最优边界值须优于当前最优值
		-	最优边界值：节点对应部分解向量衍生的解集合在边界目标函数值上的最优取值
		-	边界目标函数：需适当选择，在容易计算基础上、边界尽可能紧密，以尽量削剪状态
	-	分支界限适用于求解最优解的场合
		-	将当前最优解作为约束条件剪枝
		-	随着深度增加，节点最优边界逐渐紧密，节点更容易被终止
	-	分支界限状态空间树和节点生成顺序有关
		-	节点生成改变约束条件（当前最优解），不同生成顺序剪枝结果不同
		-	*Best-First Branch-and-Bound* 最佳优先分支边界策略：在当前树未终止叶子中，优先处理最优边界节点
			-	可能会较早得到较好的结果，利于剪枝消除更多分支

##	动态规划

-	*Dynamic Programming* 动态规划：在递归基础上，记录、复用子问题结果
	-	动态规划可用 *DAG* 描述
		-	节点：问题（状态，子问题特征）
		-	边：决策，状态转移方式
		-	目标：寻找初始状态节点、目标状态节点间最优路径
	-	动态规划要求问题满足：最优子结构、无后效性、子问题重叠
		-	最优子结构：最优状态转移路径中任意两个状态间路径均为最优路径
		-	无后效性：后续决策不影响已解决子问题
		-	子问题重叠：方便记录、复用子问题结构
	-	动态规划常用于求解最优化问题
		-	离散最优化问题：如递推关系中包含极值、累计值等
		-	交叠子问题构成复杂问题，需遍历比较
		-	组合问题
			-	币值最大化问题
			-	找零问题
			-	硬币问题
			-	背包问题
			-	最优二叉查找树
			-	最长公共子序列
		-	字符串查找问题
			-	最长上升子序列
			-	最长公共字串
			-	编辑距离

> - 最优化法则：最优化问题的任一实例的最优解，都是由其子问题实例的最优解构成（大多数情况成立）
> - *OI Wiki* 动态规划基础：<https://oi-wiki.org/dp/basic/>

###	动态规划求解思路

-	动态规划求解问题思路
	-	将原问题划分为若干阶段，每阶段对应若干子问题
		-	首先需确定涉及变量，构造求解空间
			-	递推式中变量：离散变量、有约束条件变量
			-	求解空间：各变量笛卡尔积（可通过约束条件缩减）
		-	有序组合思想：有序剔除、遍历变量可能取值，确定递推关系
			-	只需要求解全集最优解，所以只需要考虑部分有序子集
				-	即，类似类比矩阵可逆只需要判断顺序主子式
			-	单向剔除、遍历：注意考虑变量约束条件，减少搜索空间
			-	双向剔除、遍历变量：可视为两个有约束条件的独立变量（最优二叉树）
		-	有些问题需转换为等价问题，再考虑为等价问题的建立递推关系
			-	原问题求解非数值解，考虑等价的寻找数值解的问题
			-	原问题求宽松范围解，即解不要求包含断点的解，考虑以各个元素分别作为端点解构建递推关系，以最优者即为宽松范围解（最长子序列）
	-	寻找状态转移方程（问题特征即状态）
		-	依赖于子问题划分，应与子问题划分同时考虑
	-	按顺序求解各阶段问题
		-	自底向上：按顺序求解给定问题所有较小子问题，最终得到的原始问题解
			-	无对问题整体的全局把握
			-	必须求解全部子问题、填满动态规划表
			-	无需递归求解
		-	自顶向下：从原始问题开始，只计算对求解原问题所依赖的子问题
			-	只能在求解过程中才可确认所依赖的子问题
			-	仅求解部分子问题、填充动态规划表部分项
			-	需递归求解
#TODO

###	动态规划表

-	动态规划子问题求解：利用动态规划表记录、复用子问题解
	-	动态规划表：记录已求解交叠子问题解
		-	$(N_1,N_2,\cdots,N_M)$ 形状的结构化数据表
			-	其中：$M$ 离散变量数量、$N_m$ 为变量可能取值
			-	某些问题中，数据表可根据情况缩减
		-	子问题标记、结果的映射
			-	结构简单，无需考虑完整求解空间
			-	尤其适合涉及子问题少、从上至下情形
	-	查表求解子问题：复用子问题解
		-	若动态规划表中记录有结果，直接复用子问题解
		-	否则求解问题，并记录于动态规划表
	-	路径记录：部分问题要求给出最优方案路径
		-	额外记录涉及的各问题依赖的子问题，回溯即可确定

##	特定算法

###	变治法

-	变治法：在权衡时间、空间效率的情况下变换问题
	-	分成两个阶段工作
		-	“变”：出于某种原因，把问题实例变得容易求解
		-	“治”：对实例问题进行求解
	-	根据对问题的变换方式，可以分为3类
		-	*Instance Simplification* 实例化简：变换为同样问题的更简单、更方便的实例
			-	预排序
			-	输入增强
		-	*Representation Change* 改变表现：变换为同样实例不同表现
		-	*problem reduction* 问题化简：变换为算法已知的另一个问题的实例

-	典例
	-	排序
		-	预排序（线性表）
			-	比较计数排序
			-	分布计数排序
	-	查找
		-	预排序
			-	检验线性表唯一性
			-	寻找线性表众数
			-	查找线性表中元素
		-	字符串模式增强
			-	*Horspool*算法
			-	*Boyer-Moore*算法
			-	*KMP*算法
			-	最长公共子串
	-	数值
		-	高斯消元法
			-	前向消去法
			-	部分选主元法
			-	反向替换法
		-	数值计算
			-	霍纳法则
			-	二进制（计算）幂
			-	欧几里得算法
		-	极大、极小值转换
		-	极值转换为求导数为0点
		-	线性规划：在极点求解
		-	整数规划
	-	图
		-	把问题转换为状态图求解
	-	*Hash* 散列


###	贪婪

-	*Greedy* 贪婪：通过一系列局部最优选择产生全局最优解
	-	贪婪法每步条件
		-	*Feasible*：必须可行，满足问题约束
		-	*Locally Optimal*：是当前所有步骤中所有可行选择的最佳局部选择
		-	*Irrevocable*：选择一旦做出不能更改，即仅能基于目前构造的部分解做扩展
	-	只能应用最优问题，但可以作为一种通用设计技术
		-	仅部分问题能够通过贪婪算法获得最优解
		-	对无法通过贪婪算法获得最优解的问题，也可用于求近似解
	-	贪婪算法能得到最优解的正确性证明
		-	数学归纳法
		-	反证法
			-	按步骤证明：在接近目标过程中，贪婪算法每步至少不比其他任何算法差
			-	按输出证明：证明贪婪算法的输出能够获得最优解
	-	贪婪算法案例
		-	图
			-	*Prim* 算法
			-	*Kruskal* 算法
			-	*Dijkstra* 算法
		-	组合
			-	哈夫曼树（编码）

> - *OI Wiki* 贪心算法：<https://oi-wiki.org/basic/greedy/>

##	近似算法

-	近似算法常采用迭代策略：从可行解出发，通过重复应用简单步骤不断改进
	-	初始可行解可设置为
		-	平凡解
		-	其他算法（贪婪算法）得到近似解
	-	简单步骤通过小的、局部的改变生成新可行解，优化目标函数
	-	当目标函数达到极值（无法改进），返回最后可行解
		-	最终解仅为局部最优，仅适合要求较优解、近似解场合

-	近似算法是基于特定问题的，不具有普遍性
	-	不同问题的求解良好近似解难度不同，即使二者可在多项式时间内相互转换
	-	某些组合优化难题具有特殊的实例类型，在实际应用中重要、容易求解

> - *Heuristic Algorithm*：启发式算法，来自于经验而不是数学证明的*经验规则*

###	*Perfermance Ratio*

-	*Perfermance Ratio* 算法性能比：$R_A = \min \{c| r(s_a) \leq c\}$
	-	$r(s_a) = \frac {f(s_a)} {f(s^{*})}$：优化目标函数 $f$ 在近似解 $s_a$ 下的准确率
		-	此处 $f$ 为最小化问题目标函数（最大化问题则取倒数）
		-	比值越接近 1，近似解质量越高
	-	$R_A$ 即为问题所有实例中最差精确率，可用于衡量近似算法质量
		-	有些问题没有有限性能比的近似算法，如：旅商问题（除非 $P = NP$）

-	旅商问题无有限近似比算法
	-	若存在有限近似比算法，则 $\exists c, f(s_a) \leqslant cf(s^{*})$
	-	将哈密顿回路问题图 $G$ 变换为旅行商图 $G^{'}$，$G$ 中原有边距离为 1，不存在边距离为 $cn+1$
	-	近似算法能在多项式时间内生成解 $s_a, f(s_a) \leqslant cf(s^{*}) = cn$，
		-	若存在哈密顿回路，则旅行商问题中最优解 $s^{*} = n$
		-	否则，旅行商问题最优解 $s^{*} > cn+1$
		-	则近似算法能在多项式时间解决哈密顿回路问题，而哈密顿回路问题为 $NPC$ 问题，除非$P = NP$


