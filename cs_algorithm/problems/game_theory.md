#	博弈论

##	总述

##	约瑟夫斯问题

n个人围成圈编号{1..n}，从1号开始每次消去第2个人直到最后一个
人，计算最后人编号$J(n)$。

> - 对整个圈处理一遍后即得到规模为n/2子问题。

###	减常因子算法

####	算法

对n为奇数、偶数分别考虑

-	$n=2k$为偶数时，$J(2k)=2J(k)-1$
-	$n=2k+1$为奇数时，$J(2k+1)=2J(k)+1$

####	特点

-	可以将两个递推式合并

-	这个问题最简单的解法：对n本身做一次**向左循环位移**
	-	？？？#todo

##	双人游戏

-	双人游戏中往往涉及两个概念
	-	*state*：状态，当前游戏状态、数据
	-	*move*：走子，游戏中所有可能发生的状态改变
-	状态、走子彼此之间相互“调用”
	-	状态调用走子**转化**为下个状态
	-	走子调用状态**评价**当前状态

```c
make_move(state, move):
	switch move:
		case move_1:
			state = move_1(state)
			evaluate_state(state)
		...other cases...

evaluate_state(state):
	switch state:
		case state_1:
			make_move(state, move_1)
		...other cases...
	end game
```

###	拈游戏

同样局面，每个玩家都有同样可选走法，每种步数有限的走法都能
形成游戏的一个较小实例，最后能移动的玩家就是胜者。

-	拈游戏（单堆版）：只有一堆棋子n个，两个玩家轮流拿走最少
	1个，最多m个棋子
-	拈游戏（多堆版）：有I堆棋子，每堆棋子个数分别为
	${n_1,\cdots,n_I}$，可以从任意一堆棋子中拿走任意允许数量
	棋子，甚至拿走全部一堆

####	减可变规模算法

#####	算法

（单堆）从较小的n开始考虑胜负（标准流程）

-	n=0：下个人失败
-	1<=n<=m：下个人胜利（可以拿走全部）
-	n=m+1：下个人失败（无论拿走几个，对方符合1<=n<=m
	胜利条件）
-	数学归纳法可以证明：n=k(m+1)时为败局，其余为胜局

```c
// 两个函数轮流递归调用
find_good_move(coins):
	// 判断当前是否有成功步骤
	// 输入：棋子数目
	// 输出：成功策略或没有成功策略
	for taken=1 to limit do
		if(is_bad_position(coins-taken))
			// 对手没有成功策略
			return taken
	return NO_GOOD_MOVE

is_bad_position(coins):
	// 判断当前是否是good position
	// 输入：棋子数量
	// 输出：是否有成功策略
	if (coins == 0)
		return true
	return find_good_move(coins) == NO_GOOD_MOVE
		// 没有成功策略
```

####	特点

-	堆为2时，需要对两堆是否相同分别考虑

-	对更一般的I堆时
	-	对每堆数量的位串计算*二进制数位和*
	-	结果中包含至少一个1则对下个人为胜局，全为0则为负局
	-	则玩家下步要拿走的棋子数量要使得位串二进制数位和全0
		，则对方陷入负局

	-	#todo又是二进制？？？和约瑟夫斯问题一样了
	-	但是这里没有涉及最多能拿几个啊，不一定能够成功拿到
		使拈和全为0啊

> - 二进制数位和（拈和）：每位求和并忽略进位（奇或）


