#	编码问题

##	抽象字符集（ACR）

Abstract Charater Repertoire

###	字符

字母、数字、标点、表意文字（汉字）、符号或其他文本形式的
“原子”

###	抽象字符

抽象的字符，包括空白、不可打印的字符

-	对于某些语言中，抽象字符应该还包括发音字符

-	如：印度语中单词“नमस्ते”
	-	有6个字符['न', 'म', 'स', '्', 'त', 'े']，
	-	其中4、6两个字符在单词不出现，是发音字符

###	抽象字符集

抽象字符的集合

-	集合表明无序性
-	有时也简称为字符集（charater set）
-	有开放（字符不会改变）和封闭之分（会扩张）

##	编码字符集（CCS）

Coded Character Set

###	码位（Code Point）

抽象字符集中与字符关联的数字编号

-	一般是非负整数
-	习惯上有16进制表示

###	编码字符集

每个所属字符都分配了码位的抽象字符集

-	经常简称为字符集（charater set），同ACR弄混
-	字符与码位一一映射
-	可以更加方便的引用字符集中的某个元素
-	可以类比于dict

###	字符集（抽象、编码）举例

####	US-ASCII

-	128个抽象字符，封闭字符集
-	一般字符集都是兼容ascii编码字符集，即同一字符的码位相同

####	GBK

2w+中日韩汉字和其他一些字符，包括

-	`gb2312`/`gb0`：国标简体，6713个，涵盖绝大部分日常生活
-	`big5`：台湾繁体，13053
-	外加一些符号和少数民族文字

####	UCS(Unicode, universal character set)

-	统一字符集，*ISO/IEC 10646*定义的编码字符
	（`unicode`字符集）

-	容纳一切字符，包括emoji等，开放字符集

-	unicode中码位不是连续分配的

	-	目前为止，分为`0x0000~0x10FFFF`共17个平面

	-	其中0平面`0x0000~0xFFFF`称为`BMP`
		（basic multilingual plane）

	-	`BMP`中码位只有16bit长度，能够节约大量存储空间，有
		战略意义

	-	因此“常用”语言的常用字符放在`BMP`，其他不常用的
		字符只能放在其他平面

-	unicode本身是指一系列用于计算机表示所有语言字符的标准

##	字符编码表（CEF）

Character Encoding Form

###	字符编码表

将码位映射为码元序列

-	*fixed-length-encoding*：定长编码，对每个码位（字符）
	赋予长度同为m的码元（位串）

	-	*封闭字符集*符号有限，可以直接确定一一对应编码表

-	*variable-length-encoding*：变长编码，允许对不同码位
	赋予不同长度的码元

	-	*开放字符集*包括符号无上限，无法定长码元表示码位，
		必须有某种方式将码位一一映射为码元序列
	-	*封闭字符集*出于节约成本考量，也可能使用变长编码
		如：*Huffman*编码

> - 码元：能用于处理或交换编码文本的最小比特组合（位串）

###	`unicode`定义的CEF

本质思想：预留标记位值使码元序列的长度实现变长

####	`utf-8`
		
-	码元为1B
-	对`BMP`中字符一般需要`1~3B`，`BMP`外需要4B
-	兼容“`ascii`编码表（方案）”
	-	不同于**编码字符集兼容**的意义
	-	指使用“`ascii`编码方案”可以使用`utf-8`解码方案直接
		解码

####	`utf-16`

-	码元为2B
-	对`BMP`中字符一般需要2B，`BMP`外需要4B

####	`utf-32`

-	码元为4B

###	Prefix-Free Code

（自由）前缀码：所有代码码元都不是另一个字符码元的前缀

-	可以简单扫描位串直到得到一组有效码元，转换为相应字符

-	这样编码表可以很容易用一棵（编码）二叉树表示

	-	树左向边标记为0、右向边标记为1
	-	叶子节点表示字符，根节点到叶子节点路径为其码元
	-	树中叶子节点到其他叶子节点的简单路径不存在，即码元
		不可能为其他码元前缀
	-	所以任何二叉树对应一套编码表

-	这种编码方案一般用于产生**平均长度最短**的位串
	-	因此这类编码方案以bit为单位，而不是以byte为单位

####	Huffman编码

哈夫曼编码：*prefix-free code*的一种

-	根据字符出现频率进行编码
	-	需要事先知道字符出现概率
	-	可以事先扫描给定文本，对文本中字符出现字符计数
	-	将较短位串分配给高频字符、较长位串分配给低频字符

-	若字符独立出现，则哈夫曼编码是最优编码（最短长度编码）

-	需要把编码树信息包含在编码文本中才能正确解码

> - 构造哈夫曼树的贪婪算法参见组合问题

####	Adaptive Huffman Encoding

利用已经处理字符串动态更新编码

####	Lempel-ziv

对字符串编码

##	字符编码方案（CES）

Character Encoding Schema

###	字符编码方案

*字符编码表+字节序列化*方案，将码位映射为**字节流**

-	大小端序问题：码元高位还是低位字节在前
-	字节序标记问题：不同程序之间端序交流

通常所说编码、解码（encode、decode）就是指使用CES

####	磁盘/内存

-	字符编码方案不仅仅是在硬盘文件中使用，在内存也是按照
	字符编码方案存储字符串

-	理由很简单，内存中如果不使用字符编码方案，直接使用码元，
	一样会出现长度问题

> - 以上仅对`unicode`而言，对于`ascii`来说没有区分必要

####	编码字节流/字符

-	虽然在内存中，字符仍然使用某种编码方案得到字节流存储

-	但这个字节流并不是这个字符，码位才“是”这个字符

-	在考虑字符串问题时，可以“抽象的”忽略具体存储方式，认为
	存储的就是“码位”本身

###	字节序标记（BOM）

Byte Order Mark：放置于编码字节开始处的特殊字节序列，表示
序列大小端序

-	`0xFFFE`
-	`0xFEFF`

###	*Unicode*族CES方案

####	*UTF*

*unicode transfromation format*：历史上是指CES，而*utf-X*
现在可以同时指代CES和CEF，*Unicode*族标准CEF方案

-	*utf-8*：utf-8编码表码元为1B，不存在字节序问题

	-	指代CES和CEF没有什么区别，CEF只有一种

-	*utf-16*：指代CES和CEF时有歧义，需要明确指明是
	*utf-16 encoding form*（码元序列）、
	*utf-16 encoding schema*（字节流）

	-	*utf-16le*：utf-16编码表小端版本
	-	*utf-16be*：utf-16编码表大端版本
	-	*utf-16*：utf-16编码表带BOM版本，大小端均可

-	*utf-32*

	-	*utf-32le*：
	-	*utf-32be*
	-	*utf-32*

####	*UCS*

*unicode*还有两种非标准CES

-	*ucs-2*：使用2B定长序列化码位
-	*ucs-4*：使用4B定长序列化码位

###	其他字符集CES方案

US-ASCII、GBK都有自己的编码方案，只是编码方案太简单，以至于
CCS、CEF、CES三层合一

##	传输编码语法（TES）

*transfer encoding syntax*：有时候仅仅将字符表示为字节流还
不够，有些字符可能不允许出现，需要对字节流再次编码

###	举例

-	*base64编码*：将字节流映射成64个安全字符集组成的字符流

##	输入、输出辨析

###	输入

同一个字符（码元）的具体输入字节流随输入编码方案决定

-	所有的输入都是字节流，包括数字

-	字节流具体内容由输入来源的编码方案决定

	-	文件输入流：文件编码方案决定
	-	标准输入流（terminal）：terminal编码方案决定
	-	管道传输流：由管道输入端的编码方案决定

###	处理

取决于解释器、编译器、系统等处理主体的编码方案

-	这部应该有两种处理方式

	-	将输入字节流视为其自身编码方案字节流，直接储存
	-	使用多种可能编码方案依次尝试解码

-	在这一步就可能出现两个编码方案不一致的情况

###	输出

-	所有的输出也都是字节流，包括数字

-	输出的去向

	-	文件输出流：`write`
	-	标准输出流（terminal）：`print`
	-	管道传输流：

-	这个输出是指传递给**直接输出外部**的输出

	-	高层函数执行过程中，可能会隐式调用一些转换为字符串
		的函数，不是指这种输出
	-	这个字符串实际上就是主体编码后的字节流

###	显示

底层函数将收到的主体编码字节流直接传递给显示程序
（terminal等），如果显示程序和主体编码方案不同会出现乱码

###	例子

以utf-8编码方案为例

-	输入的所有的内容都是由*utf-8*编码方案编码的字节流

-	处理主体获取字节序列，根据指令处理字节序列

	-	比如字节序列编码和处理主体编码不同，将其**解码**为
		**主体编码方案**
	-	比如按照**约定**将字节序列转变为不同类型的数据

-	输出则是将需要输出的内容（包括数字等）转换字节流传给底层
	函数












