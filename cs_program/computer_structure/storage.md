#	存储

##	基本类型

###	大小端问题

> - *big-little endian*：高位**byte**在低位**byte**前
> - *little-big endian*：低位**byte**在高位**byte**前

-	大小端：更适合人理解
-	小大端：更适合计算机计算，大部分计算机架构
	-	方便截断操作

###	整形

> - 机器数：数在计算机中二进制表示形式，带符号
> - 真值：考虑表示规则，机器数二进制表示的真实数值

-	计算机中一般使用最高位表示符号
	-	`0`：正数
	-	`1`：负数

-	也有的语言不使用最高位作为符号位，如：python
	-	python语言模型中没有负值，使用`-`一元运算符计算负值
	-	其最高位不表示符号位
	-	但其**使用原码存储**整形数值，所以python中有些位运算
		特殊
		-	`x ^ 0xffffffff`类似异或运算永远为正值
		-	但`~x`、`>>`、`<<`等运算结果同C
		-	`~(b^0xffffffff)`：通过负数补码`b`得到对应负值
#todo

####	二进制码

> - 原码：最高位表示符号，其余数字位表示数值本身绝对值

> - 反码
> > -	正数：反码即为其原码
> > -	负数：反码为原码符号位不变，数值位取反

> - 补码：
> > -	正数：补码即为其原码
> > -	负数：补码为反码+1

-	原码存储数据
	-	最容易理解
	-	做正数加减法时需要额外处理符号位

-	反码存储数据
	-	符号位可以直接参与运算得到正确结果
	-	但是会出现正、负0两个0

-	补码存储数据
	-	符号位可以直接参与运算得到正确结果
	-	正、负0问题被解决
	-	负数值域增加1

####	代数性质

-	反码数值位值是**真值对最大值的同余**
	-	求和时，考虑到溢出、符号位参与运算能得到正确结果

-	补码仅仅是在反码的基础上**模大小加1**
	-	负数补码原码相互转换：数值位减1求反

###	浮点型






