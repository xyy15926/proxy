#	*Parallel*

##	执行实体

> - *Parallel*：并行，**同时做**多件事情，关于执行
> - *Concurrent*：并发，**能够处理**多件事情，关于结构

-	并发问题可以使用并行方式解决，也可以串行解决
	-	100个进程同时运行在4核CPU上，最多可能有4个进程并行
		处理，其余只能是串行处理

||进程|线程|
|-----|-----|-----|
|性能（上下文切换开销、速度）|大、慢|小、快|
|易用性|需要考虑进程退出、僵尸进程|只需要管理进程即可|
|资源共享|独立|同一进程内线程共享资源|
|通信|较复杂：环境变量、文件、系统端口|较简单：共享内存|
|移植性|差|好|
|健壮性|好，进程死亡不影响其他进程|差，线程死亡会导致进程（及线程）死亡|


> - 线程性能更好，能提升某些场景的并发性
> - 通信：参见*cs_program/parallel/#todo*
> - 移植性：基于进程分支多进程和windows模型有很大冲突，往往
	不能在windows平台上使用

###	*Process*

进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动

-	系统进行**资源分配、调度的独立单位**
	-	调度：分配CPU执行进程
	-	上下文切换：进程状态的记录、恢复、切换

-	**独立内存空间**
	-	地址空间
	-	全局变量
	-	文件描述符
	-	硬件资源

-	上下文进程间切换开销比较大，但相对比较稳定安全
	-	栈
	-	寄存器
	-	虚拟内存
	-	文件句柄

###	*Thread*

线程：进程实体

-	**CPU调度、分派的基本单位**
	-	比进程更小的、能独立运行的基本单位
	-	用于**并行调用函数**，有时被称为“轻量级进程”

-	线程自身不拥有系统资源
	-	只拥有运行中必须的资源
		-	程序计数器
		-	一组寄存器
		-	栈
	-	多个线程可以在同一进程中运行，彼此共享进程所拥有的
		全部资源

##	逻辑实体

-	进程、线程：反映硬件技术的**物理限制瓶颈**
	-	单计算核心能力不足，所以需要多核并行运算

-	子程序、协程：体现程序**逻辑重用需求**
	-	相较于进程、线程更基础
	-	可以作为语言内建机制

###	*Subroutine*/*Procedure*/*Function*/*Routine*/*Method*

子程序：打包为整体、用于执行特定任务的指令集序列

-	函数是依赖可重入能力的弱化版本
	-	一旦唤醒，于起始点开始执行
	-	一旦退出，子程序结束
	-	子程序实例只返回一次，两次激活间不保存状态

-	函数中局部变量在每次**调用/重入**函数时都是相同的
	-	**相同输入得到相同输出**

> - *procedure*：过程，有时特指无返回值、仅有副作用
> - 函数可以看作时协程的特例：只有一个状态，每次进入时局部
	状态重置

###	*Coroutine*

协程：为**非抢占式**多任务产生子程序的程序组件，允许执行过程
中挂起、恢复

-	挂起、恢复：协程可以通过调用其他协程暂时退出，之后可在
	退出位置恢复执行

	-	从协程角度看，这是调用其他协程而不是退出
	-	但实际是**各协程之间是对称的**，而不像子程序调用
		中主调-被调关系
	-	这即暗含：允许在不同入口点暂停、开始执行程序

-	局部状态维护：协程实例保持上次退出时状态

	-	则协程被唤醒时状态可能不同
	-	可能同时有多个给定协程实例

> - 协程将原在子程序外、输入状态管理工作交由自身逻辑维护
> - 原生不支持协程的语言也可以使用循环等构建
> - 经典状态机、对象已经具有协程特性

####	用途

-	协程可以简化异步代码的实现，使得需要使用异步+回调的代码
	可以使用看似同步方式写出

	-	协程本身只涉及**状态保存、过程重入**，和并发/异步无关系
	-	但协程本身蕴含的状态保存使得状态切换几乎无成本，适合
		高并发任务

-	协程在线程中调度完全由用户控制，可以视为用户态轻量级线程
	-	避免陷入**无效内核级别上下文切换**造成的性能损失
	-	较线程在IO密集任务上性能上更好

##	操作线程、进程模型

###	1对1

###	1对N

###	M对N

##	同步问题

###	生产者-消费者问题/缓存绑定问题

> - 生产者生成数据放入缓存，消费者从缓存获取、移除、消费数据
	，问题核心在于保证不让生产者在缓存已满时放入数据、不让
	消费者在缓存为空时读取数据

-	若缓存满：生产者者停止工作
-	若缓存空：消费者停止消费
-	消费者从缓存中取走数据，通知生产者工作
-	生产者向缓存中放入数据，通知消费者消费

> - 不完善的解决方案会造成死锁：生产者、消费者均等待对方唤醒

####	信号量解决方案

> - `mutex`信号量：互斥信号量，确保只有一个生产者、消费者
	操作缓存区，单一消费者、生产者可省略此信号量
> - `fill_count`信号量：已使用缓存区数量
> - `empty_count`信号量：空闲缓存区数量

```c
semaphore mutex = 1
semaphore fill_count = 0
semaphore empty_count = BUFFER_SIZE

producer():
	while true:
		item = produce_item()
		down(empty_count)
		down(mutex)
		put_item_into_buffer(item)
		up(mutex)
		up(fillcount)

consumer():
	while true:
		down(fill_count)
		down(mutex)
		item = remove_item_from_buffer()
		up(mutex)
		up(empty_count)
		consume_item(item)
```

####	状态监控解决方案

```c
item_count = 0
condition full
condition empty

add(item):
	while item_count == BUFFER_SIZE:
		wait(full)

	item_count = item_count + 1
	put_item_into_buffer(item)

	if item_count == 1:
		notify(empty)

remove():
	while item_count == 0:
		wait(empty)

	item_count = item_count - 1
	item = remove_item_from_buffer()

	if item_count == BUFFER_SIZE - 1:
		notify(full)

produer():
	while true:
		item = produce_item()
		add(item)

consumer():
	while true:
		item = remove()
		consume_item(item)
```

-	互斥信号没有保护关键区，监控方法更好

####	其他

-	协调生产者、消费者的关闭

	-	可在在队列中放置特殊的值，消费者读到时终止执行，结束
		消费者线程
	-	有多个消费者时，消费者读取特殊值之后可将特殊值放回
		队列中继续传递，直至关闭所有消费者

###	哲学家就餐问题

> - 哲学家围坐在圆桌旁，只能吃饭**或者**思考，每两个哲学家
	之间只有一根筷子，只有同时拿到左右两根筷子才能正常吃饭

-	实际计算机问题中，筷子视为共享资源

####	服务生

> - 引入服务生判断资源是否能被获取

-	引入服务生，哲学家必须经过其允许才能拿起筷子

-	服务生知道有哪些筷子正在被使用，能够判断是否会死锁

####	资源分级

> - 为资源（筷子）分配偏序关系
> > -	约定所有资源都按此偏序获取、相反顺序释放
> > -	且保证不会有无关资源同时被同一工作获取

-	哲学家只能拿左右侧筷子：不会有无关资源被同一工作获取

-	将筷子按顺序编号：资源分配偏序关系
	-	哲学家只能先拿左右筷子中编号较小者
	-	哲学家需要先放下筷子中编号较大者

> - 最实用的解法：为锁指定常量分级，强制获取顺序的顺序
> - 策略不总是实用的，尤其是所需资源列表事先不知道，可能需要
	先释放已获取资源、获取低编号资源、重新获取资源，效率不高

####	Chandy/Misra解法

> - 标记资源，保留未使用资源、交出已使用资源，初始所以资源
	已使用

-	每根筷子分为干净、脏，最初所有筷子都脏

-	对每对竞争同一筷子的哲学家，新拿筷子给编号较低者

-	当哲学家需要某筷子时
	-	向其竞争对手发送请求
	-	拥有筷子的哲学家收到请求
		-	若筷子干净则保留
		-	否则擦干净交出

-	哲学家吃完东西后，筷子变脏
	-	若有哲学家之前请求过该筷子，擦干净交出

> - 有很大并行性，适合任意大问题

###	读者-写者问题

> - 多线程同时访问共享内存地址，线程写入时其他线程不能读取、
	写入，多个线程可以同时读取

-	一般使用*readers-writer lock*解决问题

####	读者优先

-	若共享内存被读取，其他读者可以立即、同时读取
-	若一直有读者开始读取，则写者会一直被插队、无法修改

####	写者优先

-	如果写者在排队，应该尽快写入共享内存
-	若一直有写者准备写入，则读者会一直被插队、无法读取

####	限定时间

-	共享内存区的锁定权要在限定时间内结束
-	能避免读者、写者一直排队

###	熟睡的理发师问题

> - 理发店只有一名理发师、一张理发时坐的椅子、若干普通椅子
	供顾客等待
> > -	没有顾客时理发师在理发椅子上睡觉，顾客到达后离开、
		或者叫醒理发师
> > -	有顾客时，理发师为别人立法，顾客达到后若有空闲普通
		椅子则坐下休息、否则离开
> > -	理完发后，任选顾客开始理发

-	理发师等待顾客、顾客等待理发师，造成死锁
-	有顾客不按顺序等待，让某些顾客永远不能理发

####	3信标解决

```c
semaphore customer = 0
semaphore barber = 0
semaphore mutex = 1
empty_chairs = BUFFER_SIZE

barber():
	while true:
		if empty_chairs == BUFFER_SIZE:
			sleep()

		down(mutex)
		item = get_customer_from_chairs()
		empty_chairs += 1
		up(mutex)

		down(barber)
		cut_hair(item)
		up(barber)

customer():
	while true:
		down(mutex)
		if empty_chairs > 0:
			empty_chairs -= 1

		else:
			wait() or leave()

		up(mutex)
```

###	三个烟鬼问题

> - 香烟需要：烟草、卷烟纸、火柴，三个烟鬼分别有无限各一种，
	不吸烟协调人会随机安排两个烟鬼各拿出一份材料放在桌上，
	另外一个烟鬼拿到材料卷烟、抽
> > -	桌上空了后，协调人就随机要求烟鬼拿出材料
> > -	烟鬼只会在抽完手中烟后才会卷另一只
> > -	若烟草、卷烟纸在桌上，有火柴的烟鬼在吸烟，直到该烟鬼
		吸完烟拿走桌上材料才会继续

-	问题模拟程序中4种角色，展示信标方法作用有限

