#	算法设计策略

##	蛮力法

Brute Force：简单直接解决问题的方法，常常直接基于问题的描述
和所涉及的概念定义

###	特点

-	蛮力法可以解决各种问题，实际上可能是唯一几乎可以解决所有
	问题的方法
-	对某些重要问题，蛮力法可以产生合理算法，具备实用价值，
	且不必限制实例规模
-	如果解决问题实例不多，蛮力法速度可接受，设计高效算法可能
	不值得
-	蛮力法可以用于研究、教学目的，如：衡量同样问题其他更高效
	算法

###	案例

因为基本所有问题都可以使用蛮力得到**理论可行**的解决方法，
所以这里只包含实际可行、有价值算法

-	选择排序
-	冒泡排序

##	减治法

*Decrease and Conquer*技术利用问题给定实的解和同样问题较小
实例解之间某种关系，可以自底向上、自底向上的运用该关系

-	自顶向下会自然导致递归算法，但是还是非递归实现较好
-	自底向上往往是迭代实现的，从求解问题较小实例开始

减治法有3种主要变化形式

###	*Decrease-by-Constant*

减常量：每次算法迭代总是从实例中减去相同常量

-	*新问题规模 = 原问题规模 - constant*
-	一般来说这个常量为1

####	数值计算

-	自顶向下递归计算指数
-	利用指数定义自底向上计算指数

###	*Decrease-by-A-Contant-Factor*

减去常量因子：在算法迭代过程中总是减去相同的常数因子

-	*新问题规模 = 原问题规模 / constant-factor*
-	常数因子一般为2

####	数值计算

-	递归的计算$a^{n/2}$计算指数

###	*Variable-Size-Decrease*

减可变规模：算法每次迭代时，规模减小模式不同

####	数值计算

-	计算最大公约数的欧几里得算法
	$$gcd(m, n) = gcd(n, m mod n)$$

##	分治法

###	特点

-	将问题划分为同一类型的若干子问题，子问题规模最好相同
-	对子问题求解
	-	一般使用递归方法
	-	规模足够小时，有时也会利用其他算法
-	有必要则合并子问题的解得到原始问题答案

##	变治法

###	特点

变治法分成两个阶段工作

-	“变”：出于某种原因，把问题实例变得容易求解
-	“治”：对实例问题进行求解

根据对问题的变换方式，可以分为3类

###	*Instance Simplification*

实例化简：变换为同样问题的更简单、更方便的实例

-	预排序：

###	*Representation Change*

改变表现：变换为同样实例不同表现

###	*problem reduction*

问题化简：变换为算法已知的另一个问题的实例

###	典例

-	线性表（预排序）
	-	检验线性表唯一性
	-	寻找线性表众数
	-	查找线性表中元素
-	数值计算
	-	极大、极小值转换
	-	极值转换为求导数为0点
	-	线性规划：在极点求解
	-	整数规划
-	图问题
	-	把问题转换为状态图求解

##	动态规划

*Dynamic Programming*用于解决由**交叠**子问题构成问题

###	步骤

####	递推关系

导出问题实例的递推关系，其中包含较小、且交叠子问题解

-	所以一般递推关系中往往会有*max*、*min*等遍历比较类型
	的运算，否则不会有交叠子问题

-	事实上，一般动态规划就是用于求解**离散**最优化问题

-	动态规划递推中包含一个重要思想**有序组合**

	-	考虑变量时，有序的**剔除**，一般而言是单向剔除，
		有些变量需要考虑双向，视为两个有约束条件的独立
		变量（最优二叉树）

	-	因为*最优解定理*，最优解由子问题最优解构成

	-	更直观的，因为只需要求解全集最优解，所以只需要
		考虑部分有序子集，类似于**矩阵可逆**只需要判断
		**顺序主子式**

####	递推式

写出递推式表示递推关系

-	递推式中**因变量**往往就是最优解

-	递推式中**自变量**则为问题中涉及的**列表**

	-	包括：明显离散列表、**因变量限制条件**

	-	列表意味组合元素**数量为1**，若数量有限则展开，
		否则其不是自变量

	-	各自变量是各自组合的笛卡尔积的关系
-	n维列表，自变量数量+n（多维自身已经组合）

	-	两端都需要变化的变量视为两个独立、相互约束变量

-	递推式限制条件包括：自变量限制条件

####	记录解

求出交叠子问题的解并记录在表中，避免重复求解

-	否则就是普通递归，不能避免重复求解，或者说动态规划
	就是**普通递归+子问题解记录**

-	对多维表，常常逐行、逐列填充（求解子问题），一般而言
	**先初始化者先填**
	-	先初始化行，则在初始化列过程中可以在循环中填充行
	-	先初始化列，则在初始化行过程中可以在循环中填充列

####	原问题求解

从表中得到较小问题解，并用于求解更大规模问题，直至原问题求解
完成

-	需要通过回溯得到问题最优解的构成

###	分类

####	自底向上（经典）

需要求解给定问题所有较小子问题

-	计算用**所有**小问题解、填充表格

	-	自底向上没有对问题整体的全局把握，只能全部求解
	-	**循环**保证所需子问题已经求解完毕

-	每个小问题只求解一次

####	自顶向下

利用记忆功能，试图避免不必要的子问题求解

-	用自顶向下方式求解给定问题
-	同时维护类似自底向上的动态规划所使用的表格
	-	初始化时所有单元格标记未被计算
	-	之后需要计算子问题解时，先检查相应单元格，然后决定
		是否需要递归调用求解、记录

###	Principle of Optimality

最优化法则：最优化问题的任一实例的最优解，都是由其子问题实例
的最优解构成

-	最优化法则在大多数情况下成立，但也存在少数例外：寻找图
	中最长简单路径

-	在动态规划算法中，可以方便检查最优化法则是否适用

>	动态规划的大多数应用都是求解最优化问题

##	贪婪技术

贪婪法：通过一系列步骤构造问题的解，每步对目前构造的部分解
作扩展，直到得到问题的完整解

###	特点

-	只能应用于最优问题，但可以作为一种通用设计技术

-	贪婪法每步条件

	-	*feasible*：必须可行，满足问题约束
	-	*locally optimal*：是当前所有步骤中所有可行选择的
		最佳局部选择
	-	*irrevocable*：选择一旦做出不能更改

-	希望通过通过一系列局部最优选择产生全局最优解

	-	有些问题能够通过贪婪算法获得最优解
	-	对于无法通过贪婪算法获得最优解的问题，如果满足于、
		关心近似解，那么贪婪算法依然有价值

###	正确性证明

证明贪婪算法能够获得全局最优解方法

-	数学归纳法

-	证明在接近目标过程中，贪婪算法每步至少不比其他任何算法差

-	基于算法的输出、而不是算法操作证明贪婪算法能够获得最优解

###	拟阵


