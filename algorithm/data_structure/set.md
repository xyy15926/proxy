#	集合

##	Set总述

集合：互不相同项的无序组合
-	要么指出集合的特殊属性，只有集合中元素才满足的特性

###	集合运算

-	检查元素是否属于集合
-	集合的并集
-	集合的交集

###	表示方法

-	*bit vector*：长度为n的位串，当前仅当全集$U$中第i个元素
	被包含在子集$S$中时，位向量第i个元素为1

	-	这样的任意子集可以用一个位串表示
	-	可以实现快速的标准集合运算
	-	但是以使用大量存储空间为代价的

-	线性列表
	-	只适合有限集合
	-	集合不能包含相同元素，列表可以
		-	可以引入*multiset*、*bag*绕过对唯一性的要求
		-	多重集和包是可重复项的无序组合
	-	集合是元素的组合，而列表是集合的有序组合
		-	用线性表表示集合时，维护线性表的有序排列没必要

-	hashing：映射
#todo

##	不相交集

不相交集：由某个有限集的一系列不相交子集，及相应操作构成

-	这种抽象数据类型大多数实现，会使用每个不相交子集的某个
	元素作为子集代表
	-	有些对代表没有特殊约定
	-	有的要求代表为子集中最小元素等

-	通常假设集合中元素为整数，或可以映射为整数

###	操作

*union-find*算法：并查算法

-	`makeset(x)`：生成单个元素集合{x}，对集合每个元素只能
	应用一次
-	`find(x)`：返回包含x的子集
-	`union(x)`：构造分别包含x、y的不相交子集$S_x$、$S_y$的
	并集，添加到子集集合中，删除$S_x$、$S_y$

###	Quick Find实现

快速查找实现：查找操作的时间效率是最优的

-	使用索引为集合S中元素的**代表数组**实现快速查找

-	每个子集使用链表实现
	-	表头包含指向首、尾元素的指针、链表中元素个数

-	数组中值为其所属子集代表

####	操作效率

#####	`makeset(x)`

-	操作
	-	把代表数组赋值尾为`x`，创建单节点值为`x`的链表

-	时间效率
	-	单次时间效率$\in \Theta(1)$
	-	初始化n个单元素子集$\in \Theta(n)$

#####	`find(x)`

-	操作
	-	以`x`为索引从代表数组中其代表

-	时间效率$\in \Theta(1)$

#####	`union(x, y)`

-	操作

	-	合并`x`、`y`所属链表
		-	原：将`y`所属链表添加到`x`所属链表之后
		-	改进：把较短链表（不妨设为`y`链表）添加到较长
			链表之后

	-	更新`y`链表所有元素代表信息

-	时间效率

	-	单次操作代表更新次数最多（最差效率）$\in \Theta(n)$
	-	从头合并到尾
		-	原版最差效率$\in O(n^2)$
		-	改进版本最差效率$\in O(nlogn)$

###	Quick Union实现

快速求并实现：求并集操作是最优的

-	使用有根树表示每个子集
	-	树中每个节点包含子集中一个元素
	-	树根中元素作为子集代表

-	树中边从子女指向父母k

-	还需要维护一个指针数组实现集合元素到树中节点的映射

####	操作效率

#####	`makeset(x)`

-	操作
	-	创建一棵单节点树

-	时间效率
	-	单次时间效率$\in Theta(1)$
	-	初始化n棵单节点树$\in Theta(n)$

#####	`find(x)`

-	操作
	-	从指针数组得到对于节点
	-	沿着指针链得到所属树的的根（代表）

-	时间效率
	-	原版$\in O(n)$（树退化为链表）
	-	改进$\in O(logn)$（每次至少减半)
	-	路劲压缩后时间效率接近线性

#####	`union(x, y)`

-	操作
	-	原版：把`y`所属树根附加到`x`所属树根上
	-	改进：把较小（节点数量少、高度低）树附加到较大树
	-	路径压缩：每个节点直接指向树根

-	时间效率：$\in \Theta(1)$


