#	映射、字典

##	总述

能查找给定元素、增加新元素、删除元素的集合

-	需要处理的是动态内容的查找，因此需要在查找效率和其他两种
	操作中达到平衡
-	数组、散列法、平衡查找树都可以实现字典

##	Hashing散列

散列法：通过对每个键计算hash function值，得到位于0~m-1之间的
整数的hash address，把键分布在一维数组H[0..m-1] hash table中

###	Hash Function

选择合适散列表长度、散列函数尽可能减少collision

-	散列表长度相对键个数不应该过大避免空间浪费，也不应该过小
	影响算法时间效率

-	散列函数需要把键在散列表单元格中尽量均匀分

	-	所以散列表长度m常常选为质数（方便双散列）
	-	此要求散列函数必须考虑键所有比特位（否则容易发生碰撞）

-	散列函数必须容易计算

###	*load faotor*

负载因子：$\alpha = \frac n m$不应该和1相差太大

-	太大说明链表太长，查找时间很长
-	太小说明存在许多空链表，没有有效利用空间
-	接近1时，平均使用一次两次比较就能完成查找

###	开散列（分离链）

开散列：键被存储在附着于列表单元格上的链表上，每个链表包含
所有散列到该单元格的键（解决碰撞）

####	查找

-	对查找键K，使用同样散列函数计算键散的函数值$h(K)$
-	遍历相应单元格附着链表，查找是否存在键K

#####	算法效率

-	算法效率取决于链表长度，而链表长度取决于字典、散列表长度
	和散列函数质量
	-	成功查找需要检查指针次数$S = 1 + \alpha / 2$
	-	不成功查找需要检查指针次数$U = \alpha$
	-	计算散列函数值是常数时间操作
	-	若n和m大致相等，平均情况下$\in \Theta(1)$

-	算法查找的高效是以额外空间为代价的

####	插入

-	类似于查找，在链表尾部添加键即可
-	若n和m大致相等，平均状态下算法时间效率$\in \Theta(1)$

####	删除

-	查找需要删除的键，在链表移除即可
-	若n和m大致相等，平均情况下算法时间效率$\in \Theta(1)$

###	闭散列（开式寻址）

闭散列：所有键存储在散列表本身中，没有使用链表

-	表长度m至少要和键数量n一样大
-	需要解决碰撞问题

####	Linear Probing

线性探查，检查发生碰撞处后面单元格，如果单元格为空，则放置键
，否则继续查找直接后继（到尾部则循环）

#####	查找

-	给定查找键K，计算散列函数值$h(K)$
-	从$h(K)$开始向后遍历后继，比较K和单元格中键值
	-	若查找到匹配键，查找成功
	-	遇到空单元格，查找失败

#####	删除

闭散列不能直接删除，否则的中间出现空单元格，影响查找正确性

-	延迟删除：用特殊符号标记曾经被占用过、现被删除的位置

#####	算法效率

简化版本近似结论（散列规模越大，近似结论越正确）

-	成功查找访问次数：$S \approx \frac 1 2 (1+\frac 1 {(1-\alpha)})$
-	失败查找访问次数：$U \apporx \frac 1 2 [1+\frac 1 {(1-\alpha)^2}]$

#####	Cluster

聚类：散列表接满时，一序列连续单元格被占据

-	线性探查性能恶化，降低字典操作效率
-	聚类越来的越大时，新元素加入聚类可能性增加
-	大的聚类可能被新插入元素连接，导致更大程度聚合

####	Double Hashing

双散列法：增加一个散列函数$s(K)$，用于确定碰撞发生后，所使用
的探查序列遍历的固定增量

-	被探查序列为：$(h(K)+ i * s(K)) mod m, i=0, 1, 2, \cdots$

-	为了保证散列表中每个位置被探查，增量$s(K)$必须互质
	-	m为质数时自动满足
	-	文献推荐：$s(K) = m - 2 - K mod (m-2)$
	-	对较小散列：$s(K) = 8 - (K mod 8)$
	-	对较大散列：$s(K) = K mod 97 + 1$

#####	算法特点

-	数学分析比较困难，经验表明优秀的散列函数（两个），其性能
	较线性探查好
-	散列表趋满时，性能也会恶化

####	Rehashing

重散列：扫描当前表，将所有键重新放置在更大的表中

-	散列表趋满时唯一解决办法

###	应用

####	字典实现

字典实现主要是：平衡查找树、散列表

||散列表|平衡查找树|
|-----|-----|------|
|渐进时间效率|平均$\in \Theta(1)；最坏$\in \Theta(n)$|$\in \Theta(logn)|
|有序性保留|不假定键有序，不保证，不适合按序遍历、按范围查询|保证|

####	Extendible Hashing

其散列函数计算结果是一个存储段的磁盘地址

-	可扩充散列可用于存储磁盘上非常大型字典
	-	查找时先计算可能包含查找键K的存储段磁盘地址
	-	然后从磁盘中读取段中所有键，从中查找K
	-	存取主存开销较磁盘小很多，宁可多次存取主存


