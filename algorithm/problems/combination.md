#	组合问题

##	总述

-	寻找（明确地、隐含地）寻找一个组合对象
	-	排列
	-	组合
	-	子集
-	这些对象能满足特定条件并具有想要的属性
	-	价值最大化
	-	成本最小化

###	特点

无论从理论角度、实践角度而言，组合问题是计算领域最难的问题

-	随着问题规模增大，组合对象数量增长极快

-	没有一种已知算法，能在可接受的时间范围内，精确的解决
	大部分组合问题，且被普遍认为不存在（未被证实）

-	有些组合问题有高效求解算法，是幸运的例外

从更抽象的角度看，旅行商问题、图填色问题也是组合问题的特例

###	思路

-	*exhaustive search*：（穷举搜索）是简单的蛮力方法
	-	生成问题域每个元素
	-	选出满足问题约束的元素
	-	最后寻找期望元素

-	因为可能性太多，基本可能从动态规划方向着手

##	旅行商问题

Traveling Salesman Problem：找到给定n个城市之间的最短路径，
使得在回到出发城市之前，对每个城市只访问一次

-	有向图表述：顶点表示城市、边权表示城市之间距离，问题即可
	表述为求图的最短哈密顿回路

###	蛮力算法

####	算法

-	生成n-1个中间城市的组合得到所有旅行线路
-	计算线路长度，求得最短路径

####	特点

-	算法排序次数为$(n-1)!/2$

####	改进

-	线路成对出现，只是方向相反，可考虑任意两个相邻顶点，只
	考虑包含其某个排序的线路

##	背包问题

给定n个重量为$w_1, w_2, \cdots, w_n$价值为$v_1, v_2, ..., vn$
的物品和承重为$W$的背包，求能够装进背包的最有价值物品子集

###	蛮力算法

####	算法

-	考虑所有n个物品的子集
-	计算每个子集重量，找出可行子集
-	找到可行子集中价值最大子集

###	经典自底向上动态规划

依次求解所有子问题、记录

####	算法

设$F(i, j)$为由前i个物品、承重量为j的背包得到最优解

-	不包括第i个物品的子集中，最优子集价值为$F(i-1, j)$

-	包括第i个物品的子集中，最优子集是由该物品和前i-1个物品
	中能够放进承重量为$j-w_i$的背包的最优子集组成，总价值为
	$v_i + F(i-1, j-w_i)$

则递推式为

$$
F(i, j) =
\left \{ \begin{array}{c}
	max\{F(i-1, j), v_i + F(i-1, j-w_i)} & j-w_i \geqslant 0 \\
	F(i-1, j) & j-w_i \leqslant 0 \\
	0 & i=0 or j=0 (i, j \geqslant 0)
\end{array} \right.
$$

```c
Knapsack(Ws[1..n], Vs[1..n], W)
	// 动态规划求解背包问题
	// 输入：Ws[1..n]物品重量、Vs[1..n]物品价值，W背包承重
	// 输出：背包能够装载的最大价值
	for i = 0 to n do
		F[i, 0] = 0
	for j = 0 to W do
		F[0, j] = 0
		for i = 1 to n do
			if j >= Ws[i]:
				F[i, j] = max(F[i-1, j], Vs[i] + F[i-1, j-Ws[i])
				// 这里用于比较的F值，在之前的循环中已经确定
			else
				F[i, j] = F[i-1, j]
	return F[n, W]
```

####	算法特点

-	算法效率
	-	时间效率$\in \Theta(nW)$
	-	空间效率$\in \Theta(nW)$
	-	回溯求最优解组成效率$\in O(n)$

###	自顶向下动态规划

####	算法

```c
MFKnapsack(i, j)
	// 背包问题的记忆功能方法
	// 输入：i考虑的物品数量，j背包承重
	// 输出：前i个物品的最优可行子集
	// Ws[1..n]、Vs[1..n]、F[0..n, 0..W]作为全局变量
	for i = 0 to n do
		F[i, 0] = 0
	for j = 0 to W do
		F[0, j] = 0
	if F[i, j] < 0
		if j < Ws[i]
			value = MFKnapsack(i-1, j)
		else
			value = max(MFKnapsack(i-1, j),
				Vs[i] + MFKnapsack(i-1, j - Ws[i]))
		F[i, j] = value
	return F[i, j]
```

####	算法特点

-	算法效率
	-	相较于经典自底向上算法，时间效率提升常数因子，但是
		效率仍然$\in \Theta(nW)$
	-	相较于自底向上算法空间优化版版本而言，空间效率较低

##	拈游戏

同样局面，每个玩家都有同样可选走法，每种步数有限的走法都能
形成游戏的一个较小实例，最后能移动的玩家就是胜者。

-	拈游戏（单堆版）：只有一堆棋子n个，两个玩家轮流拿走最少
	1个，最多m个棋子
-	拈游戏（多堆版）：有I堆棋子，每堆棋子个数分别为
	${n_1,\dots,n_I}$，可以从任意一堆棋子中拿走任意允许数量
	棋子，甚至拿走全部一堆

###	减可变规模算法

####	算法

（单堆）从较小的n开始考虑胜负（标准流程）

-	n=0时，下个人失败
-	1<=n<=m时，下个人胜利（可以拿走全部）
-	n=m+1时，下个人失败（无论拿走几个，对方符合1<=n<=m
	胜利条件）
-	数学归纳法可以证明：n=k(m+1)时为败局，其余为胜局

####	特点

-	堆为2时，需要对两堆是否相同分别考虑
-	对更一般的I堆时
	-	对每堆数量的位串计算*二进制数位和*
	-	结果中包含至少一个1则对下个人为胜局，全为0则为负局
	-	则玩家下步要拿走的棋子数量要使得位串二进制数位和全0
		，则对方陷入负局

	-	#todo又是二进制？？？和约瑟夫斯问题一样了
	-	但是这里没有涉及最多能拿几个啊，不一定能够成功拿到
		使拈和全为0啊
	
>	二进制数位和（拈和）：每位求和并忽略进位（奇或）

##	分配问题

n个任务分配给n个人执行（一人一个），将任务j分配个人i的成本
为$C_{ijd}$，求最小成本分配方案

###	蛮力算法

####	算法

-	生成整数n的全部排列
-	根据成本矩阵计算每个分配方案总成本
-	选择和最小的方案

####	特点

-	算法排列次数为$n!$

##	币值最大化

给定一排n个硬币，币值为正整数$c_i, i=1, 2, \cdots, n$（币值
不唯一），在原始位置不相邻的情况下，使得所选硬币总金额最大

###	动态规划

####	算法

记最大可选金额为$F(n)$将可行规划分为两组

-	包含最后一枚硬币，最大金额为$c_n + F(n-2)$
-	不包含最后一枚硬币，最大金额为$F(n-1)$

则递推方程为

$$
F(n) = max\{c_n + F(n-2), F(n-1)\}, n>1 \\
F(0) = 0, F(1) = c_1
$$

```c
CoinRow(C[1..n])
	// 在所选硬币不相邻，从一排硬币中选择最大金额
	// 输入：C[1..n]保存n个硬币面值
	// 输出：可选硬币最大金额
	F[0] = 1
	F[1] = C[1]
	for i = 2 to n do
		F[i] = max(C[i] + F[i-2], F[i-1])
	return F[n]
```

####	算法特点

-	时间效率$\in \Theta(n)$
-	空间效率$\in \Theta(n)$

##	找零问题

需找零金额为n，最少需要多少面值为$d_1 < d_2 < \cdots < d_n$
的硬币，考虑$d_1 = 1$的一般情况

###	动态规划

####	算法

记$F(n)$为总金额为n的数量最少的硬币数目，定义$F(0)=0$


-	得到n的途径只能是在$n-d_j$上加入面值为$d_j$的硬币，其中
	$j=1, 2, \cdots, m$，且$n \geqslant d_j$

-	考虑所有满足条件$d_j$，选择使得且$F(n - d_j)$最小者

则递推式有

$$
F(n) =
\left \{ \begjn{array}{c}
	\mjn_{j: n \geqslant d_j} \{F(n - d_j)\} + 1 & n > 0\\
	0 & n = 0
\end{array} \rjght.
$$

```c
ChangeMaking(D[1..m], n)
	// 动态规划法求解找零问题，d_1 = 1
	// 输入：正整数n，币值数组D[1..m]
	// 输出：总金额为n的最少硬币数目
	F[0] = 0
	for i = 1 to n do
		tmp = \infty
		j = 1
		while j <= m and i >= D[j] do
			tmp = min(F[i-D[j], tmp)
			j += 1
		F[i] = tmp + 1
	return F[n]
```

##	硬币收集问题

在n * m格木板中存放有硬币，每格硬币最多一个，寻找左上角(1,1)
到右下角(n, m)路径，使得能够收集尽可能多硬币，每次只能向下、
向右移动

###	动态规划

####	算法

记$F(i, j)$为截止到第i行、第j列单元格$(i, j)$能够收集到最大
硬币数

-	单元格$(i, j)$只能经由$(i-1, j)$、$(i, j-1)$达到
	-	初值1：假定$F(0, j)=0, F(i, 0)=0$
	-	初值2；递推求解$F[1, j], F[i, 1]$

则递推方程为

$$
F(i, j) =
\left \{ \begin{array}{c}
	max \{F(i-1 ,j), F(i, j-1)\} + c_{ij} & 1 <= i <= n, i <= j <= m \\
	0 & i = 0 \or j = 0
\end{array} \right.
$$

```c
CoinCollection(C[1..n, 1..m])
	// 动态规划算法求解硬币收集问题
	// 输出：矩阵C[1..n, 1..m]表示单元格是否有硬币
	// 输出：在单元格[n, m]能够收集到的最大硬币数
	F[1, 1] = C[1, 1]
	for j = 2 to m do
		F[1, j] = F[1, j-1] + C[1, j]
		// 初始化首行
	for i = 2 to n do
		F[i, 1] = F[i-1, 1] + C[i, 1]
		for j = 2 to n do
			// 先填列
			F[i, j] = max(F[i-1, j], F[i, j-1]) + C[i, j]
	return F[n, m]
```

####	算法特点

-	算法效率
	-	计算每个单元格$F[i, j]$花费常量时间，所以算法时间
		效率$\in \Theta(nm)$
	-	算法空间效率$\in Theta(nm)$

##	生成排列

生成集合排列问题可以抽象为生成${1,\cdots,n}$所有$n!$个排列的
问题

-	假设$(n-1)!$个排列已经生成
-	则可以把n插入n-1个元素中可能的n个位置中去，得到较大规模
	问题的解

###	减常量算法

####	最小变化

-	在元素上使用小箭头标记其方向：$\overleftarrow_1\overleftarrow_2\overleftarrow_3\overleftarrow_4$
-	如果元素k的箭头指向相邻的较小元素，称在此排列中是移动的

```c
JohnsonTrotter(n)
	// 生成排列
	// 输入：正整数n
	// 输出：{1..n}所有排列列表
	将第一个排列初始化
	while 存在一个移动元素 do
		求最大的移动元素k
		把k和其箭头指向的相邻元素互换
		调转所有大于k的元素的方向
		将新排列添加到列表中
```

####	字典序

-	找到序列中最长递减后缀
	$a_{i+1} > a_{i+2} > \cdots > a_{n}$
-	将$a_i$同序列中大于其的最小元素交换
-	将新后缀颠倒，使其变为递增序列，加入列表中

```c
LexicographicPermute(n):
	// 以字典序产生排列
	// 输入：正整数n
	// 输出：字典序下，所有排列列表
	初始化第一个排列为12...n
	while 最后一个排列有两成连续升序元素 do
		找出使得a_i < a_{i+1}的最大的i
			// 即找到最长递减后缀
		找到使得a_i < a_j的最大索引
			// 即在后缀中大于其的最小元素索引
		交换a_i和a_j
		将a_{i+1}和a_{n}的元素反序
		将新排列添加至列表中
```

####	特点

-	JsonTrotter是生成排列最有效算法之一，其运行时间和排列
	数量成正比，即$\in \Theta(n!)$

##	生成子集

集合$A[a_1, \cdots, a_n}$的所有子集可以分为两组

-	包含$a_n$：${a_1, \cdots, a_n}$的所有子集
-	不包含$a_n$的子集：把$a_n$添加进${a_1, \cdots, a_n}$子集
	获得

同样的可以把集合抽象为位串，每个位串表示一个子集

###	减常量算法

####	字典序

按生成字典序（位串字典序）生成子集

-	将正序${1..n}$转换为二进制位串
-	依次按照二进制位串生成子集
	-	位串中为1表示对应元素在子集中

####	挤压序

按照挤压序（位串挤压序）生成子集

-	将倒序{n..1}转换为二进制位串
-	依次按照二进制位串生成子集
	-	位串中为1表示对应元素在子集中

>	Squashed Order：所有包含$a_j$子集必须紧排在所有包含
	$a_1, \dots, a_{j-1}$的子集之后

####	最小变化

每个子集和其直接前趋之间，要么增加一个元素，要么减少一个元素

-	即每个位串和直接前趋之间仅仅相差一位

```c
BRGC(n)
	// 递归生成二进制反射格雷码
	// 输入：正整数n
	// 输出：所有长度为n的格雷码位串列表
	if n == 1
		表L包含位串0、位串1
	else
		调用BRGC(n-1)生成长度为n-1的位串列表L1
		表L1倒序后复制给表L2
		把0加到表L1每个位串前
		表1加到表L2每个位串前
		把表L2添加到表L1后得到表L
	return L
```

