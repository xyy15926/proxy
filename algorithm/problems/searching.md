#	查找

##	总述

在给定的集合、多重集（允许多个元素具有相同的值）中找给定值
（查找键，*search key*）

-	顺序搜索
-	折半查找：效率高但应用受限
-	将原集合用另一种形式表示以方便查找

###	评价

没有任何一种查找算法在任何情况下都是最优的

-	有些算法速度快，但是需要较多存储空间
-	有些算法速度快，但是只适合有序数组

查找算法没有稳定性问题，但会发生其他问题

-	如果应用里的数据相对于查找次数频繁变化，查找问题必须结合
	添加、删除一起考虑

-	必须仔细选择数据结构、算法，以便在各种操作的需求间达到
	平衡

##	无序线性表查找

###	顺序查找

####	算法

-	将给定列表中连续元素和给定元素查找键进行比较
	-	直到遇到匹配元素：成功查找
	-	匹配之前遍历完整个列表：失败查找

```c
SequentialSearch(A[0..n-1], K)
	// 顺序查找，使用**查找键作限位器**
	// 输入：n个元素数组A、查找键K
	// 输出：第一个值为K的元素位置，查找失败返回-1
	A[n] = K
	i = 0
	while A[i] != K do
		i = i + 1
	if i < n
		return i
	else
		return -1
```

####	改进

-	将查找键添加找列表末尾，查找一定会成功，循环时将不必每次
	检查是否到列表末尾
-	如果给定数组有序：遇到等于（查找成功）、大于（查找失败）
	查找键元素，算法即可停止

###	二叉查找树

####	算法

-	对数组构建二叉查找树
-	在二叉查找树上进行查找

####	特点

-	算法效率：参见二叉查找树

-	构建二叉查找树（插入）和查找操作基本相同，效率特性也相同

-	减可变规模 + 输入增强

###	预排序查找

对线性表预排序，有序表中查找速度快得多

####	算法

```c
PreorderSearch(A[0..n-1])
	// 对数组预排序然后查找
	// 输入：可排序数组A[0..n-1]
	// 输出：元素在数组中的位置
	对B[(数组元素, 索引)]进行预排序
	使用折半查找寻找二元组
	返回二元组中索引
```

####	特点

-	算法时间效率：取决于排序算法
	-	查找算法在最差情况下总运行时间$\in \Theta(nlogn)$
	-	如果需要在统一列表上进行多次查找，预排序才值得

-	这种**预排序**思想可以用于众数、检验惟一性等，此时算法
	执行时间都取决于排序算法（优于蛮力法$\in Theta(n^2)$

	```c
	PresortElementUniqueness(A[0..n-1])
		// 先对数组排序，求解元素唯一性问题
		// 输入：n个可排序元素构成数[0..n-1]
		// 输出：A中有相等元素，返回true，否则false
		对数组排序
		for i=0 to n-2 do
			if A[i] = A[i+1]
				return false
		return true
	```

	```c
	PresortMode(A[0..n-1])
		// 对数组预排序来计算其模式（众数）
		// 输入：可排序数组A[0..n-1]
		// 输出：数组模式
		对数组A排序
		i = 0
		modefrequency = 0
		while i <= n-1 do
			runlength = 1
			runvalue = A[i]
			while i + runlength <= n-1 and A[i+runlength] == runvalue
				// 相等数值邻接，只需要求出邻接次数最大即可
				runlength = runlength+1
			if runlength > modefrequency
				modefrequency = runlength
				modevalue = runvalue
			i = i+runlength

		return modevalue
	```

-	变治法（输入增强）

##	有序线性表查找

###	折半查找

####	算法

对**有序数组**，比较查找K和数组中间元素A[m]完成查找工作

-	如果：A[m] == K，查找结束
-	若：K < A[m]，对数组前半部分执行该操作
-	若：K > A[m]，对数组后半部分执行该操作

```c
BinarySearch(A[0..n-1], K)
	// **非递归**折半查找
	// 输入：升序数组A[0..n-1]、查找键K
	// 输出：数组元素下标K，若存在；否则返回-1
	l = 0
	r = n - 1
	while l <= r do
		m = ceiling((l + r) / 2)
		if K = A[m]
			return m
		elif K < A[m]
			r = m - 1
		else l = m + 1
	return -1
```

####	特点

-	折半查找时间效率
	-	最坏情况下：$\in \Theta(log n)$
	-	平均情况下仅比最差稍好

-	就**依赖键值比较**的查找算法而言，折半查找已经是最优算法
	，但是插值算法、散列法等具有更优平均效率

-	减常因子因子法

###	插值查找

Interpolation Search：查找有序数组，在折半查找的基础上考虑
查找键的值

####	算法

-	假设数组值是线性递增，即*数字值~索引*为一条直线，则根据
	直线方程，可以估计查找键K在A[l..r]所在的位置
	$$
	x = l + \left \lfloor \frac {(K-A[l])(r-l)}
		{A[r] - A[l]} \right \rfloor
	$$

-	若k == A[x]，则算法停止，否则类似折半查找得到规模更小的
	问题

####	特点

-	即使数组值不是线性递增，也不会影响算法正确性，只是每次
	估计查找键位置不够准确，影响算法效率

-	统计考虑
	-	折半插值类似于非参方法，只考虑秩（索引）方向
	-	插值查找类似参数方法，构建了秩（索引）和数组值模型，
		但是线性关系基于假设
	-	如果模型错误可能会比折半查找效率更差，即在数据分布
		分布偏差较大的情况下非参方法好于参数方法

-	所以是否可以考虑取样方法，先取5个点构建模型，然后估计

-	算法效率
	-	对随机列表，算法比较次数小于$log_2log_n+1$
	-	最差情况，比较次数为线性，没有折半查找稳定
	-	Robert Sedgewick的Algorithms中研究表明，对较小文件
		折半查找更好，大文件、比较开销大插值查找更好

-	减可变规模

##	字符串匹配

###	蛮力字符串匹配

####	算法

-	将pattern对齐文本前m个字符，从左向右匹配相应字符
	-	m个字符全部匹配，匹配成功，算法停止
	-	遇到不匹配字符则
-	模式右移1位，然后从模式首个字符开始重复以上匹配
-	在n-m位置无法匹配成功，则无足够匹配字符，算法停止

```c
BruteForceStringMatch(T[0..n-1], P[0..m-1])
	// 蛮力字符串匹配
	// 输入：文本T：n个字符的字符数组
	//       模式：m个字符的字符数组
	// 输出：查找成功返回文本第一个匹配子串中第一个字符位置
	for i = 0 to m-m do
		j = 0
		while j < m and P[j] = T[i+j] do
			j = j + 1
			if j = m
				return i
	return -1
```

####	特点

-	最坏情况下，算法比较次数属于$O(nm)$
	-	即在移动模式之前，算法需要做足m次比较
	-	但是一般在自然语言中，算法平均效率比最差好得多
	-	在随机文本中，有线性效率



