#	图算法

##	总述

-	图的遍历算法：如何一次访问到网络中所有节点
-	最短路线算法：两个城市间最佳路线
-	有向图拓扑排序：课程、预备课程是否有矛盾
-	All-Pairs Shortest-Paths Problem：完全最短路径问题，找到
	每个顶点到其他所有顶点的距离

##	遍历算法

###	Depth-First Search

深度优先查找（DFS）

####	算法

-	从**任意顶点**开始访问图顶点，然后标记为已访问
-	每次迭代时，紧接着处理与当前顶点**邻接的未访问顶点**，
	直到遇到终点，该顶点所有邻接顶点均已访问过
-	在终点上，算法**沿着来路**后退一条边，继续从那里访问未
	访问顶点
-	后退到**起始点**，且起始点也是终点时，算法停止，这样
	起始点所在的连通分量的所有顶点均已访问过
-	若存在未访问顶点，则必须从其中任一顶点开始重复上述

```c
count = 0
	// 全局变量：访问次序（次数）
DFS(G)
	// 对给定图的深度优先查找遍历
	// 输入：图G=<V, E>
	// 输出：图G顶点按照DFS遍历第一次访问到的先后次序，
	//       未访问到标记未0
	for each vertex v in V do
		if v is marked with 0
			dfs(v)
dfs(v)
	// 递归访问所有和v相连接的未访问顶点，赋予count值
	count = count+1
	mark v with count
	for each vertex w in V adjecnt to v do
		if w is marked with 0
			dfs(w)
```

####	特点

-	算法效率非常高效，消耗时间和表示图的数据结构规模成正比
	-	邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$
	-	邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$

-	可以方便地用栈跟踪深度优先查找
	-	首次访问顶点，将顶点入栈
	-	当顶点成为终点时，将其出栈
	-	运行时就是实际上就是栈，所以深度优先可以直接利用递归
		实现

-	*Depth-First Search Foreat*
	-	遍历的初始顶点可以作为森林中树的根
	-	遇到新未访问的顶点，将其附加为**直接前趋**子女
	-	*tree edge*：连接深度优先查找森林中父母、子女顶点的
		边，其集合构成森林
	-	*back edge*：指向已访问顶点的边，且顶点不是其直接
		**前趋**，其在深度优先查找森林中将顶点与其非父母祖先
		相连接

-	DFS产生两种节点排列顺序性质不同，有不同应用
	-	入栈（首次访问顶点）次序
	-	出栈（顶点成为终点）次序

####	应用

-	检查图连通性：算法第一次停止后，是否所有顶点已经访问
-	检查图无环性：DFS是否包含回边
-	拓扑排序：见*键值法*
	-	DFS节点出栈逆序就是拓扑排序的一个解（图中无回边，
		即为有向无环图）
	-	DAG中顶点v出栈前，不存在顶点u拥有到v的边，否则存在
		回边，图不是DAG

###	Broad-First Search

广度优先查找（BFS）

####	算法

-	首先访问所有和初始顶点邻接的顶点
-	然后是离它两条边的所有未访问顶点
-	以此类推，直到所有与初始顶点在同一连通分类顶点均已访问
-	若存在未访问顶点，从图其他连通分量任意顶点开始

```c
count = 0
	// 全局变量：访问次序（次数）
BFS(G)
	// 给定图广度优先查找变量
	// 输入：图G=<V, E>
	// 输出：图G的顶点按照被BFS遍历第一次访问到次序，
	//       未访问顶点标记未0
	for each vertax v in V do
		if v is marked with 0
			bfs(v)
bfs(v)
	// 访问所有和v相连接的顶点，赋count值
	count = count+1
	whilte queue is not empty do
		for each vertex w in V adjcent to the front vertex do
			if w is marked with 0
				count = count+1
				mark w with count
				add w to the queue
		remove the front vertex from the queue
```

####	特点

-	算法效率同DFS
	-	邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$
	-	邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$

-	使用队列可以方便地跟踪广度优先查找操作
	-	从遍历初始顶点开始，标记、入队
	-	每次迭代时，算法查找所有和队头顶点邻接未访问，标记
		、入队、将队头顶点出队

-	*Breadth-First Search Forest*
	-	遍历的初始顶点可以作为森林中树的根
	-	遇到新未访问的顶点，将其附加为**直接前趋**子女
	-	*tree edge*：连接BFS森林中父母、子女顶点的边，其集合
		构成森林
	-	*cross edge*：指向已访问顶点的边，且顶点不是其直接
		**前趋**，其在BFS树连接同层、相邻层兄弟节点

-	BFS只产生顶点的一种排序，因为队列时FIFO结构，顶点入队、
	出队次序相同

####	应用

-	和DFS一样可以检查图的连通性、无环性，但是无法用于比较
	复杂的应用
-	求给定两个顶点间最短路径：从一顶点开始BFS遍历，访问到
	另一节点结束（难以证明？）

##	无权路径

###	路径数量

图中顶点i到顶点j之间长度为k的不同路径数量为$A^k[i, j]$

-	A为图的邻接矩阵
-	可以使用数学归纳法证明
-	对无向、有向图均适用

###	Warshall算法

Warshall算法：生成有向图传递闭包

-	构造n+1个n阶布尔矩阵$R^{(k)}, k=0,1,\cdots, n$

	-	$R^{(k)}_{ij}=1$：顶点i、j直接存在中间顶点**编号**
		不大于k的有效路径

	-	$R^{(0)}$：邻接矩阵，顶点直接连接

	-	$R^{(k)}, 0<k<n$：路径中间顶点编号最大为`k`

	-	$R^{(n)}$：传递闭包，允许所有类型路径

	-	后继矩阵相对前趋，允许作为路径上顶点增加，可能包含
		1数量更多

-	考虑$R^{(k)}$通过直接前趋$R^{(k-1)}$计算得到

	-	$R^{(k-1)}$中已有路径在$R^{(k)}$保留

	-	考虑$R^{(k)}$相较于$R^{(k-1)}$新增$r_{ij}=1$

		-	表示顶点i、j之间存在包含k的路径

		-	若k在路径中出现多次，则将删除回路，得到新路径

		-	则存在ik和kj之间路径满足中间顶点编号小于k，即在
			$R^{(k-1)}$中有$r_{ik}=1, r_{kj}=1$

####	算法

-	若元素$r_{ij}$在$R^{(k-1)}$中为1，则在$R^{(k)}$也是1

-	若元素$r_{ij}$在$R^{(k-1)}$中为0，当且仅当存在v使得
	$R^{(k-1)}$中$r_{iv}=1, r_{vj}=1$

```c
Warshall(A[1..n, 1..n])
	// 计算传递闭包的Warshall算法
	// 输入：A[1..n, 1..n]包含n个顶点的有向图的邻接矩阵
	// 输出：A的传递闭包
	R^0 = A
	for i = 1 to n do
		for i = 1 to n do
			for j = 1 to n do
				if R^(k-1)[i, j] == 1 or
					(R^(k-1)[i, k] == 0 and R^(k-1)[k, j] == 0)
					R^k[i, j] = 1
	return R^n
```

####	算法特点

-	算法效率
	-	时间效率$\in \Theta(n^3)$
		-	重新构造最内层循环，可以提高对某些输入的处理速度
		-	将矩阵行视为位串，使用或运算也可以加速
	-	空间效率取决于如何处理布尔矩阵

-	蛮力法：所有点分别作为起点作一次搜索，记录能够访问的顶点
	-	对有向图遍历多次
	-	使用邻接链表表示稀疏图，蛮力法渐进效率好于Warshall算法

##	有权路径

###	Prim算法

Prim算法：求解最小图最小生成树算法

-	每次添加距离当前树距离最近顶点进树
-	不断迭代构造最小生成树

####	算法

-	从图顶点集V中任选单顶点作为序列中初始子树

-	对图中顶点维护两个标记：树中最近顶点、相应距离

	-	一般使用优先队列维护
	-	对所有顶点维护：`NULL`、$\infty$标记和树不直接相连
	-	仅对和和树直接相连顶点维护：每次更新列表

-	以贪婪的方式扩张当前生成树，添加不在树中的最近顶点

-	更新顶点和树距离最近的顶点、相应距离
	
	-	因为树中只新添加一个顶点，考察与新添加顶点直接相连
		顶点即可

-	不断迭代直到所有点都在树中

```c
Prim(G)
	// 构造最小生成树Prim算法
	// 输入：加权连通图G=<V, E>
	// 输出：E_T, 组成G最小生成树的边集合
	V_T = {v_0}
		// 使用任意顶点初始化树顶点集合
	E_T = NULL
		// 初始化生成树边为空集

	for i = 1 to |V|
		if i connect V_T
			D_V[i] = i
			D_D[i] = e(0, i)
		else
			D_V[i] = NULL
			D_D[i] = \infty
		// 初始化节点和树最近节点列表、节点与树距离列表

	for i = 1 to |V|-1 do
		// 重复n-1次，知道树包含所有顶点
		edge = min(D_D)
			// 寻找距离树最近的点
		v = vertex(edge)

		V_T = V_T union {v}
		E_T = E_T union {edge}

		D_V[v] = NULL
		D_D[v] = \infty
		更新和v相连的顶点
			// 更新两个标记列表
	return E_T
```

####	正确性证明

用归纳法证明，Prim算法生成每棵子树$T_i$，都是某些最小生成树
一部分，则序列最后$T_{n-1}$就是最小生成树

-	$T_0$是单独顶点，显示是任意最小生成树一部分

-	若$T_{i-1}$是某最小生成树T一部分，设$e_i=(v, u)$为Prim
	算法将要添加的最小生成树边

-	若$T_i$不是任何最小生成树的一部分，则$e_i$不属于任何最小
	生成树

-	则将$e_i$添加至T中将构成回路，回路中包含边
	$(m, n), m \in T_{i-1},n \in T - T_{i-1}$

-	删除回边$(m, n)$，则得到另一棵生成树，且权重小于等于T，
	即最小生成树，与假设矛盾

####	算法特点

-	算法时间效率依赖实现优先队列、存储图数据结构
	-	图权重矩阵、优先队列无序数组$\in \Theta(|V|^2)$
	-	图邻接链表、优先队最小堆$\in O(|V|log|E|)$
		（书上说是$\in O(|E|log|V|)$）
	-	使用Fibonacci Heap实现优先队列能够改善最差效率

-	对树进行扩展时用到的边的集合表示算法生成树

-	穷举查找构造生成树，生成树数量呈指数增长，且构造生成树
	不容易


###	Kruskal算法

Kruskal算法：把最小生成树看作是具有$|V|-1$条边、且边权重最小
的无环子图，通过对子图不断扩展构造最小生成树

####	算法

-	按照权重非递减顺序对图中边排序

-	从空子图开始扫描有序列表，试图把列表中下条边加到当前子图
	中，如果添加边导致回路则跳过

-	不断添加边直到达到$|V|-1$

```c
Kruskal(G)
	// 构造最小生成树的Kruskal算法
	// 输入：G=<V, E>加权连通图
	// 输出：E_T，组成G的最小生成树边集
	reverse_sort([w(e_i)])
		// 按照边权非递减顺序对边集排序
	E_T = NULL
	ecounter = 0
	k = 0
	while ecounter < |V|-1 do
		k += 1
		if E_T union {e_k} 无回路
			// 需要使用高法效算法检查两个顶点是否位于同一棵树
			// 常用算法为并查算法（参见不相交子集）
			E_T = E_T union {e_k}
			ecounter += 1
	return  E_T
```

####	算法特点

-	Kruskal每次迭代都需要检查添加新边是否会导致回路，其实
	效率不一定比Prim算法高

-	Kruskal算法中间阶段会生成一系列无环子图（树）

	-	子图不总是联通的
	-	可以看作是对包含给定图所有顶点、部分边的森林所作的
		连续动作
	-	初始森林由|V|棵普通树构成，包含单独顶点
	-	最终森林为单棵树，包含图中所有顶点
	-	每次迭代从图的边有序列表中取出下条边，找到包含其端点
		的树，若不是同一棵树，则加入边生成一棵更大的树

-	算法效率
	-	如果检查顶点是否位于同一棵树算法高效，则算法运行时间
		取决于排序算法，时间效率$\in O(|E|log|E|)$

###	Dijkstra算法

Dijkstra算法：求解单起点最短路径算法

-	按照从给定起点到图中各顶点的距离，**顺序**求出离起始点
	最近的顶点、相应最短路径

-	第i次迭代前，算法已经确定了i-1条连接起点、离起点前i-1近
	顶点的最短路径

	-	这些构成了给定图的一棵子树$T_i$
	-	可以在同$T_i$顶点邻接的顶点中找到和起点最接近的顶点
		（边权非负）

-	算法只能应用于不含负权重的图

-	算法类似于Prim算法，两个评价标准不同
	-	Dijkstra算法是各条路径长度：有重复边，考虑整个路径
	-	Prim算法是评价各边总和：无重复边，只考虑一条边

####	算法

-	对顶点维护两个标记：起点到该顶点最短路径长度`d`、路径上
	前个顶点`pre_v`

	-	一般使用优先队列维护
	-	对所有顶点维护：$\infty$、`NULL`标记不在树中、不与树
		邻接顶点
	-	仅对生成树中顶点、邻接顶点维护：每次迭代更新列表

-	根据标记选择邻接顶点中和起始点距离`d`最小顶点，添加进树

-	更新顶点标记

	-	因为生成树只新添加一个顶点，只需要考虑与新添加顶点
		直接相连、未在树中顶点
	-	比较与起始点距离是否改变

-	不断迭代直至所有点均在树中


```c
Dijkstra(G, s)
	// 单起点最短路径Dijkstra算法
	// 输入：G=<V, E>非负权重加权连通图，顶点s起始点
	// 输出：对V中每个顶点，从s到v的最短路径长度d_v
	Initialize(Q)
		// 将顶点优先队列初始化为空
	for v in V
		d_v = \infty
		p_v = NULL
		Insert(Q, s, d_s)
			// 初始化有限队列中顶点优先级
	d_s = 0
	Decrease(Q, s, d_s)
		// 更新s优先级为d_s
	V_T = NULL

	for i = 0 to |V|-1 do
		u* = DeleteMin(Q)
			// 删除优先级最小元素
		V_T = V_T \union {u*}
		for v in V-V_T 中与u*邻接顶点 do
			if d_u* + w(u*, u) < d_u
				d_u = d_u* + w(u*, u)
				p_u = u*
				Decrease(Q, u, d_u)
```

####	算法特点

-	算法时间效率同Prim算法

### Floyd算法

Floyd算法：求解完全最短路径问题，有向、无向、加权图均适用
（边距离不为负，否则距离可以任意小）

-	构造n+1个距离矩阵$D^{(k)}, k=0,1,\cdots,n$

	-	$D^{(k)}$中元素$d_{ij}$表示顶点i、j之间由编号小于k的
		顶点作为中间顶点的距离

	-	$D^{(0)}$：初始权重矩阵

	-	$D^{(k)}, 0<i<n$：路径中顶点编号最大为`k`

	-	$D^{(n)}$：目标距离矩阵

	-	后继矩阵相对前趋，允许作为路径上顶点增加，各顶点间
		距离可能缩短

-	考虑$D^{(k)}$通过直接前趋$D^{(k-1)}$计算得到，其中距离
	（路径）分为两类

	-	$d^{(k)}_{ij} = d^{(k-1)}_{ij}$：不包含顶点k作为中间
		节点的路径
	
	-	$d^{(k)}_{ij} = d^{(k-1)}_{ik} + d^{(k-1)}_{kj} < d^{(k-1)}_{ij}$：
		包含顶点k作为中间节点的路径


####	算法

$$
d^{(k)}_{ij} = \min \{ d^{(k-1)}_{ik} + d^{(k-1)}_{kj},
	d^{(k-1)}_{ij}, d^{(k-1)}_{ij} \}
$$

```md
Floyd(W[1..n, 1..n])
	// 计算完全最短路径的Floyd算法
	// 输入：W不包含负距离的距离矩阵
	// 输出：包含最短距离的距离矩阵
	D^0 = W
	for k = 1 to n do
		for i = 1 to n do
			for j = 1 to n do
				D[i, j] = min(D[i, j], D[i, k] + D[k, j])
	return D
```

####	算法特点

-	算法效率
	-	时间效率同Warshall算法为立方级
	-	如上伪码的空间效率为平方级（没有创建n+1距离矩阵）

-	Floyd算法类似于Warshall算法

-	Floyd算法利用最优性原理，即最短路径中子路径也是最短

##	图子列表

###	Topological Sorting

拓扑排序：按照次序列出有向图的顶点，使得对图中每条边，其
起始顶点总在结束顶点之前

####	算法

-	在有向图中求出源（没有输出边的顶点），然后把删除其和所有
	从它出发的边
-	不断重复，直到不存在源，如果此时图中还有顶点，则图中存在
	环，无解
-	则删除节点顺序即为拓扑排序可行解

####	特点

-	减常数法

####	应用

-	判断庞大项目中相互关联任务不矛盾，然后才能合理安排，使得
	项目整体完成时间最短（需要CPM、PERT算法支持）


