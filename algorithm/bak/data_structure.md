#	数据结构

##	列表

###	Array数组

一维数组：n个**相同数据类型**的元素构成的序列，**连续**的
存储在计算机存储器中

-	通过下标访问这些元素
	-	大部分情况，下标为整数
	-	能用常量时间访问数组中的任何元素

-	字符串：数组实现的一种数据结构
	-	字符串常见操作不同于其他数组
		-	计算字符串长度
		-	按照字典序确定字符串排序时位置
		-	连接字符串构

###	Linked List链表

链表：0个或多个node构成的序列，每个节点包含两类信息：数据、
一个或多个pointer，指向链表中其他元素

-	从链表首节点开始，沿着指针链向遍历直到访问到特定元素
	-	访问单链表元素时间依赖该元素在链表中的位置

-	链表不需要事先分配任何存储空间

-	插入、删除效率高，只需要重连相关指针

####	Singly Linked List

单链表中，除了尾节点，每个节点都包含指向下一个节点的指针

####	Doubly Linked List

除了首尾节点，每个节点都包含指向前驱、后继的指针

####	Header

链表可以从特殊的Header表头节点开始，此节点可以包含一些关于
链表的信息

-	链表当前长度
-	除指向头元素的指针外，还有指向尾元素的指针

###	Stack栈

插入和删除都只能在端部（栈顶）进行的列表

-	添加、删除元素时按照`LIFO`的方式运转
	-	last in first out
	-	应用广泛，对实现递归操作必不可少

###	Queue队列

也是一种列表，只是dequeue在列表的front，enqueue在rear

-	按照`FIFO`方式运转
	-	first in last out
	-	应用广泛，包括图问题的算法

####	Priority Queue优先队列

-	用于从一个动态改变的候选集合中选择一个优先级高的元素
-	主要操作
	-	查找、删除最大元素
	-	插入元素
-	实现
	-	可以基于数组、有序数组实现
	-	基于heap的优先队列实现更好

##	图

$图G=<V, E>$由两个集合定义

-	有限集合V：元素为顶点*vertex*
-	有限集合E：元素为**一对顶点**，称为边*edge*

###	Undirected Graph

如果顶点对$(u, v)$等同于$(v, u)$（没有顺序）

-	则顶点u、v相互**adjcent**
-	其通过**undirected edge**$(u, v)$相连接
-	顶点u、v称为边$(u, v)$的**endpoint**
-	u、v和该边**incident**

如果所有图G中所有边都是无向的，称为**undirected graph**
无向图，也简称为图

####	分类

不考虑**loop**（顶点连接自身边），则含有|V|个顶点的无向图
包含边的数量|E|
$$ 0 \leq |E| \leq \frac {|V|(|V| - 1)} {2} $$

-	complete graph：任意两个顶点直接都有的边相连的图，可以
	使用$K_{|v|}$表示有|V|个顶点的完全图
-	dense graph：图中所缺的边数量相对较少
-	sparse：图中边相对顶点数量较少

对于稀疏图、稠密图可能会影响图的表示方法，影响设计、使用算法
的运行时间

###	Digraph

如果顶点对$(u, v)$不等同于$(v, u)$

-	边$(u, v)$的方向是从顶点u到顶点v
-	u称为tail，v称为head

如果图G中每条边都是有向的，称为**digraph**

###	图表示方法

####	Adjacency Matrix

n个顶点的邻接矩阵是一个n * n的bool矩阵

-	图中每个顶点使用一行和一列表示
-	i、j节点间有边，则矩阵第i行、j列元素为1，否则为0
-	无向图邻接矩阵一定是对称的，有向图邻接矩阵不一定

####	Adjacency List

图的邻接链表是邻接链表的集合

-	每个顶点用一个邻接链表表示
	-	邻接链表的header表示对应的顶点
	-	链表包含和这个顶点邻接的所有顶点

-	对应元素的邻接链表元素指出邻接矩阵中，对应行值为1的列

-	无向图一条边在邻接链表中对应两条链，有向图对应一条

####	说明

-	稀疏图：尽管链表指针会占用额外存储器，但是相对于邻接矩阵
	占用空间依然较少
-	稠密图：邻接矩阵占用空间较少

###	Weighted Graph

给边赋了值的图，值称为*weight*或*cost*

-	有大量的现实应用
-	邻接矩阵、邻接链表都可以方便的表示加权图
	-	邻接矩阵元素A[i, j]设置为有限值表示存在的边的权重，
		设置为$\infty$表示不存在边，此时矩阵也称
		**weighted matrix**或**cost matrix**
	-	邻接链表在节点中型跨同时包含节点名称和相应边权重

###	图结构

####	无向图

-	*path*：（无向）图G中始于u而止于v的邻接顶点序列，即为顶点u
	到顶点v的路径

-	*simple path*：路径上所有点互不相同

-	*cycle*：特殊的path
	-	起点、终点都是同一顶点
	-	长度大于0
	-	不包含同一条边两次

-	*acyclic*：不包含回路的图

####	有向图

-	*directed path*：有向图中顶点的一个序列，序列中每对连续
	顶点都被边连接，边方向为一个顶点指向下一个顶点

-	*directed cycle*：有向图中节点序列，起点、终点相同，每个
	节点和其直接前趋之间，都有一条从前趋指向后继的边

-	*directed acyclic graph*：DAG，有向无环图

-	*soruce*：源，没有输入边的顶点

####	公共

-	*length*：路径中代表顶点序列中的顶点数目减1，等于路径中
	包含的边数目

-	*connected*：对图中的每对顶点$(u, v)$，都有从u到v的路径

-	*connected component*：给定图的极大连通子图（没有可以添加
	的连通子图用于扩充）
	-	非连通图中包含的几个自我连通的部分

##	树

-	*free tree*；**连通**、**无回路图**，具有一些其他图
	不具有的重要特性
	-	边数总比顶点数少一：$|E|=|V|-1$
		-	这个是图为一棵树的必要条件，但不充分
		-	若图是连通的，则是充分条件

	-	任意两个顶点之间总是存在简单路径

-	*forest*：**无回路**但不一定连通的图
	-	其每个连通分量是一棵树

###	Rooted Tree

因为树中，任何两个节点间总存在简单路径，所以可以任选自由树
中某节点，作为有根树的根

-	有根树远远比自由树重要，所以也简称为树
	-	根一般放在树的顶层，第0层
	-	之后节点根据和根的距离放在相应层数

###	应用

-	常用于描述层次关系
	-	文件目录
	-	企业的组织结构
	-	字典的实现
	-	超大型的数据集合的高效存储
	-	数据编码

-	用于分析递归算法
	-	*state-space tree*：状态空间树，强调了两种算法设计
		技术：回溯、分支界限

###	结构

-	*ancestor*：从根到该顶点上的简单路径上的所有顶点
-	*proper ancestor*：除自身外的所有祖先顶点
-	*parent*：从根到顶点简单路径中，最后一条边的另一端节点
-	*parental*：至少有一个子女的顶点
-	*child*：
-	*sibling*：具有相同父母的顶点
-	*leaf*：没有子女的顶点
-	*descendent*：所有以该顶点为祖先的顶点
-	*proper descendent*：不包括顶点自身的子孙
-	*subtree*：顶点的所有子孙、连接子孙的边构成以该顶点为根的
	子树
-	*depth*：根到该顶点的简单路径的长度
-	*height*：根到叶节点的最长简单路径的长度

###	Ordered Tree

所有顶点的所有子女都是有序的有根树

####	Binary Tree

所有顶点子女个数不超过2个，每个子女不是父母的*left child*
就是*right child*

-	左（右）子树：二叉树的根是另一棵二叉树顶点的左（右）子女
	-	左右子树也是二叉树，所以二叉树可以递归定义
	-	因此，涉及二叉树的问题可以用递归算法解决

-	*binary search tree*：分配给每个父母顶点的数字都比其
	左子树中数字大，比右子树数字小
	-	*multiway search tree*：二叉查找树的推广，用于磁盘
		超大数据集的高效存取


-	二叉查找树的查找算法取决于二叉树的高度，对于n个顶点的
	二叉树，满足
	$$ \lfloor {log_{2}^{n}} \rfloor \leq h \leq n-1 $$

-	出于计算方便，在实现时二叉树常常由代表树顶点的一系列节点
	表示
	-	每个节点包含相关顶点的某些信息
	-	两个分别指向左右子女的指针

####	表示方法

-	简单的在父节点中加入与子女相同数量的指针
	-	这种表示方法在不同子女数目相差很大时不方便

-	First Child-next Silbling Representaion
	-	先子女后兄弟表示法
	-	每个节点只包含两个指针，左指针指向第一个子女，右指针
		指向节点的下一个兄弟
	-	节点的所有兄弟通过节点右指针被单独的链表连接
	-	这种表示法高效的将有序树改造成一棵二叉树，称为
		关联二叉树

##	集合与字典

###	Set

互不相同项的无序组合

-	要么直接列出元素的确切列表
-	要么指出集合的特殊属性，只有集合中元素才满足的特性

####	集合运算

-	检查元素是否属于集合
-	集合的并集
-	集合的交集

####	表示方法

-	*bit vector*：长度为n的位串，当前仅当全集$U$中第i个元素
	被包含在子集$S$中时，位向量第i个元素为1

	-	这样的任意子集可以用一个位串表示
	-	可以实现快速的标准集合运算
	-	但是以使用大量存储空间为代价的

-	线性列表
	-	只适合有限集合
	-	集合不能包含相同元素，列表可以
		-	可以引入*multiset*、*bag*绕过对唯一性的要求
		-	多重集和包是可重复项的无序组合
	-	集合是元素的组合，而列表是集合的有序组合
		-	用线性表表示集合时，维护线性表的有序排列没必要

###	Dictionary

能查找给定元素、增加新元素、删除元素的集合

-	需要处理的是动态内容的查找，因此需要在查找效率和其他两种
	操作中达到平衡
-	数组、散列法、平衡查找树都可以实现字典

##	Abstract Data Type

ADT：抽象数据类型包括：数据对象集合、对集合对象的操作
