#	图

	定义

$图G=<V, E>$由两个集合定义

-	有限集合V：元素为顶点*vertex*
-	有限集合E：元素为**一对顶点**，称为边*edge*

###	Undirected Graph

如果顶点对$(u, v)$等同于$(v, u)$（没有顺序）

-	则顶点u、v相互**adjcent**
-	其通过**undirected edge**$(u, v)$相连接
-	顶点u、v称为边$(u, v)$的**endpoint**
-	u、v和该边**incident**

如果所有图G中所有边都是无向的，称为**undirected graph**
无向图，也简称为图

####	边数量

-	complete graph：任意两个顶点直接都有的边相连的图
	-	使用$K_{|v|}$表示有|V|个顶点的完全图

-	dense graph：图中所缺的边数量相对较少

-	sparse：图中边相对顶点数量较少

####	特点

-	不考虑**loop**（顶点连接自身边），则含有|V|个顶点无向图
	包含边的数量|E|满足：
	$ 0 \leq |E| \leq \frac {|V|(|V| - 1)} {2} $

-	对于稀疏图、稠密图可能会影响图的表示方法，影响设计、使用
	算法的运行时间

###	Digraph

如果顶点对$(u, v)$不等同于$(v, u)$

-	边$(u, v)$的方向是从顶点u到顶点v
-	u称为tail，v称为head

如果图G中每条边都是有向的，称为**digraph**

##	Weighted Graph

给边赋了值的图，值称为*weight*或*cost*

-	有大量的现实应用

##	图表示方法

###	Adjacency Matrix

n个顶点的邻接矩阵是一个n * n的bool矩阵

-	图中每个顶点使用一行和一列表示
-	i、j节点间有边，则矩阵第i行、j列元素为1，否则为0
-	无向图邻接矩阵一定是对称的，有向图邻接矩阵不一定

###	Adjacency List

图的邻接链表是邻接链表的集合

-	每个顶点用一个邻接链表表示
	-	邻接链表的header表示对应的顶点
	-	链表包含和这个顶点邻接的所有顶点

-	对应元素的邻接链表元素指出邻接矩阵中，对应行值为1的列

-	无向图一条边在邻接链表中对应两条链，有向图对应一条

###	说明

-	稀疏图：尽管链表指针会占用额外存储器，但是相对于邻接矩阵
	占用空间依然较少

-	稠密图：邻接矩阵占用空间较少

-	邻接矩阵、邻接链表都可以方便的表示加权图
	-	邻接矩阵元素A[i, j]设置为有限值表示存在的边的权重，
		设置为$\infty$表示不存在边，此时矩阵也称
		**weighted matrix**或**cost matrix**
	-	邻接链表在节点中型跨同时包含节点名称和相应边权重

##	图结构、分类

###	无向图

-	*path*：（无向）图G中始于u而止于v的邻接顶点序列，即为顶点u
	到顶点v的路径

-	*simple path*：路径上所有点互不相同

-	*cycle*：特殊的path
	-	起点、终点都是同一顶点
	-	长度大于0
	-	不包含同一条边两次

-	*acyclic*：不包含回路的图

###	有向图

-	*directed path*：有向图中顶点的一个序列，序列中每对连续
	顶点都被边连接，边方向为一个顶点指向下一个顶点

-	*directed cycle*：有向图中节点序列，起点、终点相同，每个
	节点和其直接前趋之间，都有一条从前趋指向后继的边

-	*directed acyclic graph*：DAG，有向无环图

-	*soruce*：源，没有输入边的顶点

-	*transitive closure*：传递闭包，n阶布尔矩阵
	$T=\{t_{ij}\}$，若节点i到节点j直接存在有效（长度>0）有向
	路径，则$t_{ij}=0$

###	公共

-	*length*：路径中代表顶点序列中的顶点数目减1，等于路径中
	包含的边数目

-	*connected*：对图中的每对顶点$(u, v)$，都有从u到v的路径

-	*connected component*：给定图的极大连通子图（没有可以添加
	的连通子图用于扩充）
	-	非连通图中包含的几个自我连通的部分

-	顶点间距离：顶点之间最短路径长度

-	*spanning tree*：（连通图）生成树，包含图中所有顶点的
	连通无环子图（树）

-	*minimum spannin tree*：最小生成树，图的一棵权重最小的
	生成树（权重指所有边权重之和）

##	图算法

###	计算图中路径数量

用数学归纳法可以证明：图中顶点i到顶点j之间长度为k的不同路径
数量为$A^k[i, j]$，A为图的邻接矩阵

###	State-Space Graph

状态空间图：把问题化简为标准图问题

-	顶点：表示问题可能状态
-	边：表示状态之间的可能转换
-	原问题转换为求初始状态到目标状态顶点路径问题

###	Warshall算法

Warshall算法用于生成有向图传递闭包

-	构造n+1个n阶布尔矩阵$R^{(k)}, k=0,1,\cdots, n$

	-	$R^{(k)}_{ij}=1$：顶点i、j直接存在中间顶点**编号**
		不大于k的有效路径

	-	$R^{(0)}$：邻接矩阵，顶点直接连接

	-	$R^{(k)}, 0<k<n$：路径中间顶点编号最大为`k`

	-	$R^{(n)}$：传递闭包，允许所有类型路径

	-	后继矩阵相对前趋，允许作为路径上顶点增加，可能包含
		1数量更多

-	考虑$R^{(k)}$通过直接前趋$R^{(k-1)}$计算得到

	-	$R^{(k-1)}$中已有路径在$R^{(k)}$保留

	-	考虑$R^{(k)}$相较于$R^{(k-1)}$新增$r_{ij}=1$

		-	表示顶点i、j之间存在包含k的路径

		-	若k在路径中出现多次，则将删除回路，得到新路径

		-	则存在ik和kj之间路径满足中间顶点编号小于k，即在
			$R^{(k-1)}$中有$r_{ik}=1, r_{kj}=1$

####	算法

-	若元素$r_{ij}$在$R^{(k-1)}$中为1，则在$R^{(k)}$也是1

-	若元素$r_{ij}$在$R^{(k-1)}$中为0，当且仅当存在v使得
	$R^{(k-1)}$中$r_{iv}=1, r_{vj}=1$

```c
Warshall(A[1..n, 1..n])
	// 计算传递闭包的Warshall算法
	// 输入：A[1..n, 1..n]包含n个顶点的有向图的邻接矩阵
	// 输出：A的传递闭包
	R^0 = A
	for i = 1 to n do
		for i = 1 to n do
			for j = 1 to n do
				if R^(k-1)[i, j] == 1 or
					(R^(k-1)[i, k] == 0 and R^(k-1)[k, j] == 0)
					R^k[i, j] = 1
	return R^n
```


####	算法特点

-	算法效率
	-	时间效率$\in \Theta(n^3)$
		-	重新构造最内层循环，可以提高对某些输入的处理速度
		-	将矩阵行视为位串，使用或运算也可以加速
	-	空间效率取决于如何处理布尔矩阵
	

-	蛮力法：所有点分别作为起点作一次搜索，记录能够访问的顶点
	-	对有向图遍历多次
	-	使用邻接链表表示稀疏图，蛮力法渐进效率好于Warshall算法

### Floyd算法

Floyd算法用于求解完全最短路径问题，有向、无向、加权图均适用
（边距离不为负，否则距离可以任意小）

-	构造n+1个距离矩阵$D^{(k)}, k=0,1,\cdots,n$

	-	$D^{(k)}$中元素$d_{ij}$表示顶点i、j之间由编号小于k的
		顶点作为中间顶点的距离

	-	$D^{(0)}$：初始权重矩阵

	-	$D^{(k)}, 0<i<n$：路径中顶点编号最大为`k`

	-	$D^{(n)}$：目标距离矩阵

	-	后继矩阵相对前趋，允许作为路径上顶点增加，各顶点间
		距离可能缩短

-	考虑$D^{(k)}$通过直接前趋$D^{(k-1)}$计算得到，其中距离
	（路径）分为两类

	-	$d^{(k)}_{ij} = d^{(k-1)}_{ij}$：不包含顶点k作为中间
		节点的路径
	
	-	$d^{(k)}_{ij} = d^{(k-1)}_{ik} + d^{(k-1)}_{kj} < d^{(k-1)}_{ij}$：
		包含顶点k作为中间节点的路径


说明

-	Floyd算法类似于Warshall算法
-	Floyd算法利用最优性原理，即最短路径中子路径也是最短

####	算法

$$
d^{(k)}_{ij} = \min \{ d^{(k-1)}_{ik} + d^{(k-1)}_{kj},
	d^{(k-1)}_{ij}, d^{(k-1)}_{ij} \}
$$

```md
Floyd(W[1..n, 1..n])
	// 计算完全最短路径的Floyd算法
	// 输入：W不包含负距离的距离矩阵
	// 输出：包含最短距离的距离矩阵
	D^0 = W
	for k = 1 to n do
		for i = 1 to n do
			for j = 1 to n do
				D[i, j] = min(D[i, j], D[i, k] + D[k, j])
	return D
```

####	算法特点

-	算法效率
	-	时间效率同Warshall算法为立方级
	-	如上伪码的空间效率为平方级（没有创建n+1距离矩阵）

###	Prim算法

Prim算法：求解最小图最小生成树算法

-	每次添加距离当前树距离最近顶点进树
-	不断迭代构造最小生成树

####	算法

-	从图顶点集V中任选单顶点作为序列中初始子树

-	对图中顶点维护两个标记：树中最近顶点、相应距离

	-	一般使用优先队列维护
	-	对所有顶点维护：`NULL`、$\infty$标记和树不直接相连
	-	仅对和和树直接相连顶点维护：每次更新列表

-	以贪婪的方式扩张当前生成树，添加不在树中的最近顶点

-	更新顶点和树距离最近的顶点、相应距离
	
	-	因为树中只新添加一个顶点，考察与新添加顶点直接相连
		顶点即可

-	不断迭代直到所有点都在树中

```c
Prim(G)
	// 构造最小生成树Prim算法
	// 输入：加权连通图G=<V, E>
	// 输出：E_T, 组成G最小生成树的边集合
	V_T = {v_0}
		// 使用任意顶点初始化树顶点集合
	E_T = NULL
		// 初始化生成树边为空集

	for i = 1 to |V|
		if i connect V_T
			D_V[i] = i
			D_D[i] = e(0, i)
		else
			D_V[i] = NULL
			D_D[i] = \infty
		// 初始化节点和树最近节点列表、节点与树距离列表

	for i = 1 to |V|-1 do
		// 重复n-1次，知道树包含所有顶点
		edge = min(D_D)
			// 寻找距离树最近的点
		v = vertex(edge)

		V_T = V_T union {v}
		E_T = E_T union {edge}

		D_V[v] = NULL
		D_D[v] = \infty
		更新和v相连的顶点
			// 更新两个标记列表
	return E_T
```

####	正确性证明

用归纳法证明，Prim算法生成每棵子树$T_i$，都是某些最小生成树
一部分，则序列最后$T_{n-1}$就是最小生成树

-	$T_0$是单独顶点，显示是任意最小生成树一部分

-	若$T_{i-1}$是某最小生成树T一部分，设$e_i=(v, u)$为Prim
	算法将要添加的最小生成树边

-	若$T_i$不是任何最小生成树的一部分，则$e_i$不属于任何最小
	生成树

-	则将$e_i$添加至T中将构成回路，回路中包含边
	$(m, n), m \in T_{i-1},n \in T - T_{i-1}$

-	删除回边$(m, n)$，则得到另一棵生成树，且权重小于等于T，
	即最小生成树，与假设矛盾

####	算法特点

-	算法时间效率依赖实现优先队列、存储图数据结构
	-	图权重矩阵、优先队列无序数组$\in \Theta(|V|^2)$
	-	图邻接链表、优先队最小堆$\in O(|V|log|E|)$
		（书上说是$\in O(|E|log|V|)$）
	-	使用Fibonacci Heap实现优先队列能够改善最差效率

-	对树进行扩展时用到的边的集合表示算法生成树

-	穷举查找构造生成树，生成树数量呈指数增长，且构造生成树
	不容易

###	Kruskal算法

Kruskal算法：把最小生成树看作是具有$|V|-1$条边、且边权重最小
的无环子图，通过对子图不断扩展构造最小生成树

####	算法

-	按照权重非递减顺序对图中边排序

-	从空子图开始扫描有序列表，试图把列表中下条边加到当前子图
	中，如果添加边导致回路则跳过

-	不断添加边直到达到$|V|-1$

```c
Kruskal(G)
	// 构造最小生成树的Kruskal算法
	// 输入：G=<V, E>加权连通图
	// 输出：E_T，组成G的最小生成树边集
	reverse_sort([w(e_i)])
		// 按照边权非递减顺序对边集排序
	E_T = NULL
	ecounter = 0
	k = 0
	while ecounter < |V|-1 do
		k += 1
		if E_T union {e_k} 无回路
			// 需要使用高法效算法检查两个顶点是否位于同一棵树
			// 常用算法为并查算法（参见不相交子集）
			E_T = E_T union {e_k}
			ecounter += 1
	return  E_T
```

####	算法特点

-	Kruskal每次迭代都需要检查添加新边是否会导致回路，其实
	效率不一定比Prim算法高

-	Kruskal算法中间阶段会生成一系列无环子图（树）

	-	子图不总是联通的
	-	可以看作是对包含给定图所有顶点、部分边的森林所作的
		连续动作
	-	初始森林由|V|棵普通树构成，包含单独顶点
	-	最终森林为单棵树，包含图中所有顶点
	-	每次迭代从图的边有序列表中取出下条边，找到包含其端点
		的树，若不是同一棵树，则加入边生成一棵更大的树

-	算法效率
	-	如果检查顶点是否位于同一棵树算法高效，则算法运行时间
		取决于排序算法，时间效率$\in O(|E|log|E|)$

###	Dijkstra算法

Dijkstra算法：求解单起点最短路径算法

-	按照从给定起点到图中各顶点的距离，**顺序**求出离起始点
	最近的顶点、相应最短路径

-	第i次迭代前，算法已经确定了i-1条连接起点、离起点前i-1近
	顶点的最短路径

	-	这些构成了给定图的一棵子树$T_i$
	-	可以在同$T_i$顶点邻接的顶点中找到和起点最接近的顶点
		（边权非负）

-	算法只能应用于不含负权重的图

-	算法类似于Prim算法，两个评价标准不同
	-	Dijkstra算法是各条路径长度：有重复边，考虑整个路径
	-	Prim算法是评价各边总和：无重复边，只考虑一条边

####	算法

-	对顶点维护两个标记：起点到该顶点最短路径长度`d`、路径上
	前个顶点`pre_v`

	-	一般使用优先队列维护
	-	对所有顶点维护：$\infty$、`NULL`标记不在树中、不与树
		邻接顶点
	-	仅对生成树中顶点、邻接顶点维护：每次迭代更新列表

-	根据标记选择邻接顶点中和起始点距离`d`最小顶点，添加进树

-	更新顶点标记

	-	因为生成树只新添加一个顶点，只需要考虑与新添加顶点
		直接相连、未在树中顶点
	-	比较与起始点距离是否改变

-	不断迭代直至所有点均在树中


```c
Dijkstra(G, s)
	// 单起点最短路径Dijkstra算法
	// 输入：G=<V, E>非负权重加权连通图，顶点s起始点
	// 输出：对V中每个顶点，从s到v的最短路径长度d_v
	Initialize(Q)
		// 将顶点优先队列初始化为空
	for v in V
		d_v = \infty
		p_v = NULL
		Insert(Q, s, d_s)
			// 初始化有限队列中顶点优先级
	d_s = 0
	Decrease(Q, s, d_s)
		// 更新s优先级为d_s
	V_T = NULL

	for i = 0 to |V|-1 do
		u* = DeleteMin(Q)
			// 删除优先级最小元素
		V_T = V_T \union {u*}
		for v in V-V_T 中与u*邻接顶点 do
			if d_u* + w(u*, u) < d_u
				d_u = d_u* + w(u*, u)
				p_u = u*
				Decrease(Q, u, d_u)
```

####	算法特点

-	算法时间效率同Prim算法





