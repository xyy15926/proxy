#	介绍

##	基础

算法：一系列解决问题的**明确**指令，即对于符合一定规范的
输入，能够在有限时间内获得要求的输出

-	算法每步都必须**没有歧义**
-	必须确定算法所处理的**输入的值域**
-	同一算法可以用几种不同的形式描述
-	同一问题，可能存在几种不同的算法
-	同问题的不同算法，可能基于不同的解题思路，速度也会不同

###	算法正确性证明

-	对某些算法，正确性证明十分简单，对于另一些算法，可能十分
	复杂
-	证明正确性的一般方法是使用数学归纳法，因为算法的迭代过程
	本身就符合其所需的一系列步骤
-	根据特定输入追踪算法操作有意义，但是并不能证明算法的
	正确性，只需要一个算法不能正确处理的输入实例就足够了
-	对于近似算法，常常试图证明算法所产生的误差，不超出预定义
	的误差

###	算法分析

-	时间效率（time efficiency）：算法运行速度
-	空间效率（space efficiency）：算法需要多少额外的存储空间
-	简单性（simplicity）：取决于审视者的眼光
	-	简单的算法更容易理解、实现
	-	相应程序包含更少的bug
-	一般性（generality）
	-	所解决问题的一般性
	-	所接受输入的一般性
-	最优性（optimality）：与所解决问题的复杂度有关，与某算法
	效率无关
-	是否每个问题都能够用算法的方法来解决

##	常见问题

###	排序

-	按照升序重新排列给定列表中的数据项
-	为了让问题有意义，列表中的数据项应该能够排序（数据之间
	有一种全序关系）
-	键：在对记录排序时，需要选取的、作为排序的依据的一段信息

####	目的

-	排序可能是所求解的问题输出要求
-	排序能够更方便的求解和列表相关的问题
	-	查找问题
-	在其他领域的重要算法中，排序也被作为辅助步骤

####	发展

-	排序领域已经有很多不错的算法，只需要做$nlog_{x}^{n}$次
	比较就能完成长度为$n$的任意数组排序，且没有一种基于
	**键**值比较（相较于比较键值部分内容而言）的排序算法能
	在本质上操作其，

-	但是还是需要不断探寻新的算法虽然有些算法比其他的要好，
	但是没有任何算法在任何情况下是最优的
	-	有些算法比较简单，但速度较慢
	-	有些算法适合随机排列的输入，而有些适合基本有序的列表
	-	有些算法适合驻留在快速存储器中的列表，而有些适合存储
		在磁盘上的大型文件排序

####	评价

-	稳定性：排序算法保留等值元素在输入中的相对顺序
	-	一般来说，将相隔很远的键交换位置的算法虽然不稳定，
		但往往很快
-	在位性：排序算法不需要额外的存储空间，除极个别存储单元外

###	查找

在给定的集合、多重集（允许多个元素具有相同的值）中找给定值
（查找键，search key）

-	顺序搜索
-	折半查找：效率高但应用受限
-	将原集合用另一种形式表示以方便查找

没有任何一种查找算法在任何情况下都是最优的

-	有些算法速度快，但是需要较多存储空间
-	有些算法速度快，但是只适合有序数组

查找算法没有稳定性问题，但会发生其他问题，如果应用里的数据
相对于查找次数频繁变化，查找问题必须结合添加、删除一起考虑，
此时，必须仔细选择数据结构、算法，以便在各种操作的需求间达到
平衡

###	字符串处理

-	字符串：字母表中符号构成的序列
	-	文本串：字母、数字、特殊符号构成
	-	位串：0、1构成
	-	基因序列：可以使用字符串模型表示，其字母表只包括4个
		字母`{A, C, G, T}`

###	图处理

图：由一些称为顶点的点构成的集合，其中某些顶点由称为边的线段
相连

-	图的遍历算法：如何一次访问到网络中所有节点
-	最短路线算法：两个城市间最佳路线
-	有向图拓扑排序：课程、预备课程是否有矛盾
-	All-Pairs Shortest-Paths Problem：完全最短路径问题，找到
	每个顶点到其他所有顶点的距离

###	组合问题

寻找（明确地、隐含地）寻找一个组合对象，如：排列、组合、子集
，这些对象能满足特定条件并具有想要地属性，如：价值最大化、
成本最小化。

-	无论从理论角度、实践角度而言，组合问题是计算领域最难的
	问题
	-	随着问题规模增大，组合对象数量增长极快
	-	没有一种已知算法，能在可接受的时间范围内，精确的解决
		大部分组合问题，且被普遍认为不存在（未被证实）
	-	有些组合问题有高效求解算法，是幸运的例外

-	从更抽象的角度看，旅行商问题、图填色问题也是组合问题的
	特例

####	旅行商问题

Traveling Salesman Problem：找到给定n个城市之间的最短路径，
使得在回到出发城市之前，对每个城市只访问一次

-	有向图表述：顶点表示城市、边权表示城市之间距离，问题即可
	表述为求图的最短哈密顿回路

####	背包问题

给定n个重量为$w_1, w_2, \dots, w_n$价值为$v_1, v_2, ..., vn$
的物品和承重为$W$的背包，求能够装进背包的最有价值物品子集

####	分配问题

n个任务分配给n个人执行（一人一个），将任务j分配个人i的成本
为$C_ijd$，求最小成本分配方案

###	几何问题

处理类似于点、线、多面体这样的几何对象

-	最近对问题：给定平面上的n个点中，距离最近的两个点
-	凸包问题：能把给定集合中所有点都包含在里面的最小凸多边形

###	数值问题

涉及连续性数学问题，如：解方程、方程组，计算定积分，函数求值

-	大部分此类问题只能近似求解
-	此类问题大部分要操作实数，而实数在计算机内部只能近似表示
	，大量对近近似数的算术操作可能会叠加误差，输出错误结果

##	概念

###	NP-hard Problem

-	没有已知的效率可以用多项式表示的算法，且普遍认为这样的
	算法不存在
-	回溯法、分支界限法可以使得在优于指数级的效率下解决问题

###	限位器

在数据端点添加的**标记**数据

-	常用于在指示“指针”已经到达数据端点，将循环中的判断条件
	合并
	-	如在顺序查查找中在数组末尾添加查找键作为限位器，将
		判断数组越界、查找键比较合并

###	H有序

数组中任意间隔为h的元素都是有序的，对应的数组称为*h有序数组*

-	*h有序数组*：就是h个互相独立的有序数组**编织**在一起数组
-	*h有序数组*具有分离、局部有序的特点

###	BFS、DFS森林

BFS、DFS森林其实如果**仅有树向边**才是符合森林定义的

####	边类型

-	*tree edge*：树向边，父母连接的边
-	*back edge*：回边，连接“祖先”的边
	-	对有向图包括连接父母的边
	-	对无向图不存在连接父母边
-	*forward edge*：前向边，连接非后代的边
-	*cross edge*：其他边

####	边存在性

-	对于无向图DFS森林，只可能有回边
-	对于无向图BFS森林，只可能有交叉边
-	对于有向图DFS森林，可以都有



