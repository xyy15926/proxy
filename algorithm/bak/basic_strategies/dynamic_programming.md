#	动态规划

##	总述

*Dynamic Programming*用于解决由**交叠**子问题构成问题

-	导出问题实例的递推关系，其中包含较小、且交叠子问题解

	-	所以一般递推关系中往往会有*max*、*min*等遍历比较类型
		的运算，否则不会有交叠子问题

	-	事实上，一般动态规划就是用于求解**离散**最优化问题

	-	动态规划递推中包含一个重要思想**有序组合**
	
		-	考虑变量时，有序的**剔除**，一般而言是单向剔除，
			有些变量需要考虑双向，视为两个有约束条件的独立
			变量（最优二叉树）

		-	因为*最优解定理*，最优解由子问题最优解构成

		-	更直观的，因为只需要求解全集最优解，所以只需要
			考虑部分有序子集，类似于**矩阵可逆**只需要判断
			**顺序主子式**

-	写出递推式表示递推关系

	-	递推式中**因变量**往往就是最优解

	-	递推式中**自变量**则为问题中涉及的**列表**
	
		-	包括：明显离散列表、**因变量限制条件**

		-	列表意味组合元素**数量为1**，若数量有限则展开，
			否则其不是自变量

		-	各自变量是各自组合的笛卡尔积的关系

		-	n维列表，自变量数量+n（多维自身已经组合）

		-	两端都需要变化的变量视为两个独立、相互约束变量

	-	递推式限制条件包括：自变量限制条件


-	求出交叠子问题的解并记录在表中，避免重复求解

	-	否则就是普通递归，不能避免重复求解，或者说动态规划
		就是普通递归+子问题解记录

	-	对多维表，常常逐行、逐列填充（求解子问题），一般而言
		**先初始化者先填**
		-	先初始化行，则在初始化列过程中可以在循环中填充行
		-	先初始化列，则在初始化行过程中可以在循环中填充列

-	从表中得到较小问题解，并用于求解更大规模问题，直至原问题
	求解完成

	-	需要通过回溯得到问题最优解的构成

###	分类

-	自底向上（经典）：需要求解给定问题所有较小子问题

	-	计算用**所有**小问题解、填充表格

		-	自底向上没有对问题整体的全局把握，只能全部求解
		-	循环保证所需子问题已经求解完毕

	-	每个小问题只求解一次

-	自顶向下：利用记忆功能，试图避免不必要的子问题求解

	-	用自顶向下方式求解给定问题
	-	同时维护类似自底向上的动态规划所使用的表格
		-	初始化时所有单元格标记未被计算
		-	之后需要计算子问题解时，先检查相应单元格，然后
			决定是否需要递归调用求解、记录

###	Principle of Optimality

最优化法则：最优化问题的任一实例的最优解，都是由其子问题实例
的最优解构成

-	最优化法则在大多数情况下成立，但也存在少数例外：寻找图
	中最长简单路径

-	在动态规划算法中，可以方便检查最优化法则是否适用

>	动态规划的大多数应用都是求解最优化问题

##	典例

###	币值最大化

给定一排n个硬币，币值为正整数$c_i, i=1, 2, \cdots, n$（币值
不唯一），在原始位置不相邻的情况下，使得所选硬币总金额最大

####	算法

记最大可选金额为$F(n)$将可行规划分为两组

-	包含最后一枚硬币，最大金额为$c_n + F(n-2)$
-	不包含最后一枚硬币，最大金额为$F(n-1)$

则递推方程为

$$
F(n) = max\{c_n + F(n-2), F(n-1)\}, n>1 \\
F(0) = 0, F(1) = c_1
$$

```c
CoinRow(C[1..n])
	// 在所选硬币不相邻，从一排硬币中选择最大金额
	// 输入：C[1..n]保存n个硬币面值
	// 输出：可选硬币最大金额
	F[0] = 1
	F[1] = C[1]
	for i = 2 to n do
		F[i] = max(C[i] + F[i-2], F[i-1])
	return F[n]
```

####	算法特点

-	时间效率$\in \Theta(n)$
-	空间效率$\in \Theta(n)$

###	找零问题

需找零金额为n，最少需要多少面值为$d_1 < d_2 < \cdots < d_n$
的硬币，考虑$d_1 = 1$的一般情况

####	算法

记$F(n)$为总金额为n的数量最少的硬币数目，定义$F(0)=0$


-	得到n的途径只能是在$n-d_j$上加入面值为$d_j$的硬币，其中
	$j=1, 2, \cdots, m$，且$n \geqslant d_j$

-	考虑所有满足条件$d_j$，选择使得且$F(n - d_j)$最小者

则递推式有

$$
F(n) =
\left \{ \begjn{array}{c}
	\mjn_{j: n \geqslant d_j} \{F(n - d_j)\} + 1 & n > 0\\
	0 & n = 0
\end{array} \rjght.
$$

```c
ChangeMaking(D[1..m], n)
	// 动态规划法求解找零问题，d_1 = 1
	// 输入：正整数n，币值数组D[1..m]
	// 输出：总金额为n的最少硬币数目
	F[0] = 0
	for i = 1 to n do
		tmp = \infty
		j = 1
		while j <= m and i >= D[j] do
			tmp = min(F[i-D[j], tmp)
			j += 1
		F[i] = tmp + 1
	return F[n]
```

###	硬币收集问题

在n * m格木板中存放有硬币，每格硬币最多一个，寻找左上角(1,1)
到右下角(n, m)路径，使得能够收集尽可能多硬币，每次只能向下、
向右移动

####	算法

记$F(i, j)$为截止到第i行、第j列单元格$(i, j)$能够收集到最大
硬币数

-	单元格$(i, j)$只能经由$(i-1, j)$、$(i, j-1)$达到
	-	初值1：假定$F(0, j)=0, F(i, 0)=0$
	-	初值2；递推求解$F[1, j], F[i, 1]$

则递推方程为

$$
F(i, j) =
\left \{ \begin{array}{c}
	max \{F(i-1 ,j), F(i, j-1)\} + c_{ij} & 1 <= i <= n, i <= j <= m \\
	0 & i = 0 \or j = 0
\end{array} \right.
$$

```c
CoinCollection(C[1..n, 1..m])
	// 动态规划算法求解硬币收集问题
	// 输出：矩阵C[1..n, 1..m]表示单元格是否有硬币
	// 输出：在单元格[n, m]能够收集到的最大硬币数
	F[1, 1] = C[1, 1]
	for j = 2 to m do
		F[1, j] = F[1, j-1] + C[1, j]
		// 初始化首行
	for i = 2 to n do
		F[i, 1] = F[i-1, 1] + C[i, 1]
		for j = 2 to n do
			// 先填列
			F[i, j] = max(F[i-1, j], F[i, j-1]) + C[i, j]
	return F[n, m]
```

####	算法特点

-	算法效率
	-	计算每个单元格$F[i, j]$花费常量时间，所以算法时间
		效率$\in \Theta(nm)$
	-	算法空间效率$\in Theta(nm)$

##	0-1背包问题

###	经典自底向上

依次求解所有子问题、记录

####	算法

设$F(i, j)$为由前i个物品、承重量为j的背包得到最优解

-	不包括第i个物品的子集中，最优子集价值为$F(i-1, j)$

-	包括第i个物品的子集中，最优子集是由该物品和前i-1个物品
	中能够放进承重量为$j-w_i$的背包的最优子集组成，总价值为
	$v_i + F(i-1, j-w_i)$

则递推式为

$$
F(i, j) =
\left \{ \begin{array}{c}
	max\{F(i-1, j), v_i + F(i-1, j-w_i)} & j-w_i \geqslant 0 \\
	F(i-1, j) & j-w_i \leqslant 0 \\
	0 & i=0 or j=0 (i, j \geqslant 0)
\end{array} \right.
$$

```c
Knapsack(Ws[1..n], Vs[1..n], W)
	// 动态规划求解背包问题
	// 输入：Ws[1..n]物品重量、Vs[1..n]物品价值，W背包承重
	// 输出：背包能够装载的最大价值
	for i = 0 to n do
		F[i, 0] = 0
	for j = 0 to W do
		F[0, j] = 0
		for i = 1 to n do
			if j >= Ws[i]:
				F[i, j] = max(F[i-1, j], Vs[i] + F[i-1, j-Ws[i])
				// 这里用于比较的F值，在之前的循环中已经确定
			else
				F[i, j] = F[i-1, j]
	return F[n, W]
```

####	算法特点

-	算法效率
	-	时间效率$\in \Theta(nW)$
	-	空间效率$\in \Theta(nW)$
	-	回溯求最优解组成效率$\in O(n)$

###	自顶向下

####	算法

```c
MFKnapsack(i, j)
	// 背包问题的记忆功能方法
	// 输入：i考虑的物品数量，j背包承重
	// 输出：前i个物品的最优可行子集
	// Ws[1..n]、Vs[1..n]、F[0..n, 0..W]作为全局变量
	for i = 0 to n do
		F[i, 0] = 0
	for j = 0 to W do
		F[0, j] = 0
	if F[i, j] < 0
		if j < Ws[i]
			value = MFKnapsack(i-1, j)
		else
			value = max(MFKnapsack(i-1, j),
				Vs[i] + MFKnapsack(i-1, j - Ws[i]))
		F[i, j] = value
	return F[i, j]
```

####	算法特点

-	算法效率
	-	相较于经典自底向上算法，时间效率提升常数因子，但是
		效率仍然$\in \Theta(nW)$
	-	相较于自底向上算法空间优化版版本而言，空间效率较低
















