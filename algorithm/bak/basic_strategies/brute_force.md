#	蛮力法

##	简介

Brute Force：简单直接解决问题的方法，常常直接基于问题的描述
和所涉及的概念定义

-	蛮力法可以解决各种问题，实际上可能是唯一几乎可以解决所有
	问题的方法
-	对某些重要问题，蛮力法可以产生合理算法，具备实用价值，
	且不必限制实例规模
-	如果解决问题实例不多，蛮力法速度可接受，设计高效算法可能
	不值得
-	蛮力法可以用于研究、教学目的，如：衡量同样问题其他更高效
	算法

##	排序

###	选择排序

####	算法

```c
SelectionSort(A[0..n-1])
	// 选择排序排序数组
	// 输入：可排序数组A[0..n-1]
	// 输出：升序排序数组A[0..n-1]
	for i = 0 to n-1 do
		min = i
		for j = i to n-1 do
			if A[j] < A[min]
				min = j
		swap A[i] and A[min]
```

-	扫描整个列表找到最小元素，然后和首个元素交换，将其放在
	最终位置上
-	从第2个元素开始寻找之后最小元素，和第2个元素交换，将其
	放在最终位置上
-	重复n-1次，列表有序

####	特点

-	对任何输入，选择排序键值比较都是$Theta(n^2)$
-	键交换次数仅为$Theta(n)$
	-	选择排序此特性优于许多其他排序算法

###	冒泡排序

####	算法

```c
BubbleSort(A[0..n-1]):
	// 冒泡排序排序数组
	// 输入：可排序数组A[0..n-1]
	// 输出：升序排序数组A[0..n-1]
	for i = 0 to n-2 do
		for j = 0 to n-2-i do
			if A[j+i] < A[j]
				swap A[j] and A[j+1]
```

-	比较表中相邻元素，如果逆序就交换位置
-	重复多次则最大元素被“沉到”列表最后位置
-	第2轮比较将第2大元素“沉到”其最终位置
-	重复比较n-1轮，列表有序

####	特点

-	对任何输入，冒泡排序键值比较都是$Theta(n^2)$
-	其交换次数取决于特定输入
	-	最坏情况是遇到降序排列数组，此时键交换次数同比较次数
-	冒泡排序看起来就像是选择排序的**一直交换+最大优先**版本

####	改进

-	如果对列表比较一轮后没有交换任何元素，说明列表有序，可以
	结束算法

##	查找

###	顺序查找

####	算法

-	将给定列表中连续元素和给定元素查找键进行比较
	-	直到遇到匹配元素：成功查找
	-	匹配之前遍历完整个列表：失败查找

```c
SequentialSearch(A[0..n-1], K)
	// 顺序查找，使用**查找键作限位器**
	// 输入：n个元素数组A、查找键K
	// 输出：第一个值为K的元素位置，查找失败返回-1
	A[n] = K
	i = 0
	while A[i] != K do
		i = i + 1
	if i < n
		return i
	else
		return -1
```

####	改进

-	将查找键添加找列表末尾，查找一定会成功，循环时将不必每次
	检查是否到列表末尾
-	如果给定数组有序：遇到等于（查找成功）、大于（查找失败）
	查找键元素，算法即可停止

##	字符串处理

###	蛮力字符串匹配

####	算法

-	将pattern对齐文本前m个字符，从左向右匹配相应字符
	-	m个字符全部匹配，匹配成功，算法停止
	-	遇到不匹配字符则
-	模式右移1位，然后从模式首个字符开始重复以上匹配
-	在n-m位置无法匹配成功，则无足够匹配字符，算法停止

```c
BruteForceStringMatch(T[0..n-1], P[0..m-1])
	// 蛮力字符串匹配
	// 输入：文本T：n个字符的字符数组
	//       模式：m个字符的字符数组
	// 输出：查找成功返回文本第一个匹配子串中第一个字符位置
	for i = 0 to m-m do
		j = 0
		while j < m and P[j] = T[i+j] do
			j = j + 1
			if j = m
				return i
	return -1
```

####	特点

-	最坏情况下，算法比较次数属于$O(nm)$
	-	即在移动模式之前，算法需要做足m次比较
	-	但是一般在自然语言中，算法平均效率比最差好得多
	-	在随机文本中，有线性效率

##	几何问题

###	最近对

####	算法

```c
BruteForceClosestPoints(p)
	// 蛮力算法求平面中距离最近的点
	// 输入：n个点的列表p；p_i = (x_i, y_i)
	// 输出：两个最近点的距离
	d = \infty
	for i = 1 to n -1 do
		for j = i+1 to n do
			d = min(d, sqrt((x_i - x_j)^2 + (y_i - y_j)^2))
	return d
```

####	改进

-	忽略平方根函数，只比较平方

####	应用

-	聚类分析

###	凸包问题

####	概念

#####	Convex Hull

凸包：包含点集S的**最小**凸集合

-	离散点集：包含所有点的**最小凸多边形**
-	最小：凸包一定是所有包含S的凸集合的子集
-	凸包能方便地提供目标形状或给定数据集地一个近似

#####	Extreme Point

极点：对于任何以集合中点为端点的线段，不是线段中点的点

-	极点有一些特性是凸集中其他点不具备的性质
	-	单纯形法：如果存在极值，则一定可以在极点处取到
	-	找到极点、极点排序方向即可解决凸包问题

-	举例
	-	三角形中3个顶点
	-	圆周上所有点

####	算法

-	对于n个点集中两个点$p_i$、$p_j$，当且仅当集合中其他点
	都位于穿过这两点的直线**同侧**时，其连线是该集合凸包边界
	一部分
-	检验每对点，满足条件的点即构成凸包边界

####	特点

-	算法时间效率为$O(n^3)$

####	应用

-	计算机动画中使用凸包替换物体本身，加快碰撞检测速度
-	车辆路径规划
-	地理信息系统中根据卫星图像计算accessibility map
-	数理统计中用于进行异常值检测
-	计算点集直径的高效算法中需要用到

##	组合问题

对组合问题来说，exhaustive search是简单的蛮力方法

-	生成问题域每个元素
-	选出满足问题约束的元素
-	最后寻找期望元素

###	背包问题

####	算法

-	考虑所有n个物品的子集
-	计算每个子集重量，找出可行子集
-	找到可行子集中价值最大子集

###	旅行商问题

####	算法

-	生成n-1个中间城市的组合得到所有旅行线路
-	计算线路长度，求得最短路径

####	特点

-	算法排序次数为$(n-1)!/2$

####	改进

-	线路成对出现，只是方向相反，可考虑任意两个相邻顶点，只
	考虑包含其某个排序的线路

###	分配问题

####	算法

-	生成整数n的全部排列
-	根据成本矩阵计算每个分配方案总成本
-	选择和最小的方案

####	特点

-	算法排列次数为$n!$

##	图处理

###	Depth-First Search

深度优先查找（DFS）

####	算法

-	从**任意顶点**开始访问图顶点，然后标记为已访问
-	每次迭代时，紧接着处理与当前顶点**邻接的未访问顶点**，
	直到遇到终点，该顶点所有邻接顶点均已访问过
-	在终点上，算法**沿着来路**后退一条边，继续从那里访问未
	访问顶点
-	后退到**起始点**，且起始点也是终点时，算法停止，这样
	起始点所在的连通分量的所有顶点均已访问过
-	若存在未访问顶点，则必须从其中任一顶点开始重复上述

```c
count = 0
	// 全局变量：访问次序（次数）
DFS(G)
	// 对给定图的深度优先查找遍历
	// 输入：图G=<V, E>
	// 输出：图G顶点按照DFS遍历第一次访问到的先后次序，
	//       未访问到标记未0
	for each vertex v in V do
		if v is marked with 0
			dfs(v)
dfs(v)
	// 递归访问所有和v相连接的未访问顶点，赋予count值
	count = count+1
	mark v with count
	for each vertex w in V adjecnt to v do
		if w is marked with 0
			dfs(w)
```

####	特点

-	算法效率非常高效，消耗时间和表示图的数据结构规模成正比
	-	邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$
	-	邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$

-	可以方便地用栈跟踪深度优先查找
	-	首次访问顶点，将顶点入栈
	-	当顶点成为终点时，将其出栈
	-	运行时就是实际上就是栈，所以深度优先可以直接利用递归
		实现

-	*Depth-First Search Foreat*
	-	遍历的初始顶点可以作为森林中树的根
	-	遇到新未访问的顶点，将其附加为**直接前趋**子女
	-	*tree edge*：连接深度优先查找森林中父母、子女顶点的
		边，其集合构成森林
	-	*back edge*：指向已访问顶点的边，且顶点不是其直接
		**前趋**，其在深度优先查找森林中将顶点与其非父母祖先
		相连接

-	DFS产生两种节点排列顺序性质不同，有不同应用
	-	入栈（首次访问顶点）次序
	-	出栈（顶点成为终点）次序

####	应用

-	检查图连通性：算法第一次停止后，是否所有顶点已经访问
-	检查图无环性：DFS是否包含回边
-	拓扑排序：见*键值法*
	-	DFS节点出栈逆序就是拓扑排序的一个解（图中无回边，
		即为有向无环图）
	-	DAG中顶点v出栈前，不存在顶点u拥有到v的边，否则存在
		回边，图不是DAG

###	Broad-First Search

广度优先查找（BFS）

####	算法

-	首先访问所有和初始顶点邻接的顶点
-	然后是离它两条边的所有未访问顶点
-	以此类推，直到所有与初始顶点在同一连通分类顶点均已访问
-	若存在未访问顶点，从图其他连通分量任意顶点开始

```c
count = 0
	// 全局变量：访问次序（次数）
BFS(G)
	// 给定图广度优先查找变量
	// 输入：图G=<V, E>
	// 输出：图G的顶点按照被BFS遍历第一次访问到次序，
	//       未访问顶点标记未0
	for each vertax v in V do
		if v is marked with 0
			bfs(v)
bfs(v)
	// 访问所有和v相连接的顶点，赋count值
	count = count+1
	whilte queue is not empty do
		for each vertex w in V adjcent to the front vertex do
			if w is marked with 0
				count = count+1
				mark w with count
				add w to the queue
		remove the front vertex from the queue
```

####	特点

-	算法效率同DFS
	-	邻接矩阵：遍历时间效率$\in \Theta(|V|^2)$
	-	邻接链表：遍历时间效率$\in \Theta(|V|+|E|)$

-	使用队列可以方便地跟踪广度优先查找操作
	-	从遍历初始顶点开始，标记、入队
	-	每次迭代时，算法查找所有和队头顶点邻接未访问，标记
		、入队、将队头顶点出队

-	*Breadth-First Search Forest*
	-	遍历的初始顶点可以作为森林中树的根
	-	遇到新未访问的顶点，将其附加为**直接前趋**子女
	-	*tree edge*：连接BFS森林中父母、子女顶点的边，其集合
		构成森林
	-	*cross edge*：指向已访问顶点的边，且顶点不是其直接
		**前趋**，其在BFS树连接同层、相邻层兄弟节点

-	BFS只产生顶点的一种排序，因为队列时FIFO结构，顶点入队、
	出队次序相同

####	应用

-	和DFS一样可以检查图的连通性、无环性，但是无法用于比较
	复杂的应用
-	求给定两个顶点间最短路径：从一顶点开始BFS遍历，访问到
	另一节点结束（难以证明？）




