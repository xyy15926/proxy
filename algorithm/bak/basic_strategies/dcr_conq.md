#	减治法

##	简介

*Decrease and Conquer*技术利用问题给定实的解和同样问题较小
实例解之间某种关系，可以自底向上、自底向上的运用该关系

-	自顶向下会自然导致递归算法，但是还是非递归实现较好
-	自底向上往往是迭代实现的，从求解问题较小实例开始

减治法有3种主要变化形式

###	Decrease-by-Constant

减常量：每次算法迭代总是从实例中减去相同常量

-	*新问题规模 = 原问题规模 - constant*
-	一般来说这个常量为1
-	例子
	-	自顶向下递归计算指数
	-	利用指数定义自底向上计算指数

###	Decrease-by-A-Contant-Factor

减去常量因子：在算法迭代过程中总是减去相同的常数因子

-	*新问题规模 = 原问题规模 / constant-factor*
-	常数因子一般为2
-	例子
	-	递归的计算$a^{n/2}$计算指数

###	Variable-Sire-Decrease

减可变规模：算法每次迭代时，规模减小模式不同

-	例子
	-	计算最大公约数的欧几里得算法
		$$gcd(m, n) = gcd(n, m mod n)$$

#	减常量法

##	排序

###	Insertion Sort

插入排序：利用减一技术对数组$A[0..n-1]$进行排序


####	算法

-	假设对较小数组$A[0..n-2]$排序已经解决
-	从左至右扫描有序子数组，直到遇到首个小于等于$A[n-1]$元素
	，插入其后

```c
InsertionSort(A[0..n-1])
	// 用插入排序对给定数组排序
	// 输入：n个可排序元素构成数组
	// 输出：非降序排序数组
	for i = 1 to n-1 do
		v = A[i]
		j = i - 1
		while j >= 0 and A[j] > v do
			A[j+1] = A[j]
			j = j - 1
		A[j+1] = v
		// 上一步比较元素已经赋值给其后，所以应该覆盖其值
```


####	特点

-	插入排序是自顶向下基于递归思想，但是自底向上使用迭代实现
	算法效率更高
-	算法基本操作是键值比较，比较次数依赖于特定输入
	-	最坏情况（递减数组）下，每轮比较次数都到达最大，此时
		键值比较次数$\in \Theta(n^2)$
	-	最优情况（递增数组）下，每轮比较次数仅为1，此时键值
		比较次数$\in \Theta(n)$
	-	许多应用中都会遇到基本有序的文件，插入排序能保证良好
		性能
	-	对随机序列，比较次数$\in Theta(n^2)$

###	Shell Sort

插入排序的扩展，Shell排序基于*h有序*

####	算法

-	使用插入排序对*h子数组*独立排序，每次交换相隔h的元素
-	h逐渐减小到1，shell排序退化（最后一轮）为插入排序


```c
ShellSort(A[0..n-1])
	// 用插入排序对给定数组排序
	// 输入：n个可排序元素构成数组
	// 输出：非降序排序数组
	h = 1
	while h < n/3
		h = h*3 + 1
		// 获取初始h值，之后每轮h变为1/3
	while h >= 1:
		for i = h to n-1:
			v = A[i]
			j = i - h
			while j >= 0 and A[j] > v do
				A[j] = A[j-h]
				j = j - h
			A[j+h] = v
		h = h/3
```

####	特点

-	Shell排序全衡量子数组规模、有序性，更加高效
-	h递增序列
	-	子数组部分有序程度取决于h递增序列的选择
	-	不同的h递增序列对算法效率有常数倍的变动，但是在实际
		应用中效果不明显
-	Shell排序是唯一无法准确描述其对于乱序数组性能特征的排序
	方法

##	图处理

###	Topological Sorting

拓扑排序：按照次序列出有向图的顶点，使得对图中每条边，其
起始顶点总在结束顶点之前

####	算法

-	在有向图中求出源（没有输出边的顶点），然后把删除其和所有
	从它出发的边
-	不断重复，直到不存在源，如果此时图中还有顶点，则图中存在
	环，无解
-	则删除节点顺序即为拓扑排序可行解

####	应用

-	判断庞大项目中相互关联任务不矛盾，然后才能合理安排，使得
	项目整体完成时间最短（需要CPM、PERT算法支持）

##	组合

###	生成排列

生成集合排列问题可以抽象为生成${1,\dots,n}$所有$n!$个排列的
问题

-	假设$(n-1)!$个排列已经生成
-	则可以把n插入n-1个元素中可能的n个位置中去，得到较大规模
	问题的解

####	算法

#####	最小变化

-	在元素上使用小箭头标记其方向：$\overleftarrow_1\overleftarrow_2\overleftarrow_3\overleftarrow_4$
-	如果元素k的箭头指向相邻的较小元素，称在此排列中是移动的

```c
JohnsonTrotter(n)
	// 生成排列
	// 输入：正整数n
	// 输出：{1..n}所有排列列表
	将第一个排列初始化
	while 存在一个移动元素 do
		求最大的移动元素k
		把k和其箭头指向的相邻元素互换
		调转所有大于k的元素的方向
		将新排列添加到列表中
```

#####	字典序

-	找到序列中最长递减后缀$a_{i+1}>a_{i+2}>\dots>a_{n}$
-	将$a_i$同序列中大于其的最小元素交换
-	将新后缀颠倒，使其变为递增序列，加入列表中

```c
LexicographicPermute(n):
	// 以字典序产生排列
	// 输入：正整数n
	// 输出：字典序下，所有排列列表
	初始化第一个排列为12...n
	while 最后一个排列有两成连续升序元素 do
		找出使得a_i < a_{i+1}的最大的i
			// 即找到最长递减后缀
		找到使得a_i < a_j的最大索引
			// 即在后缀中大于其的最小元素索引
		交换a_i和a_j
		将a_{i+1}和a_{n}的元素反序
		将新排列添加至列表中
```

####	特点

-	JsonTrotter是生成排列最有效算法之一，其运行时间和排列
	数量成正比，即$\in \Theta(n!)$

###	生成子集

集合$A[a_1, \dots, a_n}$的所有子集可以分为两组

-	包含$a_n$：${a_1, \dots, a_n}$的所有子集
-	不包含$a_n$的子集：把$a_n$添加进${a_1, \dots, a_n}$子集
	获得

同样的可以把集合抽象为位串，每个位串表示一个子集

####	算法

#####	字典序

生成字典序（位串字典序）很简单

-	将正序{1..n}转换为二进制位串即可

#####	挤压序

Squashed Order：所有包含$a_j$子集必须紧排在所有包含
$a_1, \dots, a_{j-1}$的子集之后

-	将倒序{n..1}转换为二进制位串即可

#####	最小变化

每个子集和其直接前趋之间，要么增加一个元素，要么减少一个元素

-	即每个位串和直接前趋之间仅仅相差一位

```c
BRGC(n)
	// 递归生成二进制反射格雷码
	// 输入：正整数n
	// 输出：所有长度为n的格雷码位串列表
	if n == 1
		表L包含位串0、位串1
	else
		调用BRGC(n-1)生成长度为n-1的位串列表L1
		表L1倒序后复制给表L2
		把0加到表L1每个位串前
		表1加到表L2每个位串前
		把表L2添加到表L1后得到表L
	return L
```

#	减常因子法

##	查找

###	折半查找

####	算法

对**有序数组**，比较查找K和数组中间元素A[m]完成查找工作

-	如果：A[m] == K，查找结束
-	若：K < A[m]，对数组前半部分执行该操作
-	若：K > A[m}，对数组后半部分执行该操作

```c
BinarySearch(A[0..n-1], K)
	// **非递归**折半查找
	// 输入：升序数组A[0..n-1]、查找键K
	// 输出：数组元素下标K，若存在；否则返回-1
	l = 0
	r = n - 1
	while l <= r do
		m = ceiling((l + r) / 2)
		if K = A[m]
			return m
		elif K < A[m]
			r = m - 1
		else l = m + 1
	return -1
```

####	特点

-	折半查找时间效率
	-	最坏情况下：$\in \Theta(log n)$
	-	平均情况下仅比最差稍好
-	就**依赖键值比较**的查找算法而言，折半查找已经是最优算法
	，但是插值算法、散列法等具有更优平均效率

##	数值问题

###	俄式乘法

两个正整数n、m相乘的非主流算法

####	算法

-	反复应用以下公式，简化每步的计算
	$$
	n为奇数：n * m = \frac n 2 * 2m + m \\
	n为偶数：n * m = \frac n 2 * 2m
	$$
-	以$1 * m$作为算法终止条件

####	特点

-	n为奇数步骤中的m，可以最后累加即可
-	算法中只有折半、加倍、相加操作
	-	手动计算非常简便
	-	计算机硬件对折半、加倍只需要移位就可

##	Uncharted

###	约瑟夫斯问题

>	n个人围成圈编号{1..n}，从1号开始每次消去第2个人直到最后
	一个人，计算最后人编号$J(n)$。

对整个圈处理一遍后即得到规模为n/2子问题。

####	算法

对n为奇数、偶数分别考虑

-	$n=2k$为偶数时，$J(2k)=2J(k)-1$
-	$n=2k+1$为奇数时，$J(2k+1)=2J(k)+1$

####	特点

-	可以将两个递推式合并
-	这个问题最简单的解法：对n本身做一次**向左循环位移**
	-	？？？#todo

#	减可变规模

##	排序

###	顺序统计量

寻找列表中第k小的元素

-	采用partitioning的思路，将给定列表根据某个值进行划分

####	算法

#####	Lomuto划分

-	考虑子数组A[l..r]分为三段，按顺序排在中轴p之后
	-	小于p的元素，最后元素索引记为s
	-	大于等于p的元素，最后元素索引记为i
	-	未同p比较过元素
-	从左至右扫描A[l..r]，比较其中元素和p大小
	-	若A[i]>=p，扩大大于等于p元素段
	-	若A[i]<p，需要扩大小于等于p元素段

```c
LomutoPartition(A[l..r])
	// 采用Lomuto算法，用首个元素作中轴划分数组
	// 输入：可排序数组A[0..n-1]的子数组A[l..r]
	// 输出：A[l..r]的划分、中轴位置
	p = A[l]
	s = l
	for i = l+1 to r
		if A[i] < p
			s = s+1
			swap(A[s], A[i])
	swap(A[l], A[s])
	return s
```

#####	QuickSelect

-	对划分完后出数组，s为分割位置
	-	若：s == k-1，则中轴p就是第k小元素
	-	若：s < k-1，则应该是数组右边划分第k-s小元素
	-	若：s > k-1，则应该是数组左边划分第k小元素
-	这样就得到规模更小的问题实例

```c
QuickSelect(A[l..r], k)
	// 用基于划分递归算法解决选择问题
	// 输入：可排序数组A[0..n-1]的子数组A[l..r]、整数k
	// 输出：A[l..r]中第k小元素
	s = LomutoPartition(A[l..r])
	if s = l+k-1
		return A[s]
	elif s > l+k-1
		QuickSelect(A[l..s-1], k)
	else
		QuickSelect(A[s+1..r], l+k-1-s)
```

####	特点

-	快速选择效率
	-	最好情况下只需要划分一次即找到，需要比较$n-1$次
	-	最坏情况下需要比较$n(n-1)/2$次，这比直接基于排序更差
	-	数学分析表明，基于划分的算法平均情况下效率是线性的

-	已经找到一种复杂算法替代Lomuto算法用于在快速选择中选出
	中轴，在最坏情况下保持线性时间效率

-	QuickSelect算法可以不用递归实现，且非递归版本中甚至
	不需要调整参数k值，只需要最后s == k-1即可

-	基于划分的选择算法还解决了：求出给定列表中k个最小元素
	问题

##	查找

###	插值查找

Interpolation Search：查找有序数组，在折半查找的基础上考虑
查找键的值

####	算法

-	假设数组值是线性递增，即*数字值~索引*为一条直线，则根据
	直线方程，可以估计查找键K在A[l..r]所在的位置
	$$
	x = l + \left \lfloor \frac {(K-A[l])(r-l)}
		{A[r] - A[l]} \right \rfloor
	$$

-	若k == A[x]，则算法停止，否则类似折半查找得到规模更小的
	问题

####	特点

-	即使数组值不是线性递增，也不会影响算法正确性，只是每次
	估计查找键位置不够准确，影响算法效率

-	统计考虑
	-	折半插值类似于非参方法，只考虑秩（索引）方向
	-	插值查找类似参数方法，构建了秩（索引）和数组值模型，
		但是线性关系基于假设
	-	如果模型错误可能会比折半查找效率更差，即在数据分布
		分布偏差较大的情况下非参方法好于参数方法

-	所以是否可以考虑取样方法，先取5个点构建模型，然后估计

-	算法效率
	-	对随机列表，算法比较次数小于$log_2log_n+1$
	-	最差情况，比较次数为线性，没有折半查找稳定
	-	Robert Sedgewick的Algorithms中研究表明，对较小文件
		折半查找更好，大文件、比较开销大插值查找更好

###	二叉查找树

对数组构建二叉查找树，在二叉查找树上进行查找

####	算法

-	如果树为空，查找失败
-	若树不为空，将查找键K和树根节点K(r)比较
	-	相等则查找停止
	-	K<K(r)则在左子树中继续查找
	-	K>K(r)则在右子树中继续查找

####	特点

-	算法效率
	-	最差情况下，二叉树完全偏斜，需要进行n次比较
	-	随机情况下，查找n个随机键构造的二叉树比较次数$2logn$

-	构建二叉查找树（插入）和查找操作基本相同，效率特性也相同

##	组合

###	拈游戏

同样局面，每个玩家都有同样可选走法，每种步数有限的走法都能
形成游戏的一个较小实例，最后能移动的玩家就是胜者。

-	拈游戏（单堆版）：只有一堆棋子n个，两个玩家轮流拿走最少
	1个，最多m个棋子
-	拈游戏（多堆版）：有I堆棋子，每堆棋子个数分别为
	${n_1,\dots,n_I}$，可以从任意一堆棋子中拿走任意允许数量
	棋子，甚至拿走全部一堆

####	算法

（单堆）从较小的n开始考虑胜负（标准流程）

-	n=0时，下个人失败
-	1<=n<=m时，下个人胜利（可以拿走全部）
-	n=m+1时，下个人失败（无论拿走几个，对方符合1<=n<=m
	胜利条件）
-	数学归纳法可以证明：n=k(m+1)时为败局，其余为胜局

####	特点

-	堆为2时，需要对两堆是否相同分别考虑
-	对更一般的I堆时
	-	对每堆数量的位串计算*二进制数位和*
	-	结果中包含至少一个1则对下个人为胜局，全为0则为负局
	-	则玩家下步要拿走的棋子数量要使得位串二进制数位和全0
		，则对方陷入负局

	-	#todo又是二进制？？？和约瑟夫斯问题一样了
	-	但是这里没有涉及最多能拿几个啊，不一定能够成功拿到
		使拈和全为0啊
	
>	二进制数位和（拈和）：每位求和并忽略进位（奇或）





