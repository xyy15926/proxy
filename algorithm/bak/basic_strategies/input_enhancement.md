#	输入增强

##	简介

对问题的部分或全部作预处理，存储获得的额外信息，加速之后问题
求解

##	排序

###	比较计数排序

####	算法

-	遍历待排序列表中每个元素
	-	计算、记录列表中小于该元素的元素个数
	-	更新大于其的元素的小于元素的元素个数

```c
ComparisonCountingSort(A[0..n-1])
	// 用比较计数法排序
	// 输入：可排序数组A[0..n-1]
	// 输出：将A中可排序数组按照升序排列数组
	for i = 0 to n-1 do
		count[i] = 0
	for i = 0 to n-2 do
		for j = i+1 to n-1 do
			if A[i] < A[j]
				count[j] += 1
			else
				count[i] += 1
	for i = 0 to n-1 do
		S[count[i]] = A[i]
```

####	特点

-	算法效率
	-	算法比较次数为$n(n-1)/2$
	-	占用了线性数量的额外空间
-	算法使得键值的可能移动次数最小化，能够直接将键值放在在
	有序数组最终位置

###	分布计数排序

-	待排序元素来自于某个已知小集合$[l..u]$

####	算法

-	扫描列表，计算、存储列表中元素出现频率于数组$F[l..u]$中
-	再次扫描列表，根据值填入相应位置

```c
DistributionCountingSort(A[0..n-1], l, u):
	// 分布计数法排序，对元素来自有限范围整数的数组排序
	// 输入：数组[0..n-1]，数组中整数位于l、u间
	// 输出：A中元素构成非降序数组S[0..n-1]
	for j = 0 to u-l do
		D[j] = 0
	for i = 0 to n=1 do
		D[A[i]-l] += 1
	for j = 1 to u-l do
		D[j] += D[j-1]
		// 存储各元素最后出现索引+1
	for i = n-1 downto 0 do
		j = A[i] - l
		S[D[j]-1] = A[i]
		D[j] -= 1
		// 更新应该存储的位置，类似于压栈
	return S
```

####	特点

-	算法效率
	-	如果元素值范围固定，效率为线性（不是基于比较的排序，
		$nlogn$没有限制）
	-	用空间换时间，其实可以看作是hash
	-	利用了输入列表独特自然属性

##	字符串匹配（查找）

###	Horspool算法

算法**从右往左**匹配，在**任意位置**匹配不成功时只考虑
**同模式最后字符匹配的文本字符`c`**，确定安全移动距离，在
不会错过匹配子串的情况下移动最长距离

-	如果`c`在模式中出现，则模式移动到其最后`c`至同文本中`c`
	匹配
-	否则移动模式长度m
-	特别的，如果`c`只在模式最后字符出现，则也应该移动m

####	算法

-	对给定长度m的模式及文本中用到的字母表，构造移动表`t`
-	将模式同文本开始对齐
-	重复以下过程直至发了了匹配子串或模式达到了文本字符外
	-	从模式**最后字符开始**，比较模式、文本相应字符
	-	若m个字符匹配，停止
	-	遇到不匹配字符`c`，若为当前文本中和模式最后匹配字符
		对齐的字符，将模式移动`t(c)`个字符

```c
ShiftTable(P[0..m-1])
	// 用Horspool算法、Boyer-Moore算法填充移动表
	// 输入：模式P[0..m-1]、可能出现字符表
	// 输出：以字符表为为索引的数组Table[0..size-1]
	for i=0 to size-1 do
		Table[i] = m
		// 初始化所有字符对应移动距离为m
	for j=0 to m-2 do
		Table[P[j]] = m - 1 - j
		// 对模式中存在的字符重新计算移动距离
	return Table
```

```c
HorspoolMatching(P[0..m-1], T[0..n-1])
	// 实现Horspool字符串匹配算法
	// 输入：模式P[0..m-1]、文本T[0..n-1]
	// 输出：第一个匹配子串最左端字符下标，未匹配返回-1
	Table = ShiftTable(P[0..m-1])
	i = m - 1
	while i <= n-1 do
		k = 0
		while k <= m-1 and P[m-1-k]=T[i-k] do
			k = k+1
		if k == m
			return i-m+1
		else
			i = i+Table[T[i]]
	return -1
```

####	特点

-	算法效率
	-	最差情况下模式为相同字符，效率$\in O(nm)$
	-	对随机文本效率$\in O(n)$

###	Boyer-Moore算法

-	坏符号移动：模式、文本中相应不匹配字符**确定**的移动
	（不是Horspool中简单根据最后字符确定移动）
-	好后缀移动：模式、文本匹配的后缀**确定**的移动

####	算法

-	对给定长度m的模式及文本用到的字母表，构造坏符号移动表`t`
-	对给定长度m的模式构造后缀移动表
-	将模式与文本开始处对齐
-	重复以下直到找到匹配子串或模式达到文本字符以外
	-	从模式最后字符开始比较模式、文本相应字符
	-	所有m个字符匹配，则停止
	-	若`c`是不匹配字符，移动坏符号表、后缀移动表决定的
		距离较大者

```c
BadSymbolShift(P[0..m-1])
	// 创建坏符号移动表
	// 输入：模式P[0..m-1]
	// 输出：坏符号移动表

```

####	特点

-	算法效率
	-	算法效率最差也是线性的

###	KMP算法

算法**从左往右**匹配，失败时不回溯指针，利用已经得到的
**部分匹配**结果尽可能将模式滑动一段距离，从模式中间*next*
字符开始比较

$$
next[i] =
\left \{ \begin{array} {c}
	-1 & i=0 \\
	Max\{k|0<k<m-1, 'p_0 \cdots p_{k-1}' == \
		'p_{i-k} \cdots p_{i-1}\}' \
		& 此集合不空 \\
	0 & 其他情况 \\
\end{array} \right.
$$

####	算法

```c
KMPShift(P[0..m-1])
	// 计算KMP算法next值
	// 输入：模式P[0..m-1]
	// 输出：模式中各元素next值数组
	i = -1
		// 表示开始比较文本中下个字符
	j = 0
	next[0] = -1
		// 即如果模式首字符都不匹配，比较文本下个字符
	while i < m
		if i == -1 or P[j] == P[i]
			i += 1
			j += 1
			// 当前字符匹配成功，决定下个字符next值
			next[j] = i
		else
			i = next[i]
			// 若当前字符没有匹配成功，不会立即处理下个字符
			// next值，而是反复迭代、查询已匹配部分next值，
			// 以获得最大匹配前缀
	return next
```

```c
KMPShiftVal(P[0..m-1])
	// 计算KMP算法next值修正版（考虑next值与当前相等）
	// 输入：模式P[0..m-1]
	// 输出：模式中各元素next_val值数组u
	i = -1
		// 表示开始比较文本中下个字符
	j = 0
	next_val[0] = -1
	while i < m do
		if i == -1 or P[j] == P[i]
			i += 1
			j += 1
			if T[j] != T[i]
				next_val[j] = i
			else
				next_val[j] = next_val[i]
				// 考虑了next值相同时，可以再滑动一次
				// 这里会导致next_val值跳跃
		else
			i = next_val[i]
	return next_val
```

```c
KMPMatching(P[0..m-1], T[0..n-1])
	// 实现KMP字符串匹配算法
	// 输入：模式P[0..m-1]、文本T[0..n-1]
	// 输出：第一个匹配子串最左端字符下标，未匹配返回-1
	i = 0
	j = 0
	while i < m and j < n do
		if i == -1 or P[i] == T[j]
			i += 1
			j += 1
		else
			i = next[i]
	if i >= m
		return j - m + 1
	else
		return -1
```

####	特点

-	算法效率
	-	算法时间效率$\in O(m+n)$

-	文本指针不需要回溯，整个匹配过程只需要对文本扫描一次，
	对流程处理十分有效，可以边读边匹配

##	Hashing散列

散列法：通过对每个键计算hash function值，得到位于0~m-1之间的
整数的hash address，把键分布在一维数组H[0..m-1] hash table中

###	Hash Function

选择合适散列表长度、散列函数尽可能减少collision

-	散列表长度相对键个数不应该过大避免空间浪费，也不应该过小
	影响算法时间效率

-	散列函数需要把键在散列表单元格中尽量均匀分

	-	所以散列表长度m常常选为质数（方便双散列）
	-	此要求散列函数必须考虑键所有比特位（否则容易发生碰撞）

-	散列函数必须容易计算

###	*load faotor*

负载因子：$\alpha = \frac n m$不应该和1相差太大

-	太大说明链表太长，查找时间很长
-	太小说明存在许多空链表，没有有效利用空间
-	接近1时，平均使用一次两次比较就能完成查找

###	开散列（分离链）

开散列：键被存储在附着于列表单元格上的链表上，每个链表包含
所有散列到该单元格的键（解决碰撞）

####	查找

-	对查找键K，使用同样散列函数计算键散的函数值$h(K)$
-	遍历相应单元格附着链表，查找是否存在键K

#####	算法效率

-	算法效率取决于链表长度，而链表长度取决于字典、散列表长度
	和散列函数质量
	-	成功查找需要检查指针次数$S = 1 + \alpha / 2$
	-	不成功查找需要检查指针次数$U = \alpha$
	-	计算散列函数值是常数时间操作
	-	若n和m大致相等，平均情况下$\in \Theta(1)$

-	算法查找的高效是以额外空间为代价的

####	插入

-	类似于查找，在链表尾部添加键即可
-	若n和m大致相等，平均状态下算法时间效率$\in \Theta(1)$

####	删除

-	查找需要删除的键，在链表移除即可
-	若n和m大致相等，平均情况下算法时间效率$\in \Theta(1)$

###	闭散列（开式寻址）

闭散列：所有键存储在散列表本身中，没有使用链表

-	表长度m至少要和键数量n一样大
-	需要解决碰撞问题

####	Linear Probing

线性探查，检查发生碰撞处后面单元格，如果单元格为空，则放置键
，否则继续查找直接后继（到尾部则循环）

#####	查找

-	给定查找键K，计算散列函数值$h(K)$
-	从$h(K)$开始向后遍历后继，比较K和单元格中键值
	-	若查找到匹配键，查找成功
	-	遇到空单元格，查找失败

#####	删除

闭散列不能直接删除，否则的中间出现空单元格，影响查找正确性

-	延迟删除：用特殊符号标记曾经被占用过、现被删除的位置

#####	算法效率

简化版本近似结论（散列规模越大，近似结论越正确）

-	成功查找访问次数：$S \approx \frac 1 2 (1+\frac 1 {(1-\alpha)})$
-	失败查找访问次数：$U \apporx \frac 1 2 [1+\frac 1 {(1-\alpha)^2}]$

#####	Cluster

聚类：散列表接满时，一序列连续单元格被占据

-	线性探查性能恶化，降低字典操作效率
-	聚类越来的越大时，新元素加入聚类可能性增加
-	大的聚类可能被新插入元素连接，导致更大程度聚合

####	Double Hashing

双散列法：增加一个散列函数$s(K)$，用于确定碰撞发生后，所使用
的探查序列遍历的固定增量

-	被探查序列为：$(h(K)+ i * s(K)) mod m, i=0, 1, 2, \cdots$

-	为了保证散列表中每个位置被探查，增量$s(K)$必须互质
	-	m为质数时自动满足
	-	文献推荐：$s(K) = m - 2 - K mod (m-2)$
	-	对较小散列：$s(K) = 8 - (K mod 8)$
	-	对较大散列：$s(K) = K mod 97 + 1$

#####	算法特点

-	数学分析比较困难，经验表明优秀的散列函数（两个），其性能
	较线性探查好
-	散列表趋满时，性能也会恶化

####	Rehashing

重散列：扫描当前表，将所有键重新放置在更大的表中

-	散列表趋满时唯一解决办法

###	应用

####	字典实现

字典实现主要是：平衡查找树、散列表

||散列表|平衡查找树|
|-----|-----|------|
|渐进时间效率|平均$\in \Theta(1)；最坏$\in \Theta(n)$|$\in \Theta(logn)|
|有序性保留|不假定键有序，不保证，不适合按序遍历、按范围查询|保证|

####	Extendible Hashing

其散列函数计算结果是一个存储段的磁盘地址

-	可扩充散列可用于存储磁盘上非常大型字典
	-	查找时先计算可能包含查找键K的存储段磁盘地址
	-	然后从磁盘中读取段中所有键，从中查找K
	-	存取主存开销较磁盘小很多，宁可多次存取主存










