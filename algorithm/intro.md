#	介绍

##	基础

算法：一系列解决问题的**明确**指令，即对于符合一定规范的
输入，能够在有限时间内获得要求的输出

-	算法每步都必须**没有歧义**
-	必须确定算法所处理的**输入的值域**
-	同一算法可以用几种不同的形式描述
-	同一问题，可能存在几种不同的算法
-	同问题的不同算法，可能基于不同的解题思路，速度也会不同

###	算法正确性证明

-	对某些算法，正确性证明十分简单，对于另一些算法，可能十分
	复杂
-	证明正确性的一般方法是使用数学归纳法，因为算法的迭代过程
	本身就符合其所需的一系列步骤
-	根据特定输入追踪算法操作有意义，但是并不能证明算法的
	正确性，只需要一个算法不能正确处理的输入实例就足够了
-	对于近似算法，常常试图证明算法所产生的误差，不超出预定义
	的误差

###	算法分析

-	时间效率（time efficiency）：算法运行速度
-	空间效率（space efficiency）：算法需要多少额外的存储空间
-	简单性（simplicity）：取决于审视者的眼光
	-	简单的算法更容易理解、实现
	-	相应程序包含更少的bug
-	一般性（generality）
	-	所解决问题的一般性
	-	所接受输入的一般性
-	最优性（optimality）：与所解决问题的复杂度有关，与某算法
	效率无关
-	是否每个问题都能够用算法的方法来解决

###	排序

-	按照升序重新排列给定列表中的数据项
-	为了让问题有意义，列表中的数据项应该能够排序（数据之间
	有一种全序关系）
-	键：在对记录排序时，需要选取的、作为排序的依据的一段信息

####	目的

-	排序可能是所求解的问题输出要求
-	排序能够更方便的求解和列表相关的问题
	-	查找问题
-	在其他领域的重要算法中，排序也被作为辅助步骤

####	发展

-	排序领域已经有很多不错的算法，只需要做$nlog_{x}^{n}$次
	比较就能完成长度为$n$的任意数组排序，且没有一种基于
	**键**值比较（相较于比较键值部分内容而言）的排序算法能
	在本质上操作其，

-	但是还是需要不断探寻新的算法虽然有些算法比其他的要好，
	但是没有任何算法在任何情况下是最优的
	-	有些算法比较简单，但速度较慢
	-	有些算法适合随机排列的输入，而有些适合基本有序的列表
	-	有些算法适合驻留在快速存储器中的列表，而有些适合存储
		在磁盘上的大型文件排序

####	评价

-	稳定性：排序算法保留等值元素在输入中的相对顺序
	-	一般来说，将相隔很远的键交换位置的算法虽然不稳定，
		但往往很快
-	在位性：排序算法不需要额外的存储空间，除极个别存储单元外

###	查找

在给定的集合、多重集（允许多个元素具有相同的值）中找给定值
（查找键，search key）

-	顺序搜索
-	折半查找：效率高但应用受限
-	将原集合用另一种形式表示以方便查找

没有任何一种查找算法在任何情况下都是最优的

-	有些算法速度快，但是需要较多存储空间
-	有些算法速度快，但是只适合有序数组

查找算法没有稳定性问题，但会发生其他问题，如果应用里的数据
相对于查找次数频繁变化，查找问题必须结合添加、删除一起考虑，
此时，必须仔细选择数据结构、算法，以便在各种操作的需求间达到
平衡

###	字符串处理

-	字符串：字母表中符号构成的序列
	-	文本串：字母、数字、特殊符号构成
	-	位串：0、1构成
	-	基因序列：可以使用字符串模型表示，其字母表只包括4个
		字母`{A, C, G, T}`

###	图处理

图：由一些称为顶点的点构成的集合，其中某些顶点由称为边的线段
相连

-	图的遍历算法：如何一次访问到网络中所有节点
-	最短路线算法：两个城市间最佳路线
-	有向图拓扑排序：课程、预备课程是否有矛盾

###	组合问题

寻找（明确地、隐含地）寻找一个组合对象，如：排列、组合、子集
，这些对象能满足特定条件并具有想要地属性，如：价值最大化、
成本最小化。

-	无论从理论角度、实践角度而言，组合问题是计算领域最难的
	问题
	-	随着问题规模增大，组合对象数量增长极快
	-	没有一种已知算法，能在可接受的时间范围内，精确的解决
		大部分组合问题，且被普遍认为不存在（未被证实）
	-	有些组合问题有高效求解算法，是幸运的例外

-	从更抽象的角度看，旅行商问题、图填色问题也是组合问题的
	特例

###	几何问题

处理类似于点、线、多面体这样的几何对象

-	最近对问题：给定平面上的n个点中，距离最近的两个点
-	凸包问题：能把给定集合中所有点都包含在里面的最小凸多边形

###	数值问题

涉及连续性数学问题，如：解方程、方程组，计算定积分，函数求值

-	大部分此类问题只能近似求解
-	此类问题大部分要操作实数，而实数在计算机内部只能近似表示
	，大量对近近似数的算术操作可能会叠加误差，输出错误结果




