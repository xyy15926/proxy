#	算法分析
##	基础

算法：一系列解决问题的**明确**指令，即对于符合一定规范的
输入，能够在有限时间内获得要求的输出

-	算法每步都必须**没有歧义**
-	必须确定算法所处理的**输入的值域**
-	同一算法可以用几种不同的形式描述
-	同一问题，可能存在几种不同的算法
-	同问题的不同算法，可能基于不同的解题思路，速度也会不同

###	算法正确性证明

-	对某些算法，正确性证明十分简单，对于另一些算法，可能十分
	复杂
-	证明正确性的一般方法是使用数学归纳法，因为算法的迭代过程
	本身就符合其所需的一系列步骤
-	根据特定输入追踪算法操作有意义，但是并不能证明算法的
	正确性，只需要一个算法不能正确处理的输入实例就足够了
-	对于近似算法，常常试图证明算法所产生的误差，不超出预定义
	的误差

###	算法分析方向

-	时间效率（time efficiency）：算法运行速度
-	空间效率（space efficiency）：算法需要多少额外的存储空间
-	简单性（simplicity）：取决于审视者的眼光
	-	简单的算法更容易理解、实现
	-	相应程序包含更少的bug
-	一般性（generality）
	-	所解决问题的一般性
	-	所接受输入的一般性
-	最优性（optimality）：与所解决问题的复杂度有关，与某算法
	效率无关
-	是否每个问题都能够用算法的方法来解决

##	分析框架

-	time complexity：算法运行速度
-	space complexity：算法需要的额外空间
	-	算法需要的额外空间已经不是需要重点关注的问题

###	影响因素

####	输入规模$n$

-	几乎所有算法，对规模更大的输入需要运行更长时间，因此使用
	输入规模作为参数很有价值

-	在有些情况下，选择不同的参数表示输入规模有差别

-	选择输入规模的度量单位还受到算法的操作细节影响

-	和数字特性相关的算法，倾向于使用$n$的二进制位数
	$b=\lfloor {log_{2}^{n}} \rfloor + 1$

####	其他因素

有些算法的运行时间不仅取决于输入规模，还取决于特定输入的细节

-	*worst-case efficiency*：最坏情况下的效率
-	*best-case efficiency*：最优情况下的效率
-	*average-case efficiency*
	-	平均效率的研究比最差、优效率研究困难很多
	-	可以将输入划分为几种类型，使得对同类实例，算法基本
		执行次数相同，推导各类输入的概率分布，得到平均次数
-	*amortized efficiency*：应用于算法对同样的数据结构所执行
	的一系列操作
	-	有些情况下，算法单次执行时间代价高，但是n次运行的
		总运行时间明显优于单次执行最差效率 * n

###	衡量角度

####	运行时间

-	使用**时间**标准的度量算法程序运行时间缺陷
	-	计算机速度
	-	程序实现质量
	-	编译器
	-	计时困难

-	找到*basic operation*并计算其运行次数
	-	不依赖于其他无关因素
	-	对总运行时间贡献最大，不需要统计算法每步操作执行次数
	-	如：对排序基本操作为键比较，数学问题则是四则运算，
		需要注意除法、乘法、加减法耗时依次减小

-	时间估计
	-	$c_{op}$：特定计算一个基本操作的执行时间
	-	$C(n)$：算法执行基本操作的次数
	-	$T(n)=c_{op}C(n)$：可以用于估算算法的执行时间
		-	需要小心使用
		-	$C(n)$不包含非基本操作的信息，也只是估计的结果
		-	$c_{op}$也是不可靠的估计值

####	Order of Growth

小规模输入运行时间差别不足以将高效算法与低效算法相区别，
对大规模输入忽略乘法常量，仅关注执行次数的*order of growth*
及其常数倍，即算法的渐进效率

-	按照算法渐进效率进行分类的方法缺乏使用价值，因为没有指定
	乘法常量的值

-	但是对于实际类型输入，除了少数算法，乘法常量之间不会相差
	悬殊，作为规律，即使是中等规模的输入，属于较优渐进
	效率类型的算法也会比来自较差类型的算法效果好

-	对数函数：增长慢，以至于可以认为，对数级操作次数的算法能
	瞬间完成任何实际规模输入
-	指数级：指数函数、阶乘函数
	-	需要指数级操作次数的算法只能用于解决规模非常小的问题

###	渐进效率

####	渐进符号

#####	$O(g(n))$

-	对于足够大的n，$t(n)$的上界由$g(n)$的常数倍确定，则
	$t(n) \in O(g(n))$

-	即存在大于0的常数$c$、非负整数$n_{0}$，使得
	$$ n > n_{0} 时，t(n) \leqslant cg(n) $$

-	增长次数小于等于$g(n) n \rightarrow \infty$
	（及常数倍）的函数集合

#####	$\Omega (g(n))$

-	对于足够大的n，$t(n)$的下界由$g(n)$的常数倍确定，则
	$t(n) \in \Omega(g(n))$

-	即存在大于0的常数$c$、非负整数$n_{0}$，使得
	$$ n > n_{0} 时，t(n) \geqslant cg(n) $$

-	增长次数大于等于$g(n) n \rightarrow \infty$
	（及常数倍）的函数集合

#####	$\Theta (g(n))$

-	对于足够大的n，$t(n)$的上、下界由$g(n)$的常数倍确定，则
	$t(n) \in \Theta(g(n))$

-	即存在大于0的常数$c_{1}, c_{2}$、非负整数$n_{0}$，使得
	$$
	n > n_{0} 时，c_{2}g(n) \leqslant t(n) \leqslant c_{1}g(n)
	$$

-	增长次数等于$g(n) n \rightarrow \infty$（及常数倍）
	的函数集合

####	极限比较增长次数

利用极限比较增长次数：比直接利用定义判断算法的增长次数方便，
可以使用微积分技术计算极限

$$
\lim_{n \rightarrow \infty} \frac {t(n)} {g_n}
\left\{
	\begin{array}\\
	0		& t(n)的增长次数比g(n)小，t(n) \in O(g(n))\\
	c>0		& t(n)的增长次数同g(n)，t(n) \in \Theta(g(n)) \\
	\infty	& t(n)的增长次数比g(n)大，t(n) \in \Omega(g(n))\\
	不存在 \\
	\end{array}
\right.
$$

####	基本渐进效率类型

|类型|名称|注释|
|------|------|------|
|$1$|常量|很少，效率最高|
|$log_{n}$|对数|算法的每次循环都会消去问题规模的常数因子，对数算法不可能关注输入的每个部分|
|$n$|线性|能关注输入每个部分的算法至少是线性运行时间|
|$nlog_{n}$|线性对数|许多分治算法都属于此类型|
|$n^{2}$|平方|包含两重嵌套循环的典型效率|
|$n^{3}$|立方|包含三重嵌套循环的典型效率|
|$2^{n}$|指数|求n个元素的所有子集|
|$n!$|阶乘|n个元素集合的全排列|

##	算法的数学分析

###	非递归算法

####	分析通用方案

1.	决定表示输入规模的参数
2.	找出算法的基本操作：一般位于算法最内层循环
3.	检查算法基本操作执行次数是否只依赖于输入规模，如果和其他
	特性有关，需要分别研究最差、最优、平均效率
4.	建立算法基本操作执行次数的求和表达式（或者是递推关系）
5.	利用求和运算的标准公式、法则建立操作次数的闭合公式，或
	至少确定其增长次数

###	递归算法

用一个方程把squence的generic term和一个或多个其他项相关联，
并提供第一个项或前几项的精确值
$$
\begin{array}\\
	x(n) = x(n-1) + n (n>0) \\
	x(0) = 0
\end{array}
$$
-	*recurrence*：递推式
-	*initial condition*：序列起始值、递归调用结束条件
-	求解：找到序列通项的精确公式满足递推式、初始条件，或者
	证明序列不存在
-	*general solution*：满足**递推方程**所有解序列公式，通常
	会包含参数
-	*particular solution*：满足给定递推方程的特定序列，通常
	感兴趣的是满足初始条件的特解

####	递归求解方法

-	*method of forward substituion*：从序列初始项开始，使用
	递推方程生成给面若干项，从中找出能用闭合公式表示的模式
	-	带入递推方程、初始条件验证
	-	数学归纳法证明

-	*method of backward subsitution*：从序列末尾开始，把序列
	通项$x(n)$表示为$x(n-i)$的函数，使得i是初始条件之一，
	再求和公式得到递推式的解

-	*second-order linear recurrence with constant coefficients*
	：求解*characteristic equation*得到特征根得到通解

####	常见递推类型

#####	*decrease-by-one*

减一法：利用规模为n、n-1的给定实例之间的关系求解问题

-	减常数法特例

$$
\begin{align*}
T(n)& = T(n-1) + f(n) \\
	& = T(n-2) + f(n-2) + f(n) \\
	& = \cdots \\
	& = T(0) + \sum_{j=1}^{n} f(j) \\
\end{align*}
$$

#####	*decrease-by-a-constant-factor*

减常因子法：把规模为n的实例化简为规模为n/b的实例求解问题

$$
\begin{align*}
T(b^{k}) &= T(b^{k-1}) + f(b^{k}) \\
		&= T(b^{k-2}) + f(b^{k-1}) + f(b^{k}) \\
		&= \cdots \\
		&= T(1) + \sum_{j=1}^{k} f(b^{j})
\end{align*}
$$

#####	*divide-and-conquer*

分治法：将给定实例划分为若干较小实例，对每个实例递归求解，如有必要，
再将较小实例的接合并为给定实例的一个解

$$
\begin{align*}
T(b^{k}) &= aT(n/b) + f(n) \\
		&= a[aT(b^{k-2} + f(b^{k-1})] + f(b^{k}) \\
		&= a^{2}T(b^{k-2}) + af(b^{k-1}) + f(b^{k}) \\
		&= a^{2}[aT(b^{k-3} + f(b^{k-2})] + af(b^{k-1}) + f(b^{k}) \\
		&= a^{3}aT(b^{k-3} + a^{2}f(b^{k-2}) + af(b^{k-1}) + f(b^{k}) \\
		&= \cdots \\
		&=a^{k}T(1) + a^{k-1}f(b^{1}) + a^{k-2}f(b^{2}) + \cdots + a^{0}f(b^{k}) \\
		&=a^{k} \left[ T(1) + \sum_{j=1}^{k} \frac {f(b^{j})} {a^{j}} \right] \\

n = b^{k} \\
T(n) &= n^{log_{b}^{a}} \left[ T(1) + \sum_{j=1}^{log_{b}^{n}} \frac {f(b^{j})} {a^{j}} \right]
\end{align*}
$$

####	平滑法则、主定理

-	*eventually nondecreaing*：$f(n)$在自然数上非负，若
	$\exists n_{0}, \forall n_{2} > n_{1} \geqslant n_{0}, f(n_{2}) > f(n_{1})$，
	则为最终非递减

-	*smooth*：$f(n)$在自然数上非负、最终非递减，若
	$f(2n) \in \Theta(f(n))$，则平滑

	-	若$f(n)$平滑，则对任何整数b有$f(bn) \in \Theta(f(n))$

#####	平滑法则

$T(n)$最终非递减，$f(n)$平滑，若$n=b^{k}(b>2)$时有
$T(n) \in \Theta(f(n))$，则$T(n) \in \Theta(f(n))$

#####	主定理

-	方便对分治法、减常因子法效率进行分析

$T(n)$最终非递减，满足递推式

$$
T(n) = aT(n/b) + f(n), \quad n=b^{k}, k=1,2,3,\cdots \\
T(1) = c \\
a \geqslant 1, b \geqslant 2, c > 0
$$
若$f(n) \in \Theta(n^{d}), d \geqslant 0$，则
$$ T(n) \in
\left\{
	\begin{array}\\
	\Theta(n^{d})	& a<b^{d} \\
	\Theta(n^{d}log_{n})	& a=b^{d} \\
	\Theta(n^{log_{b}^{a}})	& a>b^{d} \\
	\end{array}
\right.
$$

####	分析通用方案

1.	决定衡量输入规模的参数
2.	找出算法基本操作
3.	检查算法基本操作执行次数是否只依赖于输入规模，如果和其他
	特性有关，需要分别研究最差、最优、平均效率
4.	建立算法基本操作执行次数的递推关系、相应初始条件
5.	求解递推式，或至少确定其增长次数

