#	C++内存控制

##	内存布局

###	程序内存结构

-	*static area*：静态区，存储程序指令（按位存储）、
	全局变量
	-	位于地址编址号较小、接近地址空间开始处
	-	该区域中分配的内存量在程序整个执行期间不发生改变

-	*stack area*：栈区，存放函数栈帧
	-	最高地址区
	-	程序每调用函数、方法都会在此内存区域中创建新的栈帧，
		函数返回所创建栈帧会被撤销，释放内存
	-	操作迅速，不需要寻址
	-	数据大小已知、固定

-	*heap area*：堆区，程序运行期间动态分配
	-	程序中未分配的可用内存池
	-	处于栈区、静态区之间
	-	缺乏组织
	-	需要寻址、操作速度慢
	-	可以用于存储编译时未知大小、可变数据


> - 堆、栈以相反方向增长，方便任一区域都可以依照需要增长，
	直到所有可用内存耗尽

###	内存分配

> - *static allocation*：静态分配，声明全局变量、常量时，
	编译器为其在静态区中分配在整个程序生命周期内持久的内存
	空间
> - *automatic allocation*：自动分配，调用函数时，编译器为
	局部变量在栈帧分配存储空间，函数返回时空间自动释放
> - *dynamical allocation*：程序允许时，动态获得内存空间

-	*stack frame*：栈帧
	-	栈帧随机为函数中局部变量分配内存、地址
	-	栈帧中还包含额外信息，其结构取决于机器架构

-	变量：C++中声明变量时，编译器必须保证给声明变量分配足够
	内存存储该类型变量值，分配内存大小取决于变量类型

##	*Pointer*

> - C++设计原则：应该尽可能多的访问到有底层硬件提供的机制，
	所以C++语言使得内存位置的地址对程序员可见

指针：值是内存中一个地址的数据项

-	指针允许以压缩方式引用大的数据结构
-	指针使得程序在运行时能够预订新的内存
-	指针可以用于记录数据项之间关系

###	*lvalue*

左值：引用内存中能够存储数据的内存单元的表达式

-	任何左值都存储在内存中，所以都有一个地址
-	左值声明后，地址不会改变，地址中存储的内容可能发生改变
-	左值的地址是一个指针值，可以被存储在内存中的、像数据一样
	被修改

###	指针使用

####	声明指针

```cpp
int *p1, *p2;
```

-	编译器需要知道指针*base type*，才能正确的解释指针地址
	中的数据

-	 `*`用于指明变量为指针变量
	-	语法上属于变量名：声明时需要给每个指针变量标记`*`
	-	但拥有基类型：是用于声明、定义的类型

> - *base type*：基类型，指针所指对象的类型

####	指针使用

-	`&`：取地址
-	`*`：*dereferencing*，解析引用，取指针所指向对象的值
-	`->`：解析+选择操作符，取指针指向对象的成员

####	特殊指针

-	`this`：**指向当前对象**
	-	解决二义性：引用当前对象的实例变量，即使其被形参、
		局部变量覆盖
	-	有建议：总是使用`this`引用当前实例变量使代码更具有
		可读性
	-	类方法调用都将`this`作为隐含参数，指向当前实例，即
		主调函数中类实例

-	`NULL`：*null pointer*，空指针，不指向任何实际内存地址
	-	在内部表示为0
	-	在`<cstddef>`中已定义
	-	使用`*`解释空指针不合法，但不总是能检测出来

####	引用调用

C++内部通过指针实现引用调用

-	参数通过引用传递时，栈帧会在调用时存储一个指针指向该值
	的内存单元
	-	引用参数被声明为引用类型，编译器会自动解析其指针值
-	可以通过明确调用指针替代引用调用的效果

###	*Pointer Arithmetic*

指针运算：对指针进行加减的运算

```cpp
p + k
	// **定义**为：`&array[k]`
*p++
	// 一元运算符右结合，等价于`*(p++)`
	// 检索数组当前元素，并将索引指向下个元素
```

-	只有`+-`运算有意义，且有约束
	-	可以`+-`整数
	-	不能指针相加
	-	可以指针相减，返回两个指针之间数组元素数量

-	建议使用数组索引而不是指针运算提高可靠性

##	*Array*

数组：较低级的多个数据值的集合

-	特性
	-	有序
	-	同质
-	约束
	-	数组分配内存大小固定
	-	数组大小不允许被获得
	-	不支持插入、删除元素
	-	不检查越界：重大安全隐患

> - C++提供的内置数组类型，基于从C语言继承而来的语言模型
> - 考虑到`Vector`集合类更加灵活方便，没有什么理由继续使用
	数组

###	数组使用

```cpp
type name[size];
	// 声明大小为`size`、类型为`type`的数组`name`
name[idx];
	// 选择数组`name`中`idx`处元素
type static_arr [] = {};
	// 数组静态初始化
const int ARR_LEN = sizeof static_arr / sizeof static_arr[0];
	// 获取数组长度
```

-	声明：多数情况下，应该使用符号常量而不是确定的整数值指定
	数组大小，以便修改代码

-	*selection*：通过数组名+`[idx]`选择元素

-	静态初始化：可以忽略数组容量，编译器自动从初始化的元素
	数目推断

-	获取数组分配容量：基于数组同质性

####	数组容量

> - *allocated size*：声明时指定的数组容量
> - *effective size*：实际使用到的元素数目

-	声明比需求大的数组
	-	定义常量表示数组元素数目最大值，以此声明数组

####	指针&数组

数组名同时也**用作**一个指针值，表示数组中首个元素地址

-	如果编译器遇到数组变量名没带下标，则将其解释为指向数组
	开始内存的指针变量

-	C++将数组视为指针最重要的原因：数组形参和实参共享

	-	数组和指针作为形参声明函数完全相同
	-	数组作为实参传递时，其值（首个元素地址）类似指针被
		复制，调用函数中对数组的改变持久
	-	应该使用能反映其用途的方式声明参数，打算用数组作为
		参数就声明参数为数组

-	C++中指针、数组最关键区别：变量声明时内存分配

	-	数组：连续的、可以存储数组元素的内存
	-	指针：存储机器地址的一个字的内存，不能直接存储数据

-	指针作为数组使用

	-	将已存在数组首地址赋给指针有严格限制
	-	真正优势是程序运行时动态分配内存创建数组

##	动态内存管理

###	分配内存

-	动态分配的内存在分配其的栈帧被释放后仍然保持
-	**动态内存分配一定要手动及时释放**

####	`new`

`new`：以某种类型，从堆中分配一块空间给所指定类型的变量

-	`new`操作符返回堆中预留的、存储某类型值的地址

	```cpp
	int *ip = new int;
		// 从堆中分配单个类型空间给指定指针变量
	int *array = new double[4];
		// 从堆上给数组分配空间给指定指针变量
		// 动态数组
	Point *p_1 = new Point;
		// 从堆上给对象、结构体分配空间，调用默认构造函数
	Point *p_2 = new Point(2, 3);
		// 类型名后提供参数，则`new`会调用相应构造函数
	```

-	一旦在堆中分配了空间，可以通过解析指针来引用

####	`xlloc`

###	释放内存

####	`delete`

`delete`：取`new`操作符事先分配内存的指针，释放该指针指向
的内存空间

```cpp
delete ip;
	// 释放单个类型空间指针变量
delete[] array;
	// 释放动态数组
```

####	释放内存策略

-	*garbage collection*：垃圾回收，自动查找不再使用的内存，
	然后释放

###	拷贝

-	*shallow copying*：浅拷贝，C++默认拷贝
	-	如果值是指针，不会拷贝指针所指的值
	-	可以通过重载赋值操作符、构造拷贝构造函数改变默认的
		浅拷贝行为

-	*deep copying*：深拷贝
	-	拷贝指针时，拷贝指针所指的值




