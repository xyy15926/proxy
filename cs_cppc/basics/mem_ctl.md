#	C++内存控制

##	内存布局

###	程序内存结构

-	*static area*：静态区，存储程序指令（按位存储）、
	全局变量
	-	位于地址编址号较小、接近地址空间开始处
	-	该区域中分配的内存量在程序整个执行期间不发生改变

-	*stack area*：栈区，存放函数栈帧
	-	最高地址区
	-	程序每调用函数、方法都会在此内存区域中创建新的栈帧，
		函数返回所创建栈帧会被撤销，释放内存
	-	操作迅速，不需要寻址
	-	数据大小已知、固定

-	*heap area*：堆区，程序运行期间动态分配
	-	程序中未分配的可用内存池
	-	处于栈区、静态区之间
	-	缺乏组织
	-	需要寻址、操作速度慢
	-	可以用于存储编译时未知大小、可变数据


> - 堆、栈以相反方向增长，方便任一区域都可以依照需要增长，
	直到所有可用内存耗尽

###	内存分配

> - *static allocation*：静态分配，声明全局变量、常量时，
	编译器为其在静态区中分配在整个程序生命周期内持久的内存
	空间
> - *automatic allocation*：自动分配，调用函数时，编译器为
	局部变量在栈帧分配存储空间，函数返回时空间自动释放
> - *dynamical allocation*：程序允许时，动态获得内存空间

-	*stack frame*：栈帧
	-	栈帧随机为函数中局部变量分配内存、地址
	-	栈帧中还包含额外信息，其结构取决于机器架构

-	变量：C++中声明变量时，编译器必须保证给声明变量分配足够
	内存存储该类型变量值，分配内存大小取决于变量类型

##	*Pointer*

> - C++设计原则：应该尽可能多的访问到有底层硬件提供的机制，
	所以C++语言使得内存位置的地址对程序员可见

指针：值是内存中一个地址的数据项

-	指针允许以压缩方式引用大的数据结构
-	指针使得程序在运行时能够预订新的内存
-	指针可以用于记录数据项之间关系

###	*Lvalue*、*Rvalue*

> - 左值：引用内存中能够存储数据的内存单元的表达式
> - 右值：非左值表达式

> - 具体参见*cs_program/program_design/language_design*

####	左值引用

左值引用：只能绑定左值，绑定有其他对象内存空间的变量

-	建立引用时是将**内存空间绑定**
	-	使用的是对象在内存中位置
	-	则被引用对象**需要是左值**
	-	则不能将右值绑定到左值引用上

-	**常量左值引用**保证不能通过引用改变对应内存空间值
	-	尝试绑定右值引用时，编译器会自动为右值分配空间
	-	则可以将右值绑定在常量（左值）引用上

```cpp
int foo(42);
int& bar = foo;
	// OK：`foo`是左值，使用其在内存中位置
int& baz = 42;
	// Err：`42`是右值，不能将其绑定在左值引用上
const int& quz = 42;
	// OK：`42`是右值，但编译器可以为其开辟内存空间
int& garply = ++foo;
	// OK：前置自增运算符返回左值
```

####	右值引用

右值引用：**只能且必须**绑定右值

-	考虑右值只能是字面常量、或临时对象，则右值引用
	-	是临时的、即将销毁
	-	**不会在其他地方使用**

-	则接受、使用右值引用的代码，可以自由的接管所引用对象
	的资源，无需担心对其他代码逻辑造成数据破坏

	-	*move sematics*：与右值引用交换成员

```cpp
int foo(42);
int&& baz = foo;
	// Err：`foo`是左值，不能绑定在右值引用上
int&& quz = 42;
	// OK：`42`是右值，可以绑定在右值引用上
int&& quux = foo * 1;
	// OK：`foo * 1`结果是右值，可以绑定在右值引用上
int&& waldo = foo--;
	// OK：后置自减运算符返回右值
```

#####	*Move Sematics*

-	使用左值引用对类型`X`赋值操作流程如下

	```cpp
	X& X::operator=(X const & rhs){
		// make a clone of what rhs.m_pResource refers to
		// destruct the resource this.m_pResource refers to
		// attach the clone to this.m_pResource
	}
	```
	> - `m_pResource`为`X`拥有某种**资源**

-	考虑如下代码中最后一行赋值的执行

	```cpp
	X foo();
	X x;
	x = foo();
	```

	-	克隆`foo()`返回的临时对象中资源
	-	析构`x`中资源，替换为`foo()`返回临时对象中资源副本
	-	析构`foo()`返回临时对象

-	以上赋值流程效率低、没有必要，考虑交换`x`和`foo()`返回
	临时对象资源副本，即*move*语义

	```cpp
	X& x::operator=(X&& rhs){
		// swap this->m_pResource and rhs.m_pResource
	}
	```

	-	执行同样`x=foo()`
		-	此赋值操作只有由编译器自动析构`foo()`返回的临时
			对象
		-	`x.m_pResource`被转移给临时对象，在临时对象析构
			时被析构

	-	交换成员其实和右值引用没有必然联系
		-	在其他方法中同样可以交换成员对象
		-	但是只有在参为右值引用时，交换成员对象确保
			**不会对其他代码逻辑**造成破坏

	-	右值引用参数函数是对左值引用参数函数的重载
		-	编译器优先为右值引用调用以右值引用为形参的函数
		-	区分右值引用、左值引用可以尽量节省资源

#####	*Perfect Forwarding*

完美转发：

####	引用值类型

-	无论左值引用、右值引用
	-	引用作为变量被保留，则其为左值
	-	否则为右值

-	左值引用

	```cpp
	int foo(42);
	int & bar = foo;
		// `bar`是对`foo`的左值引用
	int & baz = bar;
		// `baz`是对`bar`的左值引用
		// `bar`左值引用本身是左值
	int qux = ++foo;
		// 前置自增运算符返回左值引用
		// 此时左值引用作为右值
	```

-	右值引用

	```cpp
	class Type;
	void foo(Type&& bar){
		Type baz(bar);
	}
	Type&& qux();
	quxx = qux();
	```

####	引用叠加

-	C++11中引用叠加规则如下
	-	`Type& &` -> `Type&`
	-	`Type& &&` -> `Type&`
	-	`Type&& &` -> `Type&`
	-	`Type&& &&` -> `Type&&`

-	C++11之前不支持引用叠加，以下代码报错

	```cpp
	typedef int& intR;
	typedef intR& intRR;
	```

###	指针使用

####	声明指针

```cpp
int *p1, *p2;
```

-	编译器需要知道指针*base type*，才能正确的解释指针地址
	中的数据

-	 `*`用于指明变量为指针变量
	-	语法上属于变量名：声明时需要给每个指针变量标记`*`
	-	但拥有基类型：是用于声明、定义的类型

> - *base type*：基类型，指针所指对象的类型

####	指针使用

-	`&`：取地址
-	`*`：*dereferencing*，解析引用，取指针所指向对象的值
-	`->`：解析+选择操作符，取指针指向对象的成员

####	特殊指针

-	`this`：**指向当前对象**
	-	解决二义性：引用当前对象的实例变量，即使其被形参、
		局部变量覆盖
	-	有建议：总是使用`this`引用当前实例变量使代码更具有
		可读性
	-	类方法调用都将`this`作为隐含参数，指向当前实例，即
		主调函数中类实例

-	`NULL`：*null pointer*，空指针，不指向任何实际内存地址
	-	在内部表示为0
	-	在`<cstddef>`中已定义
	-	使用`*`解释空指针不合法，但不总是能检测出来

####	引用调用

C++内部通过指针实现引用调用

-	参数通过引用传递时，栈帧会在调用时存储一个指针指向该值
	的内存单元
	-	引用参数被声明为引用类型，编译器会自动解析其指针值
-	可以通过明确调用指针替代引用调用的效果

###	*Pointer Arithmetic*

指针运算：对指针进行加减的运算

```cpp
p + k
	// **定义**为：`&array[k]`
*p++
	// 一元运算符右结合，等价于`*(p++)`
	// 检索数组当前元素，并将索引指向下个元素
```

-	只有`+-`运算有意义，且有约束
	-	可以`+-`整数
	-	不能指针相加
	-	可以指针相减，返回两个指针之间数组元素数量

-	建议使用数组索引而不是指针运算提高可靠性

##	*Array*

数组：较低级的多个数据值的集合

-	特性
	-	有序
	-	同质
-	约束
	-	数组分配内存大小固定
	-	数组大小不允许被获得
	-	不支持插入、删除元素
	-	不检查越界：重大安全隐患

> - C++提供的内置数组类型，基于从C语言继承而来的语言模型
> - 考虑到`Vector`集合类更加灵活方便，没有什么理由继续使用
	数组

###	数组使用

```cpp
type name[size];
	// 声明大小为`size`、类型为`type`的数组`name`
name[idx];
	// 选择数组`name`中`idx`处元素
type static_arr [] = {};
	// 数组静态初始化
const int ARR_LEN = sizeof static_arr / sizeof static_arr[0];
	// 获取数组长度
```

-	声明：多数情况下，应该使用符号常量而不是确定的整数值指定
	数组大小，以便修改代码

-	*selection*：通过数组名+`[idx]`选择元素

-	静态初始化：可以忽略数组容量，编译器自动从初始化的元素
	数目推断

-	获取数组分配容量：基于数组同质性

####	数组容量

> - *allocated size*：声明时指定的数组容量
> - *effective size*：实际使用到的元素数目

-	声明比需求大的数组
	-	定义常量表示数组元素数目最大值，以此声明数组

####	指针&数组

数组名同时也**用作**一个指针值，表示数组中首个元素地址

-	如果编译器遇到数组变量名没带下标，则将其解释为指向数组
	开始内存的指针变量

-	C++将数组视为指针最重要的原因：数组形参和实参共享

	-	数组和指针作为形参声明函数完全相同
	-	数组作为实参传递时，其值（首个元素地址）类似指针被
		复制，调用函数中对数组的改变持久
	-	应该使用能反映其用途的方式声明参数，打算用数组作为
		参数就声明参数为数组

-	C++中指针、数组最关键区别：变量声明时内存分配

	-	数组：连续的、可以存储数组元素的内存
	-	指针：存储机器地址的一个字的内存，不能直接存储数据

-	指针作为数组使用

	-	将已存在数组首地址赋给指针有严格限制
	-	真正优势是程序运行时动态分配内存创建数组

##	动态内存管理

###	分配内存

-	动态分配的内存在分配其的栈帧被释放后仍然保持
-	**动态内存分配一定要手动及时释放**

####	`new`

`new`：以某种类型，从堆中分配一块空间给所指定类型的变量

-	`new`操作符返回堆中预留的、存储某类型值的地址

	```cpp
	int *ip = new int;
		// 从堆中分配单个类型空间给指定指针变量
	int *array = new double[4];
		// 从堆上给数组分配空间给指定指针变量
		// 动态数组
	Point *p_1 = new Point;
		// 从堆上给对象、结构体分配空间，调用默认构造函数
	Point *p_2 = new Point(2, 3);
		// 类型名后提供参数，则`new`会调用相应构造函数
	```

-	一旦在堆中分配了空间，可以通过解析指针来引用

####	`xlloc`

###	释放内存

####	`delete`

`delete`：取`new`操作符事先分配内存的指针，释放该指针指向
的内存空间

```cpp
delete ip;
	// 释放单个类型空间指针变量
delete[] array;
	// 释放动态数组
```

####	释放内存策略

-	*garbage collection*：垃圾回收，自动查找不再使用的内存，
	然后释放

###	拷贝

-	*shallow copying*：浅拷贝，C++默认拷贝
	-	如果值是指针，不会拷贝指针所指的值
	-	可以通过重载赋值操作符、构造拷贝构造函数改变默认的
		浅拷贝行为

-	*deep copying*：深拷贝
	-	拷贝指针时，拷贝指针所指的值




