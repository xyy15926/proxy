继承、Mixin

a.	多重继承问题

	1.	结果复杂化：相较于单一继承明确的父类，多重继承父类和子类之间的
			关系比较复杂

	2.	优先顺序模糊：子类同时继承父类和“祖先类”时，继承的方法顺序不明确

	3.	功能冲突：多重继承的多个父类之间可能有冲突的方法

b.	多重继承优点#todo

c.	多重继承问题解决方案

	1.	规格继承

		a.	使用inteface、traits这些结构实现”多重继承“

		b.	普遍意义上的单一继承

			1.	类只能“单一继承”父类

			2.	但是可以“继承”多个interface，traits

			3.	interface、traits中只能包含方法，而没有具体实现

		c.	方案问题

			1.	即使“继承”interface也需要重新实现方法

			2.	只是通过规定解决多重继承的问题，但是也损失优点

		d.	弥补技巧：delegate（代理）

			1.	对interface itf实现一个公用实现impl

			2.	对其他“继承”itf的类itf_cls声明一个itf类型的变量itf_var

			3.	并将公用实现的一个实例赋值给这个itf类型的变量

			4.	这样itf_cls中itf方法的实现就可以直接使用itf_var调用impl的方法

			5.	示例（java）
				interface itf{ func()=0; };
				class itf_impl implements itf{ func()={}; }
				class itf_cls implements itf, others{ itf itf_var;}

	2.	实现继承：方法+实现的集合

		a.	普遍意义上多重继承

			1.	类可以继承多个父类

			2.	多个父类没有要求其中不能包含方法的实现

		b.	方案问题：就是多重继承的普遍问题

		c.	弥补技巧：mixin（混入）

			1.	每个类只“逻辑上”继承一个类，其他只继承mixin类

				a.	mixin类单一职责

				b.	mixin对宿主类（子类）无要求

				c.	宿主类（子类）不会因为去掉mixin类而受到影响，
					不调用超类方法避免引起MRO查找顺序问题

			2.	mixin思想同规则继承

				a.	均是将父类划分为：逻辑父类、逻辑特性族

				b.	但是规则继承是**禁止**“多重继承”，而mixin只是有效方案

				c.	mixin对开发者要求更严格，需要自查是否符合mixin原则

			3.	示例（python）
				class mixin_cls(){}
				class sub_cls(super_cls, mixin_cls){}
