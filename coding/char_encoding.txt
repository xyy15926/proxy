编码问题

1.	抽象字符集（ACR，abstract charater repertoire）

	a.	字符：字母、数字、标点、表意文字（汉字）、符号或其他文本形式的“原子”

	b.	抽象字符：抽象的字符，包括空白、不可打印的字符

		1.	对于某些语言中，抽象字符应该还包括发音字符

		2.	如在印度语中单词
			“नमस्ते”中有6个字符['न', 'म', 'स', '्', 'त', 'े']，
			其中4、6两个字符在单词不出现，是发音字符

	c.	抽象字符集：抽象字符的集合

		1.	集合表面无序性

		2.	有时也简称为字符集（charater set）

		3.	有开放（字符不会改变）和封闭之分（会扩张）

2.	编码字符集（CCS，coded character set）

	a.	码位（code point）：抽象字符集中与字符关联的数字编号

		1.	一般是非负整数

		2.	习惯上有16进制表示

	b.	编码字符集：每个所属字符都分配了码位的抽象字符集

		1.	经常简称为字符集（charater set），同ACR弄混

		2.	字符与码位一一映射

		3.	可以更加方便的引用字符集中的某个元素

		4.	可以类比于dict

	c.	（抽象、编码）字符集举例：

		1.	US-ASCII

			a.	128个抽象字符，封闭字符集

			b.	一般字符集都是兼容ascii编码字符集，即同一字符的码位相同

		2.	GBK：2w+中日韩汉字和其他一些字符，包括

			a.	gb2312/gb0：国标简体，6713个，涵盖绝大部分日常生活

			b.	big5：台湾繁体，13053

			c.	外加一些符号和少数民族文字

		3.	UCS(Unicode, universal character set)

			a.	统一字符集，ISO/IEC 10646定义的编码字符集（unicode字符集）

			b.	容纳一切字符，包括emoji等，开放字符集

			c.	unicode中码位不是连续分配的

				1.	目前为止，分为0x0000~0x10FFFF共17个平面

				2.	其中0平面0x0000~0xFFFF称为BMP（basic multilingual plane）

				3.	BMP中码位只有16bit长度，能够节约大量存储空间，有战略意义

				4.	因此“常用”语言的常用字符放在BMP，其他不常用的字符只能放在其他平面

			d.	unicode本身是指一系列用于计算机表示所有语言字符的标准

3.	字符编码表（CEF，character encoding form）

	a.	码元：能用于处理或交换编码文本的最小比特组合

	b.	字符编码表：将码位映射为码元序列

		1.	开放字符集包括的符号无上限，无法定长bits表示码位

		2.	需要一种方式将码位一一映射为码元序列

	c.	unicode定义的CEF

		1.	utf-8
		
			a.	码元为1B

			b.	对BMP中字符一般需要1~3B，BMP外需要4B

			c.	对“ascii编码表（方案）”实现了兼容

				1.	和编码字符集兼容不一样

				2.	指使用“ascii编码方案”可以使用utf-8解码方案直接解码

		2.	utf-16

			a.	码元为2B

			b.	对BMP中字符一般需要2B，BMP外需要4B

		3	utf-32：码元为4B

		4.	本质思想：预留标记位值是码元序列的长度实现变长

4.	字符编码方案（CES，character encoding schema）

	a.	字符编码方案：字符编码表+字节序列化方案，将码位映射为字节流

		1.	大小端序问题：码元高位还是低位字节在前

		2.	字节序标记问题：不同程序之间端序交流

		3.	注意

			a.	字符编码方案不仅仅是在硬盘文件中使用，在内存也是按照字符编码方案存储字符串

			b.	理由很简单，内存中如果不使用字符编码方案，直接使用码元，一样会出现长度问题

			c.	以上对于unicode而言，对于ascii来说没有区分必要

		4.	需要分清两个编码字节流和字符

			a.	虽然在内存中，字符仍然使用某种编码方案得到字节流存储

			b.	但这个字节流并不是这个字符，码位才”是“这个字符

			c.	在考虑字符串问题时，可以“抽象的”忽略具体存储方式，认为存储的就是“码位”本身

	b.	字节序标记（BOM，byte order mark）

		1.	放置于编码字节开始处的特殊字节序列，表示序列大小端序

			a.	0xFFFE

			b.	0xFEFF

		2.	unicode不同CEF有不同方案

			a.	utf-8：utf-8编码表码元为1B，不存在字节序问题

			b.	utf-16le：utf-16编码表小端版本

			c.	utf-16be：utf-16编码表大端版本

			d.	utf-16：utf-16编码表带BOM版本，大小端均可

			e.	utf-32le

			f.	utf-32be

			g.	utf-32

	c.	注意

		1.	utf（unicode transfromation format）历史上是指CES

		2.	utf-X可以同时指代CES和CEF

			a.	utf-8：指代CES和CEF没有什么区别，CEF只有一种

			b.	utf-16：指代CES和CEF时有歧义

				1.	utf-16 encoding form的码元序列

				2.	utf-16 encoding schema的字节流

			c.	utf-32

		3.	通常所说编码、解码（encode、decode）就是指使用CES

		4.	unicode还有两种非标准CES

			a.	ucs-2：使用2B定长序列化码位

			b.	ucs-4：使用4B定长序列化码位

		5.	其他字符集：US-ASCII、GBK都有自己的编码方案，只是编码方案太简单，以至于CCS、CEF、CES三层合一

5.	传输编码语法（TES，transfer encoding syntax）

	a.	传输编码语法：有时候仅仅将字符表示为字节流还不够，有些字符可能不允许出现，需要对字节流再次编码

	b.	举例

		1.	base64编码：将字节流映射成64个安全字符集组成的字符流

6.	输入、输出辨析

	a.	输入

		1.	所有的输入都是字节流，包括数字

		2.	字节流具体内容由输入来源的编码方案决定

			a.	文件：文件编码方案决定

			b.	terminal：terminal编码方案决定

			c.	传输流：也是由输出端的编码方案决定

		3.	即同一个字符（码元）的具体输入字节流随输入编码方案决定

	b.	处理：取决于解释器、编译器、系统等处理主体的编码方案

		1.	感觉上应该将输入字节流视为其自身编码方案字节流，直接储存

		2.	在这一步就可能出现两个编码方案不一致的情况

	c.	输出

		1.	所有的输出也都是字节流，包括数字

		2.	输出的去向

			a.	文件：write

			b.	terminal：标准输出, print

			c.	传输流

		3.	这个输出是指传递给“直接输出”函数的输出

			a.	其中可能会隐式调用一些转换为字符串的函数（面向对象语言中）

			b.	这个“字符串”实际上就是主体编码后的字节流

	d.	显示：底层函数将收到的主体编码字节流直接传递给显示程序（terminal等），如果显示程序和主体编码方案不同会出现乱码

		wrong：
		1.	负责显示的函数是底层函数，比如print这样的函数，函数同样使用的是处理主体使用的编码方案

		2.	输出应该是把编码后的字节流传给这些底层函数，由这些底层函数解码为码元

		3.	底层函数继续根据系统使用的字体，从中查找对应的“图像”

	e.	以utf-8编码方案为例

		1.	输入的所有的内容都是由utf-8编码方案编码的字节流

		2.	处理主体获取字节序列

		3.	根据指令处理字节序列

			a.	比如字节序列编码和处理主体编码不同，将其“解码”为主体编码方案

			b.	比如按照“约定”将字节序列转变为不同类型的数据

		4.	输出则是将需要输出的内容（包括数字等）转换字节流传给底层函数

